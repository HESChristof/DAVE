<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>DAVE.marine API documentation</title>
<meta name="description" content="This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.marine</code></h1>
</header>
<section id="section-intro">
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/.">http://mozilla.org/MPL/2.0/.</a></p>
<p>Ruben de Bruin - 2019</p>
<p>Helper functions for Marine analysis</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Ruben de Bruin - 2019

  Helper functions for Marine analysis

&#34;&#34;&#34;

from DAVE.scene import *
import matplotlib.pyplot as plt


def GZcurve_DisplacementDriven(scene, vessel_node, displacement_kN=None, minimum_heel= 0, maximum_heel=90, steps=180, teardown=True, allow_surge=False, allow_sway=False, allow_yaw=False, allow_trim=True, noplot = False, noshow = False):
    &#34;&#34;&#34;This works for vessels without a parent.

    The vessels slaved to an axis system and its heel angle is fixed and enforced. After solving statics the GZ
    curve is derived from the resulting moment on the connection.

    The vessels heel and yaw are fixed.
    The vessel is free to heave, trim, and
    Only the vessels heel angle is fixed. The vessel is free to heave and trim.

    Args:
        scene:          the scene
        vessel_node:    the vessel node or vessel node name
        displacement_kN: displacement to be used (default value of 1 results in moment in kN*m instead of arm in m)
        minimum_heel    minimum heel, begin of the curve (0)
        maximum_heel    maximum heel, end of the curve (90)
        steps:          number of steps (use un-even number to capture 0)
        teardown:       remove the helper elements after the calculation
        allow_surge:    (False)
        allow_sway:     (False)
        allow_yaw:      (False)
        allow_trim:     (True)
        noplot:         Do not plot results [False]
        noshow:         Do plot but do not do plt.show() [False]

    Returns:
        dictionary with heel, moment, and GM

    &#34;&#34;&#34;



    # --------- verify input -----------


    s = scene # lazy

    if minimum_heel &gt; maximum_heel:
        raise ValueError(&#39;Minimum heel should be smaller than maximum heel&#39;)

    # vessel_node should not have a parent
    vessel = s._node_from_node_or_str(vessel_node)
    if vessel.parent is not None:
        raise ValueError(&#34;Vessel should not have a parent. Got {} as vessel which has parent {}.&#34;.format(vessel.name, vessel.parent.name))

    no_displacement = False
    if displacement_kN is None: # default value
        no_displacement = True
        displacement_kN = 1

    if minimum_heel == maximum_heel and steps&gt;1:
        raise ValueError(&#34;Can not take multiple steps of min and max value are identical&#34;)

    # --------------- store current state -------

    # store current vessel props
    _position = vessel.position
    _rotation = vessel.rotation
    _fixed = vessel.fixed
    _verbose = s.verbose
    s.verbose = False

    # --------- construct system to impose heel ---------

    # construct axis system at vessel origin
    name = s.available_name_like(vessel.name + &#34;_global_motion&#34;)
    global_motion = s.new_axis(name, parent=vessel) # construct at vessel origin
    global_motion.change_parent_to(None)
    global_motion.fixed = (not allow_surge,
                           not allow_sway,
                           False,               # heave allowed
                           True, True,
                           not allow_yaw)

    trim_motion = s.new_axis(s.available_name_like(vessel.name + &#34;_trim_motion&#34;), parent=global_motion)

    if allow_trim:
        trim_motion.fixed = (True,True,True,
                             True,False,True) # allow for trim (rotation about y)
    else:
        trim_motion.set_fixed()

    name = s.available_name_like(vessel.name + &#34;_heel&#34;)
    heel_node = s.new_axis(name, parent=trim_motion)

    heel_node.set_fixed()
    vessel.change_parent_to(heel_node)
    vessel.set_fixed()

    # record dofs
    s._vfc.state_update()
    D0 = s._vfc.get_dofs()

    # ----------------- do the calcs ---------------

    heel = np.linspace(minimum_heel,maximum_heel,num=steps)
    moment = list()
    trim = list()

    for x in heel:
        s._vfc.set_dofs(D0)
        heel_node.rx = x
        s.solve_statics(silent=True)
        moment.append(-heel_node.applied_force[3])
        trim.append(trim_motion.ry)

    if no_displacement:
        GM = np.nan
    else:
        GZ = np.array(moment, dtype=float) / displacement_kN
        # calculate GM, but only if zero is part of the heel curve and at least two points
        if (np.max(heel)&gt;=0 and np.min(heel)&lt;=0 and len(heel)&gt;1):
            GMs = np.diff(GZ) / np.diff(np.deg2rad(heel))
            heels = 0.5*(heel[:-1] + heel[1:])
            GM = np.interp(0,heels, GMs)
        else:
            GM = np.nan

        # restore dofs
        s._vfc.set_dofs(D0)

    # ----------- plot the results -----------

    if not noplot:

        if allow_trim:
            plt.plot(heel, trim, color=&#39;black&#39;, marker=&#39;+&#39;)
            plt.xlabel(&#39;Imposed Heel angle [deg]&#39;)
            plt.ylabel(&#39;Solved trim angle [deg]&#39;)
            plt.title(&#39;Trim resulting from imposed heel&#39;)
            plt.grid()
            plt.figure()

        plt.xlabel(&#39;Heel angle [deg]&#39;)
        what = &#39;moment&#39;
        if no_displacement:
            plt.plot(heel, moment, color=&#39;black&#39;, marker=&#39;+&#39;)
            plt.ylabel(&#39;Restoring moment [kN*m]&#39;)
        else:
            plt.plot(heel, GZ, color=&#39;black&#39;, marker=&#39;+&#39;)
            what = &#39;arm&#39;
            plt.ylabel(&#39;GZ [m]&#39;)

            # plot the GM line
            yy = plt.ylim()
            xmax = np.rad2deg(yy[1] / GM)
            xmin = np.rad2deg(yy[0] / GM)

            xmin = np.max([xmin, np.min(heel)])
            xmax = np.min([xmax, np.max(heel)])


            plt.plot([xmin, xmax], [np.deg2rad(xmin)*GM, np.deg2rad(xmax)*GM])
            box_props = dict(boxstyle=&#39;round&#39;, facecolor=&#39;gold&#39;, alpha=1)
            plt.text(xmax,np.deg2rad(xmax)*GM,&#39;GM = {:.2f}&#39;.format(GM),horizontalalignment=&#39;left&#39;,bbox=box_props)

        plt.title(&#39;Restoring {} curve for {}&#39;.format(what, vessel.name))

        plt.grid()
        if not noshow:
            plt.show()

    # -------- clean up -----------

    if teardown:
        vessel.change_parent_to(None)
        s.delete(global_motion)

        # store current vessel props
        vessel.position = _position
        vessel.rotation = _rotation
        vessel.fixed = _fixed

    s.verbose = _verbose

    # --------- collect return values --------
    r = dict()
    r[&#39;heel&#39;] = heel

    if not no_displacement:
        r[&#39;GM&#39;] = GM
        r[&#39;GZ&#39;] = moment
    else:
        r[&#39;moment&#39;] = moment

    return r


def GZcurve_MomentDriven():

    &#34;&#34;&#34;Calculates the GZ curve by applying a heeling moment and calculating the resulting heel angle. This method allows for
    accurate calculation of the curve up till approximately the maximum of the curve.

    - Where to apply moment (poi / body)
    - Where to obtain roll (body)
    - Where to get displacement from

    Returns:

    &#34;&#34;&#34;

    # Store the current DOFs of the model
    # start with a moment (can not be obtained from the GM as more than one buoyancy object may be present)
    #</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DAVE.marine.GZcurve_DisplacementDriven"><code class="name flex">
<span>def <span class="ident">GZcurve_DisplacementDriven</span></span>(<span>scene, vessel_node, displacement_kN=None, minimum_heel=0, maximum_heel=90, steps=180, teardown=True, allow_surge=False, allow_sway=False, allow_yaw=False, allow_trim=True, noplot=False, noshow=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This works for vessels without a parent.</p>
<p>The vessels slaved to an axis system and its heel angle is fixed and enforced. After solving statics the GZ
curve is derived from the resulting moment on the connection.</p>
<p>The vessels heel and yaw are fixed.
The vessel is free to heave, trim, and
Only the vessels heel angle is fixed. The vessel is free to heave and trim.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene</code></strong></dt>
<dd>
<pre><code> the scene
</code></pre>
</dd>
<dt><strong><code>vessel_node</code></strong></dt>
<dd>the vessel node or vessel node name</dd>
<dt><strong><code>displacement_kN</code></strong></dt>
<dd>displacement to be used (default value of 1 results in moment in kN*m instead of arm in m)</dd>
<dt>minimum_heel
minimum heel, begin of the curve (0)</dt>
<dt>maximum_heel
maximum heel, end of the curve (90)</dt>
<dt><strong><code>steps</code></strong></dt>
<dd>
<pre><code> number of steps (use un-even number to capture 0)
</code></pre>
</dd>
<dt><strong><code>teardown</code></strong></dt>
<dd>
<p>remove the helper elements after the calculation</p>
</dd>
<dt><strong><code>allow_surge</code></strong></dt>
<dd>(False)</dd>
<dt><strong><code>allow_sway</code></strong></dt>
<dd>
<p>(False)</p>
</dd>
<dt><strong><code>allow_yaw</code></strong></dt>
<dd>
<p>(False)</p>
</dd>
<dt><strong><code>allow_trim</code></strong></dt>
<dd>
<p>(True)</p>
</dd>
<dt><strong><code>noplot</code></strong></dt>
<dd>
<pre><code>Do not plot results [False]
</code></pre>
</dd>
<dt><strong><code>noshow</code></strong></dt>
<dd>
<pre><code>Do plot but do not do plt.show() [False]
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionary</code> <code>with</code> <code>heel</code>, <code>moment</code>, <code>and</code> <code>GM</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GZcurve_DisplacementDriven(scene, vessel_node, displacement_kN=None, minimum_heel= 0, maximum_heel=90, steps=180, teardown=True, allow_surge=False, allow_sway=False, allow_yaw=False, allow_trim=True, noplot = False, noshow = False):
    &#34;&#34;&#34;This works for vessels without a parent.

    The vessels slaved to an axis system and its heel angle is fixed and enforced. After solving statics the GZ
    curve is derived from the resulting moment on the connection.

    The vessels heel and yaw are fixed.
    The vessel is free to heave, trim, and
    Only the vessels heel angle is fixed. The vessel is free to heave and trim.

    Args:
        scene:          the scene
        vessel_node:    the vessel node or vessel node name
        displacement_kN: displacement to be used (default value of 1 results in moment in kN*m instead of arm in m)
        minimum_heel    minimum heel, begin of the curve (0)
        maximum_heel    maximum heel, end of the curve (90)
        steps:          number of steps (use un-even number to capture 0)
        teardown:       remove the helper elements after the calculation
        allow_surge:    (False)
        allow_sway:     (False)
        allow_yaw:      (False)
        allow_trim:     (True)
        noplot:         Do not plot results [False]
        noshow:         Do plot but do not do plt.show() [False]

    Returns:
        dictionary with heel, moment, and GM

    &#34;&#34;&#34;



    # --------- verify input -----------


    s = scene # lazy

    if minimum_heel &gt; maximum_heel:
        raise ValueError(&#39;Minimum heel should be smaller than maximum heel&#39;)

    # vessel_node should not have a parent
    vessel = s._node_from_node_or_str(vessel_node)
    if vessel.parent is not None:
        raise ValueError(&#34;Vessel should not have a parent. Got {} as vessel which has parent {}.&#34;.format(vessel.name, vessel.parent.name))

    no_displacement = False
    if displacement_kN is None: # default value
        no_displacement = True
        displacement_kN = 1

    if minimum_heel == maximum_heel and steps&gt;1:
        raise ValueError(&#34;Can not take multiple steps of min and max value are identical&#34;)

    # --------------- store current state -------

    # store current vessel props
    _position = vessel.position
    _rotation = vessel.rotation
    _fixed = vessel.fixed
    _verbose = s.verbose
    s.verbose = False

    # --------- construct system to impose heel ---------

    # construct axis system at vessel origin
    name = s.available_name_like(vessel.name + &#34;_global_motion&#34;)
    global_motion = s.new_axis(name, parent=vessel) # construct at vessel origin
    global_motion.change_parent_to(None)
    global_motion.fixed = (not allow_surge,
                           not allow_sway,
                           False,               # heave allowed
                           True, True,
                           not allow_yaw)

    trim_motion = s.new_axis(s.available_name_like(vessel.name + &#34;_trim_motion&#34;), parent=global_motion)

    if allow_trim:
        trim_motion.fixed = (True,True,True,
                             True,False,True) # allow for trim (rotation about y)
    else:
        trim_motion.set_fixed()

    name = s.available_name_like(vessel.name + &#34;_heel&#34;)
    heel_node = s.new_axis(name, parent=trim_motion)

    heel_node.set_fixed()
    vessel.change_parent_to(heel_node)
    vessel.set_fixed()

    # record dofs
    s._vfc.state_update()
    D0 = s._vfc.get_dofs()

    # ----------------- do the calcs ---------------

    heel = np.linspace(minimum_heel,maximum_heel,num=steps)
    moment = list()
    trim = list()

    for x in heel:
        s._vfc.set_dofs(D0)
        heel_node.rx = x
        s.solve_statics(silent=True)
        moment.append(-heel_node.applied_force[3])
        trim.append(trim_motion.ry)

    if no_displacement:
        GM = np.nan
    else:
        GZ = np.array(moment, dtype=float) / displacement_kN
        # calculate GM, but only if zero is part of the heel curve and at least two points
        if (np.max(heel)&gt;=0 and np.min(heel)&lt;=0 and len(heel)&gt;1):
            GMs = np.diff(GZ) / np.diff(np.deg2rad(heel))
            heels = 0.5*(heel[:-1] + heel[1:])
            GM = np.interp(0,heels, GMs)
        else:
            GM = np.nan

        # restore dofs
        s._vfc.set_dofs(D0)

    # ----------- plot the results -----------

    if not noplot:

        if allow_trim:
            plt.plot(heel, trim, color=&#39;black&#39;, marker=&#39;+&#39;)
            plt.xlabel(&#39;Imposed Heel angle [deg]&#39;)
            plt.ylabel(&#39;Solved trim angle [deg]&#39;)
            plt.title(&#39;Trim resulting from imposed heel&#39;)
            plt.grid()
            plt.figure()

        plt.xlabel(&#39;Heel angle [deg]&#39;)
        what = &#39;moment&#39;
        if no_displacement:
            plt.plot(heel, moment, color=&#39;black&#39;, marker=&#39;+&#39;)
            plt.ylabel(&#39;Restoring moment [kN*m]&#39;)
        else:
            plt.plot(heel, GZ, color=&#39;black&#39;, marker=&#39;+&#39;)
            what = &#39;arm&#39;
            plt.ylabel(&#39;GZ [m]&#39;)

            # plot the GM line
            yy = plt.ylim()
            xmax = np.rad2deg(yy[1] / GM)
            xmin = np.rad2deg(yy[0] / GM)

            xmin = np.max([xmin, np.min(heel)])
            xmax = np.min([xmax, np.max(heel)])


            plt.plot([xmin, xmax], [np.deg2rad(xmin)*GM, np.deg2rad(xmax)*GM])
            box_props = dict(boxstyle=&#39;round&#39;, facecolor=&#39;gold&#39;, alpha=1)
            plt.text(xmax,np.deg2rad(xmax)*GM,&#39;GM = {:.2f}&#39;.format(GM),horizontalalignment=&#39;left&#39;,bbox=box_props)

        plt.title(&#39;Restoring {} curve for {}&#39;.format(what, vessel.name))

        plt.grid()
        if not noshow:
            plt.show()

    # -------- clean up -----------

    if teardown:
        vessel.change_parent_to(None)
        s.delete(global_motion)

        # store current vessel props
        vessel.position = _position
        vessel.rotation = _rotation
        vessel.fixed = _fixed

    s.verbose = _verbose

    # --------- collect return values --------
    r = dict()
    r[&#39;heel&#39;] = heel

    if not no_displacement:
        r[&#39;GM&#39;] = GM
        r[&#39;GZ&#39;] = moment
    else:
        r[&#39;moment&#39;] = moment

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.marine.GZcurve_MomentDriven"><code class="name flex">
<span>def <span class="ident">GZcurve_MomentDriven</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the GZ curve by applying a heeling moment and calculating the resulting heel angle. This method allows for
accurate calculation of the curve up till approximately the maximum of the curve.</p>
<ul>
<li>Where to apply moment (poi / body)</li>
<li>Where to obtain roll (body)</li>
<li>Where to get displacement from</li>
</ul>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GZcurve_MomentDriven():

    &#34;&#34;&#34;Calculates the GZ curve by applying a heeling moment and calculating the resulting heel angle. This method allows for
    accurate calculation of the curve up till approximately the maximum of the curve.

    - Where to apply moment (poi / body)
    - Where to obtain roll (body)
    - Where to get displacement from

    Returns:

    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DAVE" href="index.html">DAVE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DAVE.marine.GZcurve_DisplacementDriven" href="#DAVE.marine.GZcurve_DisplacementDriven">GZcurve_DisplacementDriven</a></code></li>
<li><code><a title="DAVE.marine.GZcurve_MomentDriven" href="#DAVE.marine.GZcurve_MomentDriven">GZcurve_MomentDriven</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>