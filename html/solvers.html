<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>DAVE.solvers.ballast API documentation</title>
<meta name="description" content="Ballasting" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.solvers.ballast</code></h1>
</header>
<section id="section-intro">
<p>Ballasting</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Ballasting
&#34;&#34;&#34;
import numpy as np
from scipy.optimize import minimize, minimize_scalar
import matplotlib.pyplot as plt

from DAVE.scene import *
import DAVE.settings as ds


def visualize_optimiaztion(fun, xlim, ylim):
    step = 1
    x,y = np.meshgrid(np.arange(xlim[0], xlim[1] + step, step),
                      np.arange(ylim[0], ylim[1] + step, step))
    def fun2(x,y):
        return fun([x,y])

    funn = np.vectorize(fun2)
    z = funn(x,y)

    fig = plt.figure(figsize=(8, 5))

    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib.colors import LogNorm

    ax = plt.axes(projection=&#39;3d&#39;, elev=50, azim=-50)

    ax.plot_surface(x, y, z, norm=LogNorm(), rstride=1, cstride=1,
                    edgecolor=&#39;none&#39;, alpha=.8, cmap=plt.cm.jet)

    plt.show()





def force_vessel_to_evenkeel_and_draft(scene, vessel, z):
    &#34;&#34;&#34;
    Calculates the required force to be applied to place the vessel even-keel at the given vertical position (-draft if origin is at keel).

    Args:
        scene:  Scene
        vessel: Vessel node or vessel node name
        draft:  requested vertical position of vessel axis system origin. If the vessel origin is at the keel than this is minus draft

    Returns:
        Required external force and position (F,x,y) to be applied to the the vessel to the given position
    &#34;&#34;&#34;



    vessel = scene._node_from_node_or_str(vessel)

    # store old props
    # old_position = vessel.position
    # old_rotation = vessel.rotation
    old_parent = vessel.parent
    old_fixed = vessel.fixed

    if vessel.parent is not None:
        raise Exception(&#39;Vessel with parent : not yet implemented&#39;)

    # Create a dummy at the vessel origin
    dummy_name = scene.available_name_like(vessel.name + &#34;dummy&#34;)
    dummy = scene.new_axis(dummy_name)
    dummy.change_parent_to(vessel)
    dummy.parent = None

    # set dummy to even-keel
    dummy.rx = 0
    dummy.ry = 0
    dummy.z = z
    fixed = [1,1,1,1,1,1]
    fixed[0] = old_fixed[0]  # allowed to surge
    fixed[1] = old_fixed[1]  # allowed to sway
    fixed[5] = old_fixed[5] # allowed to yaw

    dummy.fixed = fixed

    # Change vessel parent to dummy
    vessel.parent = dummy
    vessel.position = (0,0,0)
    vessel.rotation = (0,0,0)
    vessel.fixed = True

    # solve statics
    scene.solve_statics()

    force = vessel.connection_force

    vessel.change_parent_to(old_parent)
    vessel.fixed = old_fixed
    scene.delete(dummy_name)

    F = -force[2]

    if abs(F)&lt;1e-6:
        print(&#39;No force required to get to requested draft&#39;)
        return (0,0,0)

    x = -force[4] / force[2]
    y = force[3] / force[2]

    print(&#39;Required force of {} kN at position x={}m and y={}m&#39;.format(F,x,y))

    return (F,x,y)





class BallastSystemSolver:
    &#34;&#34;&#34;
    Changes in ballast system are condidered ok if either

    the error reduced with at least min_error_reduction
    the system is a a better state (more filling in higher priority tank without increasing the error)

    &#34;&#34;&#34;

    def __init__(self, ballast_system_node):

        self.BallastSystem = ballast_system_node

        self._target_cog = np.array((0.,0.,0.))
        self._target_wt = 0
        self.tolerance = 1e-3
        self.silent = True
        self.min_error_reduction = self.tolerance/25


    def print(self, *kwarg):
        if not(self.silent):
            print(*kwarg)


    def xyzw(self):
        return self.BallastSystem.xyzw()

    def _error(self):
        (cog, wt) = self.xyzw()

        dx = cog[0] - self._target_cog[0]
        dy = cog[1] - self._target_cog[1]
        dw = wt - self._target_wt

        return dx**2 + dy**2 + 0.1*dw **2

    def optimize_tank(self, tank):

        self.print(&#39;-- optimize tank -- {}&#39;.format(tank.name))
        E0 = self._error()
        self.print(&#39;-- initial error {}&#39;.format(E0))
        p0 = tank.pct

        was_partial = tank.is_partial()

        # fill tank
        tank.pct = 100
        if self._error() &lt; E0:
            self.print(&#39;Tank {} set to FULL&#39;.format(tank.name))
            if self._error() &lt; E0 - self.min_error_reduction:
                return True
            if was_partial:
                return True


        # empty tank
        tank.pct = 0
        if self._error() &lt; E0:
            self.print(&#39;Tank {} set to EMPTY&#39;.format(tank.name, ))
            if self._error() &lt; E0 - self.min_error_reduction:
                return True
            if was_partial:
                return True

        # optimum must be somewhere in between

        def fun(x):
            tank.pct = x
            return self._error()

        res = minimize_scalar(fun, bounds=(0,100),method=&#39;Bounded&#39;)

        if not res.success:
            x = np.linspace(0,100,num=101)
            funn = np.vectorize(fun)
            y = funn(x)
            plt.plot(x,y)
            plt.show()
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR ONE TANK!!!&#39;)
            # raise ArithmeticError(&#39;Optimization failed&#39;)

        if res.x &gt; 100 or res.x &lt; 0:
            self.print(&#39;error with bounds&#39;)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0 - self.min_error_reduction:
            self.print(&#39;Tank {} set to {}&#39;.format(tank.name, res.x))
            tank.pct = res.x
            return True

        tank.pct = p0
        return False

    def optimize_multiple_partial(self, tanks):
        E0 = self._error()
        p0 = list()
        for tank in tanks:
            p0.append(tank.pct)

        n_tanks = len(tanks)

        self.print(&#39;Optimizing multiple ( n = {} ) tanks:&#39;.format(n_tanks))
        self.print(&#39;Initial error {}&#39;.format(E0))

        for tank in tanks:
            self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))



        # See if it is possible to empty or fill one of the tanks and get an result that is at least as good
        # This does not need to decrease the error because it leads to a better state
        # Except if that tank was already empty or full

        if n_tanks == 2:

            store_tank1 = tanks[1].pct
            store_tank0 = tanks[0].pct

            # empty second tank and optimize first one
            if not tanks[1].is_empty():
                tanks[1].make_empty()
                self.optimize_tank(tanks[0])
                if self._error() &lt;= E0:
                    return True
                tanks[1].pct = store_tank1

            # fill first tank and optimize second one
            if not tanks[0].is_full:
                tanks[0].make_full()
                self.optimize_tank(tanks[1])
                if self._error() &lt;= E0:
                    return True
                tanks[0].pct = store_tank0

            # fill second tank and optimize first one
            if not tanks[1].is_full:
                tanks[1].make_full()
                self.optimize_tank(tanks[0])
                if self._error() &lt;= E0:
                    return True
                tanks[1].pct = store_tank1

            # empty first tank and optimize second one
            if not tanks[0].is_empty:
                tanks[0].make_empty()
                self.optimize_tank(tanks[1])
                if self._error() &lt;= E0:
                    return True
                tanks[0].pct = store_tank0


        # More than two tanks - make empty
        if n_tanks &gt; 2:
            for i_empty in reversed(range(n_tanks)):

                # set original fillings
                for tank,fill in zip( tanks, p0):
                    tank.pct = fill

                if tanks[i_empty].is_empty(): # do not empty tanks that were already full
                    continue

                subset = []
                for i in range(n_tanks):
                    if i == i_empty:
                        tanks[i].pct = 0
                    else:
                        subset.append(tanks[i])

                if self.optimize_multiple_partial(subset):
                    if self._error() &lt;= E0:
                        self.print(&#39;Removed one of the slack tanks&#39;)
                        for tank in tanks:
                            self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))

                        return True

        #  More than two tanks - make full
        if n_tanks&gt;2:
            for i_full in range(n_tanks):

                # set original fillings
                for tank, fill in zip(tanks,p0):
                    tank.pct = fill

                if tanks[i_full].is_full():  # do not fill tanks that were already full
                    continue

                subset = []
                for i in range(n_tanks):
                    if i==i_full:
                        tanks[i].pct=100
                    else:
                        subset.append(tanks[i])

                if self.optimize_multiple_partial(subset):
                    if self._error() &lt;= E0:
                        self.print(&#39;Removed one of the slack tanks&#39;)
                        return True


        # =========== It was not possible to improve the state by filling or emptying one of the tanks partial completely ====
        #
        # Do an optimization over all the given tanks


        # set original fillings
        for tank, fill in zip(tanks,p0):
            tank.pct = fill

        def fun(x):
            for i,tank in enumerate(tanks):
                tank.pct = x[i]
            return self._error()

        x0 = []
        bnds = []

        for tank in tanks:
            x0.append(tank.pct)
            bnds.append((0., 100.))

        res = minimize(fun, x0=np.array(x0), bounds=bnds) # , method=&#34;trust-constr&#34; is slowest but give best results?

        if not res.success:
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(n_tanks))

            # Often it fails because the solution any point on a line.

            # raise ArithmeticError(&#39;Optimization failed&#39;)  # TODO: possible to use a more robust routine?
            # if n_tanks==2: # we can plot this!
            #     visualize_optimiaztion(fun, (0,100), (0,100))


        # apply the result
        fun(res.x)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0-self.min_error_reduction:

            self.print(&#39;Before optimaliz = &#39;, x0)
            self.print(&#39;multi-opt result = &#39;, res.x)

            return True

        # set original fillings
        for tank, fill in zip(tanks, p0):
            tank.pct = fill
        return False


    def optimize_using(self, tanks):
        &#34;&#34;&#34;Optimize using the given tanks. No fancy combinations&#34;&#34;&#34;

        names = &#39;&#39;
        for t in tanks:
            names += &#39; &#39; + t.name + &#39;(&#39; + str(t.pct) + &#39;)&#39;
        print(&#39;Optimize using {} tanks: {}&#39;.format(len(tanks), names))

        E0 = self._error()
        p0 = list()
        for tank in tanks:
            p0.append(tank.pct)

        def fun(x):
            for i, tank in enumerate(tanks):
                tank.pct = x[i]
            return self._error()

        x0 = []
        bnds = []

        for tank in tanks:
            x0.append(tank.pct)
            bnds.append((0., 100.))

        res = minimize(fun, x0=np.array(x0), bounds=bnds)

        if not res.success:
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(len(tanks)))

        # apply the result
        fun(res.x)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0:
            self.print(&#39;Before optimaliz = &#39;, x0)
            self.print(&#39;multi-opt result = &#39;, res.x)
            return True
        else:
            self.print(&#39;multi-opt result = &#39;, res.x)

        # set original fillings
        for tank, fill in zip(tanks, p0):
            tank.pct = fill
        return False

    def ballast_to(self, cogx, cogy, weight):

        _log = []

        self._target_wt = weight
        self._target_cog[0] = cogx - self.BallastSystem.position[0]
        self._target_cog[1] = cogy- self.BallastSystem.position[1]

        # Get usable tanks
        optTanks = []
        for tank in self.BallastSystem._tanks:
            if not tank.frozen:
                optTanks.append(tank)



        # print log:
        print(&#39;ballasting to volume of {} kN&#39;.format(self._target_wt ))
        print(&#39;at {} , {}&#39;.format(self._target_cog[0],self._target_cog[1] ))

        print(&#39;using:&#39;)
        for tank in optTanks:
            print(&#39;{} of {} [ {}% full ]at {} {} {}&#39;.format(tank.name, tank.max, tank.pct, *tank.position))
        print(&#39;-----------------------------&#39;)

        maxit = 100
        for it in range(maxit):

            print(&#39;Iteration = {}, Error = {} with tanks:&#39;.format(it, self._error()))

            _log.append([tank.pct for tank in optTanks])
            print(_log[-1])

            if self._error() &lt; self.tolerance:
                break

            # optimize partially filled tanks
            partials = []
            for tank in optTanks:
                if tank.is_partial():
                    partials.append(tank)

            if len(partials) == 1:
                if self.optimize_tank(partials[0]):
                    continue


            if len(partials) &gt; 1:
                if self.optimize_multiple_partial(partials):
                    continue

            changed = False

            # See if it gets better by filling or emptying _any_ of the other tanks
            for tank in optTanks:
                if self.optimize_tank(tank):
                    changed = True
                    break

            if changed:
                continue

            # optimizing the currently partial tanks failed
            # keeping the currently partial tanks and optimizing any one of the other tanks failed

            # use the current partial tanks in combination with ONE of the other tanks
            for tank in optTanks:
                if tank not in partials:
                    temp = partials.copy()
                    temp.append(tank)
                    if self.optimize_multiple_partial(temp):

                        self.print(&#39;Optimized the following:&#39;)
                        for tank in temp:
                            self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                        changed = True
                        break

            if changed:
                continue

            # use the current partial tanks in combination with TWO of the other tanks
            #
            # WARNING: This is very, very slow because there are many combinations

            # do we need to fill or drain?
            _, wt = self.xyzw()
            if wt &lt; self._target_wt:
                fill = False
            else:
                fill = True

            for tank in optTanks:

                # exclude full tanks if we need to fill
                if fill and tank.is_full():
                    continue
                # exclude empty tanks if we need to drain
                if not fill and tank.is_empty():
                    continue

                for tank2 in optTanks:

                    # exclude full tanks if we need to fill
                    if fill and tank2.is_full():
                        continue
                    # exclude empty tanks if we need to drain
                    if not fill and tank2.is_empty():
                        continue

                    # we now have tank and tank2
                    # optimize using all partial tanks plus these two

                    if tank not in partials:
                        temp = partials.copy()
                        temp.append(tank)
                        if tank2 not in temp:
                            temp.append(tank2)
                            if self.optimize_using(temp):

                                self.print(&#39;Optimized the following:&#39;)
                                for tank in temp:
                                    self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                                changed = True
                                break

            if changed:
                continue

            print([t.pct for t in optTanks])
            print(self._error())
            print(self.xyzw())

            raise ArithmeticError(&#39;Optimization failed&#39;)

        self.print(&#39;Error = {}&#39;.format(self._error()))
        self.print(self.xyzw())
        print([t.pct for t in optTanks])

        if it == maxit-1:
            plt.plot(_log)
            print(&#39;Error = {}&#39;.format(self._error()))
            plt.show()
            raise ArithmeticError(&#39;Optimization failed : too many iterations&#39;)

#</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DAVE.solvers.ballast.force_vessel_to_evenkeel_and_draft"><code class="name flex">
<span>def <span class="ident">force_vessel_to_evenkeel_and_draft</span></span>(<span>scene, vessel, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the required force to be applied to place the vessel even-keel at the given vertical position (-draft if origin is at keel).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene</code></strong></dt>
<dd>Scene</dd>
<dt><strong><code>vessel</code></strong></dt>
<dd>Vessel node or vessel node name</dd>
<dt><strong><code>draft</code></strong></dt>
<dd>requested vertical position of vessel axis system origin. If the vessel origin is at the keel than this is minus draft</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Required</code> <code>external</code> <code>force</code> <code>and</code> <code>position</code> (<code>F</code>,<code>x</code>,<code>y</code>) <code>to</code> <code>be</code> <code>applied</code> <code>to</code> <code>the</code> <code>the</code> <code>vessel</code> <code>to</code> <code>the</code> <code>given</code> <code>position</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_vessel_to_evenkeel_and_draft(scene, vessel, z):
    &#34;&#34;&#34;
    Calculates the required force to be applied to place the vessel even-keel at the given vertical position (-draft if origin is at keel).

    Args:
        scene:  Scene
        vessel: Vessel node or vessel node name
        draft:  requested vertical position of vessel axis system origin. If the vessel origin is at the keel than this is minus draft

    Returns:
        Required external force and position (F,x,y) to be applied to the the vessel to the given position
    &#34;&#34;&#34;



    vessel = scene._node_from_node_or_str(vessel)

    # store old props
    # old_position = vessel.position
    # old_rotation = vessel.rotation
    old_parent = vessel.parent
    old_fixed = vessel.fixed

    if vessel.parent is not None:
        raise Exception(&#39;Vessel with parent : not yet implemented&#39;)

    # Create a dummy at the vessel origin
    dummy_name = scene.available_name_like(vessel.name + &#34;dummy&#34;)
    dummy = scene.new_axis(dummy_name)
    dummy.change_parent_to(vessel)
    dummy.parent = None

    # set dummy to even-keel
    dummy.rx = 0
    dummy.ry = 0
    dummy.z = z
    fixed = [1,1,1,1,1,1]
    fixed[0] = old_fixed[0]  # allowed to surge
    fixed[1] = old_fixed[1]  # allowed to sway
    fixed[5] = old_fixed[5] # allowed to yaw

    dummy.fixed = fixed

    # Change vessel parent to dummy
    vessel.parent = dummy
    vessel.position = (0,0,0)
    vessel.rotation = (0,0,0)
    vessel.fixed = True

    # solve statics
    scene.solve_statics()

    force = vessel.connection_force

    vessel.change_parent_to(old_parent)
    vessel.fixed = old_fixed
    scene.delete(dummy_name)

    F = -force[2]

    if abs(F)&lt;1e-6:
        print(&#39;No force required to get to requested draft&#39;)
        return (0,0,0)

    x = -force[4] / force[2]
    y = force[3] / force[2]

    print(&#39;Required force of {} kN at position x={}m and y={}m&#39;.format(F,x,y))

    return (F,x,y)</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.visualize_optimiaztion"><code class="name flex">
<span>def <span class="ident">visualize_optimiaztion</span></span>(<span>fun, xlim, ylim)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_optimiaztion(fun, xlim, ylim):
    step = 1
    x,y = np.meshgrid(np.arange(xlim[0], xlim[1] + step, step),
                      np.arange(ylim[0], ylim[1] + step, step))
    def fun2(x,y):
        return fun([x,y])

    funn = np.vectorize(fun2)
    z = funn(x,y)

    fig = plt.figure(figsize=(8, 5))

    from mpl_toolkits.mplot3d import Axes3D
    from matplotlib.colors import LogNorm

    ax = plt.axes(projection=&#39;3d&#39;, elev=50, azim=-50)

    ax.plot_surface(x, y, z, norm=LogNorm(), rstride=1, cstride=1,
                    edgecolor=&#39;none&#39;, alpha=.8, cmap=plt.cm.jet)

    plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="DAVE.solvers.ballast.BallastSystemSolver"><code class="flex name class">
<span>class <span class="ident">BallastSystemSolver</span></span>
<span>(</span><span>ballast_system_node)</span>
</code></dt>
<dd>
<section class="desc"><p>Changes in ballast system are condidered ok if either</p>
<p>the error reduced with at least min_error_reduction
the system is a a better state (more filling in higher priority tank without increasing the error)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BallastSystemSolver:
    &#34;&#34;&#34;
    Changes in ballast system are condidered ok if either

    the error reduced with at least min_error_reduction
    the system is a a better state (more filling in higher priority tank without increasing the error)

    &#34;&#34;&#34;

    def __init__(self, ballast_system_node):

        self.BallastSystem = ballast_system_node

        self._target_cog = np.array((0.,0.,0.))
        self._target_wt = 0
        self.tolerance = 1e-3
        self.silent = True
        self.min_error_reduction = self.tolerance/25


    def print(self, *kwarg):
        if not(self.silent):
            print(*kwarg)


    def xyzw(self):
        return self.BallastSystem.xyzw()

    def _error(self):
        (cog, wt) = self.xyzw()

        dx = cog[0] - self._target_cog[0]
        dy = cog[1] - self._target_cog[1]
        dw = wt - self._target_wt

        return dx**2 + dy**2 + 0.1*dw **2

    def optimize_tank(self, tank):

        self.print(&#39;-- optimize tank -- {}&#39;.format(tank.name))
        E0 = self._error()
        self.print(&#39;-- initial error {}&#39;.format(E0))
        p0 = tank.pct

        was_partial = tank.is_partial()

        # fill tank
        tank.pct = 100
        if self._error() &lt; E0:
            self.print(&#39;Tank {} set to FULL&#39;.format(tank.name))
            if self._error() &lt; E0 - self.min_error_reduction:
                return True
            if was_partial:
                return True


        # empty tank
        tank.pct = 0
        if self._error() &lt; E0:
            self.print(&#39;Tank {} set to EMPTY&#39;.format(tank.name, ))
            if self._error() &lt; E0 - self.min_error_reduction:
                return True
            if was_partial:
                return True

        # optimum must be somewhere in between

        def fun(x):
            tank.pct = x
            return self._error()

        res = minimize_scalar(fun, bounds=(0,100),method=&#39;Bounded&#39;)

        if not res.success:
            x = np.linspace(0,100,num=101)
            funn = np.vectorize(fun)
            y = funn(x)
            plt.plot(x,y)
            plt.show()
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR ONE TANK!!!&#39;)
            # raise ArithmeticError(&#39;Optimization failed&#39;)

        if res.x &gt; 100 or res.x &lt; 0:
            self.print(&#39;error with bounds&#39;)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0 - self.min_error_reduction:
            self.print(&#39;Tank {} set to {}&#39;.format(tank.name, res.x))
            tank.pct = res.x
            return True

        tank.pct = p0
        return False

    def optimize_multiple_partial(self, tanks):
        E0 = self._error()
        p0 = list()
        for tank in tanks:
            p0.append(tank.pct)

        n_tanks = len(tanks)

        self.print(&#39;Optimizing multiple ( n = {} ) tanks:&#39;.format(n_tanks))
        self.print(&#39;Initial error {}&#39;.format(E0))

        for tank in tanks:
            self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))



        # See if it is possible to empty or fill one of the tanks and get an result that is at least as good
        # This does not need to decrease the error because it leads to a better state
        # Except if that tank was already empty or full

        if n_tanks == 2:

            store_tank1 = tanks[1].pct
            store_tank0 = tanks[0].pct

            # empty second tank and optimize first one
            if not tanks[1].is_empty():
                tanks[1].make_empty()
                self.optimize_tank(tanks[0])
                if self._error() &lt;= E0:
                    return True
                tanks[1].pct = store_tank1

            # fill first tank and optimize second one
            if not tanks[0].is_full:
                tanks[0].make_full()
                self.optimize_tank(tanks[1])
                if self._error() &lt;= E0:
                    return True
                tanks[0].pct = store_tank0

            # fill second tank and optimize first one
            if not tanks[1].is_full:
                tanks[1].make_full()
                self.optimize_tank(tanks[0])
                if self._error() &lt;= E0:
                    return True
                tanks[1].pct = store_tank1

            # empty first tank and optimize second one
            if not tanks[0].is_empty:
                tanks[0].make_empty()
                self.optimize_tank(tanks[1])
                if self._error() &lt;= E0:
                    return True
                tanks[0].pct = store_tank0


        # More than two tanks - make empty
        if n_tanks &gt; 2:
            for i_empty in reversed(range(n_tanks)):

                # set original fillings
                for tank,fill in zip( tanks, p0):
                    tank.pct = fill

                if tanks[i_empty].is_empty(): # do not empty tanks that were already full
                    continue

                subset = []
                for i in range(n_tanks):
                    if i == i_empty:
                        tanks[i].pct = 0
                    else:
                        subset.append(tanks[i])

                if self.optimize_multiple_partial(subset):
                    if self._error() &lt;= E0:
                        self.print(&#39;Removed one of the slack tanks&#39;)
                        for tank in tanks:
                            self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))

                        return True

        #  More than two tanks - make full
        if n_tanks&gt;2:
            for i_full in range(n_tanks):

                # set original fillings
                for tank, fill in zip(tanks,p0):
                    tank.pct = fill

                if tanks[i_full].is_full():  # do not fill tanks that were already full
                    continue

                subset = []
                for i in range(n_tanks):
                    if i==i_full:
                        tanks[i].pct=100
                    else:
                        subset.append(tanks[i])

                if self.optimize_multiple_partial(subset):
                    if self._error() &lt;= E0:
                        self.print(&#39;Removed one of the slack tanks&#39;)
                        return True


        # =========== It was not possible to improve the state by filling or emptying one of the tanks partial completely ====
        #
        # Do an optimization over all the given tanks


        # set original fillings
        for tank, fill in zip(tanks,p0):
            tank.pct = fill

        def fun(x):
            for i,tank in enumerate(tanks):
                tank.pct = x[i]
            return self._error()

        x0 = []
        bnds = []

        for tank in tanks:
            x0.append(tank.pct)
            bnds.append((0., 100.))

        res = minimize(fun, x0=np.array(x0), bounds=bnds) # , method=&#34;trust-constr&#34; is slowest but give best results?

        if not res.success:
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(n_tanks))

            # Often it fails because the solution any point on a line.

            # raise ArithmeticError(&#39;Optimization failed&#39;)  # TODO: possible to use a more robust routine?
            # if n_tanks==2: # we can plot this!
            #     visualize_optimiaztion(fun, (0,100), (0,100))


        # apply the result
        fun(res.x)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0-self.min_error_reduction:

            self.print(&#39;Before optimaliz = &#39;, x0)
            self.print(&#39;multi-opt result = &#39;, res.x)

            return True

        # set original fillings
        for tank, fill in zip(tanks, p0):
            tank.pct = fill
        return False


    def optimize_using(self, tanks):
        &#34;&#34;&#34;Optimize using the given tanks. No fancy combinations&#34;&#34;&#34;

        names = &#39;&#39;
        for t in tanks:
            names += &#39; &#39; + t.name + &#39;(&#39; + str(t.pct) + &#39;)&#39;
        print(&#39;Optimize using {} tanks: {}&#39;.format(len(tanks), names))

        E0 = self._error()
        p0 = list()
        for tank in tanks:
            p0.append(tank.pct)

        def fun(x):
            for i, tank in enumerate(tanks):
                tank.pct = x[i]
            return self._error()

        x0 = []
        bnds = []

        for tank in tanks:
            x0.append(tank.pct)
            bnds.append((0., 100.))

        res = minimize(fun, x0=np.array(x0), bounds=bnds)

        if not res.success:
            self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(len(tanks)))

        # apply the result
        fun(res.x)

        # Did the optimization result in a different tank fill
        if self._error() &lt; E0:
            self.print(&#39;Before optimaliz = &#39;, x0)
            self.print(&#39;multi-opt result = &#39;, res.x)
            return True
        else:
            self.print(&#39;multi-opt result = &#39;, res.x)

        # set original fillings
        for tank, fill in zip(tanks, p0):
            tank.pct = fill
        return False

    def ballast_to(self, cogx, cogy, weight):

        _log = []

        self._target_wt = weight
        self._target_cog[0] = cogx - self.BallastSystem.position[0]
        self._target_cog[1] = cogy- self.BallastSystem.position[1]

        # Get usable tanks
        optTanks = []
        for tank in self.BallastSystem._tanks:
            if not tank.frozen:
                optTanks.append(tank)



        # print log:
        print(&#39;ballasting to volume of {} kN&#39;.format(self._target_wt ))
        print(&#39;at {} , {}&#39;.format(self._target_cog[0],self._target_cog[1] ))

        print(&#39;using:&#39;)
        for tank in optTanks:
            print(&#39;{} of {} [ {}% full ]at {} {} {}&#39;.format(tank.name, tank.max, tank.pct, *tank.position))
        print(&#39;-----------------------------&#39;)

        maxit = 100
        for it in range(maxit):

            print(&#39;Iteration = {}, Error = {} with tanks:&#39;.format(it, self._error()))

            _log.append([tank.pct for tank in optTanks])
            print(_log[-1])

            if self._error() &lt; self.tolerance:
                break

            # optimize partially filled tanks
            partials = []
            for tank in optTanks:
                if tank.is_partial():
                    partials.append(tank)

            if len(partials) == 1:
                if self.optimize_tank(partials[0]):
                    continue


            if len(partials) &gt; 1:
                if self.optimize_multiple_partial(partials):
                    continue

            changed = False

            # See if it gets better by filling or emptying _any_ of the other tanks
            for tank in optTanks:
                if self.optimize_tank(tank):
                    changed = True
                    break

            if changed:
                continue

            # optimizing the currently partial tanks failed
            # keeping the currently partial tanks and optimizing any one of the other tanks failed

            # use the current partial tanks in combination with ONE of the other tanks
            for tank in optTanks:
                if tank not in partials:
                    temp = partials.copy()
                    temp.append(tank)
                    if self.optimize_multiple_partial(temp):

                        self.print(&#39;Optimized the following:&#39;)
                        for tank in temp:
                            self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                        changed = True
                        break

            if changed:
                continue

            # use the current partial tanks in combination with TWO of the other tanks
            #
            # WARNING: This is very, very slow because there are many combinations

            # do we need to fill or drain?
            _, wt = self.xyzw()
            if wt &lt; self._target_wt:
                fill = False
            else:
                fill = True

            for tank in optTanks:

                # exclude full tanks if we need to fill
                if fill and tank.is_full():
                    continue
                # exclude empty tanks if we need to drain
                if not fill and tank.is_empty():
                    continue

                for tank2 in optTanks:

                    # exclude full tanks if we need to fill
                    if fill and tank2.is_full():
                        continue
                    # exclude empty tanks if we need to drain
                    if not fill and tank2.is_empty():
                        continue

                    # we now have tank and tank2
                    # optimize using all partial tanks plus these two

                    if tank not in partials:
                        temp = partials.copy()
                        temp.append(tank)
                        if tank2 not in temp:
                            temp.append(tank2)
                            if self.optimize_using(temp):

                                self.print(&#39;Optimized the following:&#39;)
                                for tank in temp:
                                    self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                                changed = True
                                break

            if changed:
                continue

            print([t.pct for t in optTanks])
            print(self._error())
            print(self.xyzw())

            raise ArithmeticError(&#39;Optimization failed&#39;)

        self.print(&#39;Error = {}&#39;.format(self._error()))
        self.print(self.xyzw())
        print([t.pct for t in optTanks])

        if it == maxit-1:
            plt.plot(_log)
            print(&#39;Error = {}&#39;.format(self._error()))
            plt.show()
            raise ArithmeticError(&#39;Optimization failed : too many iterations&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.ballast_to"><code class="name flex">
<span>def <span class="ident">ballast_to</span></span>(<span>self, cogx, cogy, weight)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ballast_to(self, cogx, cogy, weight):

    _log = []

    self._target_wt = weight
    self._target_cog[0] = cogx - self.BallastSystem.position[0]
    self._target_cog[1] = cogy- self.BallastSystem.position[1]

    # Get usable tanks
    optTanks = []
    for tank in self.BallastSystem._tanks:
        if not tank.frozen:
            optTanks.append(tank)



    # print log:
    print(&#39;ballasting to volume of {} kN&#39;.format(self._target_wt ))
    print(&#39;at {} , {}&#39;.format(self._target_cog[0],self._target_cog[1] ))

    print(&#39;using:&#39;)
    for tank in optTanks:
        print(&#39;{} of {} [ {}% full ]at {} {} {}&#39;.format(tank.name, tank.max, tank.pct, *tank.position))
    print(&#39;-----------------------------&#39;)

    maxit = 100
    for it in range(maxit):

        print(&#39;Iteration = {}, Error = {} with tanks:&#39;.format(it, self._error()))

        _log.append([tank.pct for tank in optTanks])
        print(_log[-1])

        if self._error() &lt; self.tolerance:
            break

        # optimize partially filled tanks
        partials = []
        for tank in optTanks:
            if tank.is_partial():
                partials.append(tank)

        if len(partials) == 1:
            if self.optimize_tank(partials[0]):
                continue


        if len(partials) &gt; 1:
            if self.optimize_multiple_partial(partials):
                continue

        changed = False

        # See if it gets better by filling or emptying _any_ of the other tanks
        for tank in optTanks:
            if self.optimize_tank(tank):
                changed = True
                break

        if changed:
            continue

        # optimizing the currently partial tanks failed
        # keeping the currently partial tanks and optimizing any one of the other tanks failed

        # use the current partial tanks in combination with ONE of the other tanks
        for tank in optTanks:
            if tank not in partials:
                temp = partials.copy()
                temp.append(tank)
                if self.optimize_multiple_partial(temp):

                    self.print(&#39;Optimized the following:&#39;)
                    for tank in temp:
                        self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                    changed = True
                    break

        if changed:
            continue

        # use the current partial tanks in combination with TWO of the other tanks
        #
        # WARNING: This is very, very slow because there are many combinations

        # do we need to fill or drain?
        _, wt = self.xyzw()
        if wt &lt; self._target_wt:
            fill = False
        else:
            fill = True

        for tank in optTanks:

            # exclude full tanks if we need to fill
            if fill and tank.is_full():
                continue
            # exclude empty tanks if we need to drain
            if not fill and tank.is_empty():
                continue

            for tank2 in optTanks:

                # exclude full tanks if we need to fill
                if fill and tank2.is_full():
                    continue
                # exclude empty tanks if we need to drain
                if not fill and tank2.is_empty():
                    continue

                # we now have tank and tank2
                # optimize using all partial tanks plus these two

                if tank not in partials:
                    temp = partials.copy()
                    temp.append(tank)
                    if tank2 not in temp:
                        temp.append(tank2)
                        if self.optimize_using(temp):

                            self.print(&#39;Optimized the following:&#39;)
                            for tank in temp:
                                self.print(&#39;{} --&gt; {}&#39;.format(tank.name, tank.pct))

                            changed = True
                            break

        if changed:
            continue

        print([t.pct for t in optTanks])
        print(self._error())
        print(self.xyzw())

        raise ArithmeticError(&#39;Optimization failed&#39;)

    self.print(&#39;Error = {}&#39;.format(self._error()))
    self.print(self.xyzw())
    print([t.pct for t in optTanks])

    if it == maxit-1:
        plt.plot(_log)
        print(&#39;Error = {}&#39;.format(self._error()))
        plt.show()
        raise ArithmeticError(&#39;Optimization failed : too many iterations&#39;)</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.optimize_multiple_partial"><code class="name flex">
<span>def <span class="ident">optimize_multiple_partial</span></span>(<span>self, tanks)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_multiple_partial(self, tanks):
    E0 = self._error()
    p0 = list()
    for tank in tanks:
        p0.append(tank.pct)

    n_tanks = len(tanks)

    self.print(&#39;Optimizing multiple ( n = {} ) tanks:&#39;.format(n_tanks))
    self.print(&#39;Initial error {}&#39;.format(E0))

    for tank in tanks:
        self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))



    # See if it is possible to empty or fill one of the tanks and get an result that is at least as good
    # This does not need to decrease the error because it leads to a better state
    # Except if that tank was already empty or full

    if n_tanks == 2:

        store_tank1 = tanks[1].pct
        store_tank0 = tanks[0].pct

        # empty second tank and optimize first one
        if not tanks[1].is_empty():
            tanks[1].make_empty()
            self.optimize_tank(tanks[0])
            if self._error() &lt;= E0:
                return True
            tanks[1].pct = store_tank1

        # fill first tank and optimize second one
        if not tanks[0].is_full:
            tanks[0].make_full()
            self.optimize_tank(tanks[1])
            if self._error() &lt;= E0:
                return True
            tanks[0].pct = store_tank0

        # fill second tank and optimize first one
        if not tanks[1].is_full:
            tanks[1].make_full()
            self.optimize_tank(tanks[0])
            if self._error() &lt;= E0:
                return True
            tanks[1].pct = store_tank1

        # empty first tank and optimize second one
        if not tanks[0].is_empty:
            tanks[0].make_empty()
            self.optimize_tank(tanks[1])
            if self._error() &lt;= E0:
                return True
            tanks[0].pct = store_tank0


    # More than two tanks - make empty
    if n_tanks &gt; 2:
        for i_empty in reversed(range(n_tanks)):

            # set original fillings
            for tank,fill in zip( tanks, p0):
                tank.pct = fill

            if tanks[i_empty].is_empty(): # do not empty tanks that were already full
                continue

            subset = []
            for i in range(n_tanks):
                if i == i_empty:
                    tanks[i].pct = 0
                else:
                    subset.append(tanks[i])

            if self.optimize_multiple_partial(subset):
                if self._error() &lt;= E0:
                    self.print(&#39;Removed one of the slack tanks&#39;)
                    for tank in tanks:
                        self.print(&#39;{} == {} &#39;.format(tank.name, tank.pct))

                    return True

    #  More than two tanks - make full
    if n_tanks&gt;2:
        for i_full in range(n_tanks):

            # set original fillings
            for tank, fill in zip(tanks,p0):
                tank.pct = fill

            if tanks[i_full].is_full():  # do not fill tanks that were already full
                continue

            subset = []
            for i in range(n_tanks):
                if i==i_full:
                    tanks[i].pct=100
                else:
                    subset.append(tanks[i])

            if self.optimize_multiple_partial(subset):
                if self._error() &lt;= E0:
                    self.print(&#39;Removed one of the slack tanks&#39;)
                    return True


    # =========== It was not possible to improve the state by filling or emptying one of the tanks partial completely ====
    #
    # Do an optimization over all the given tanks


    # set original fillings
    for tank, fill in zip(tanks,p0):
        tank.pct = fill

    def fun(x):
        for i,tank in enumerate(tanks):
            tank.pct = x[i]
        return self._error()

    x0 = []
    bnds = []

    for tank in tanks:
        x0.append(tank.pct)
        bnds.append((0., 100.))

    res = minimize(fun, x0=np.array(x0), bounds=bnds) # , method=&#34;trust-constr&#34; is slowest but give best results?

    if not res.success:
        self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(n_tanks))

        # Often it fails because the solution any point on a line.

        # raise ArithmeticError(&#39;Optimization failed&#39;)  # TODO: possible to use a more robust routine?
        # if n_tanks==2: # we can plot this!
        #     visualize_optimiaztion(fun, (0,100), (0,100))


    # apply the result
    fun(res.x)

    # Did the optimization result in a different tank fill
    if self._error() &lt; E0-self.min_error_reduction:

        self.print(&#39;Before optimaliz = &#39;, x0)
        self.print(&#39;multi-opt result = &#39;, res.x)

        return True

    # set original fillings
    for tank, fill in zip(tanks, p0):
        tank.pct = fill
    return False</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.optimize_tank"><code class="name flex">
<span>def <span class="ident">optimize_tank</span></span>(<span>self, tank)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_tank(self, tank):

    self.print(&#39;-- optimize tank -- {}&#39;.format(tank.name))
    E0 = self._error()
    self.print(&#39;-- initial error {}&#39;.format(E0))
    p0 = tank.pct

    was_partial = tank.is_partial()

    # fill tank
    tank.pct = 100
    if self._error() &lt; E0:
        self.print(&#39;Tank {} set to FULL&#39;.format(tank.name))
        if self._error() &lt; E0 - self.min_error_reduction:
            return True
        if was_partial:
            return True


    # empty tank
    tank.pct = 0
    if self._error() &lt; E0:
        self.print(&#39;Tank {} set to EMPTY&#39;.format(tank.name, ))
        if self._error() &lt; E0 - self.min_error_reduction:
            return True
        if was_partial:
            return True

    # optimum must be somewhere in between

    def fun(x):
        tank.pct = x
        return self._error()

    res = minimize_scalar(fun, bounds=(0,100),method=&#39;Bounded&#39;)

    if not res.success:
        x = np.linspace(0,100,num=101)
        funn = np.vectorize(fun)
        y = funn(x)
        plt.plot(x,y)
        plt.show()
        self.print(&#39;SUB-OPTIMIZATION FAILED FOR ONE TANK!!!&#39;)
        # raise ArithmeticError(&#39;Optimization failed&#39;)

    if res.x &gt; 100 or res.x &lt; 0:
        self.print(&#39;error with bounds&#39;)

    # Did the optimization result in a different tank fill
    if self._error() &lt; E0 - self.min_error_reduction:
        self.print(&#39;Tank {} set to {}&#39;.format(tank.name, res.x))
        tank.pct = res.x
        return True

    tank.pct = p0
    return False</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.optimize_using"><code class="name flex">
<span>def <span class="ident">optimize_using</span></span>(<span>self, tanks)</span>
</code></dt>
<dd>
<section class="desc"><p>Optimize using the given tanks. No fancy combinations</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_using(self, tanks):
    &#34;&#34;&#34;Optimize using the given tanks. No fancy combinations&#34;&#34;&#34;

    names = &#39;&#39;
    for t in tanks:
        names += &#39; &#39; + t.name + &#39;(&#39; + str(t.pct) + &#39;)&#39;
    print(&#39;Optimize using {} tanks: {}&#39;.format(len(tanks), names))

    E0 = self._error()
    p0 = list()
    for tank in tanks:
        p0.append(tank.pct)

    def fun(x):
        for i, tank in enumerate(tanks):
            tank.pct = x[i]
        return self._error()

    x0 = []
    bnds = []

    for tank in tanks:
        x0.append(tank.pct)
        bnds.append((0., 100.))

    res = minimize(fun, x0=np.array(x0), bounds=bnds)

    if not res.success:
        self.print(&#39;SUB-OPTIMIZATION FAILED FOR {} TANKS&#39;.format(len(tanks)))

    # apply the result
    fun(res.x)

    # Did the optimization result in a different tank fill
    if self._error() &lt; E0:
        self.print(&#39;Before optimaliz = &#39;, x0)
        self.print(&#39;multi-opt result = &#39;, res.x)
        return True
    else:
        self.print(&#39;multi-opt result = &#39;, res.x)

    # set original fillings
    for tank, fill in zip(tanks, p0):
        tank.pct = fill
    return False</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *kwarg)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *kwarg):
    if not(self.silent):
        print(*kwarg)</code></pre>
</details>
</dd>
<dt id="DAVE.solvers.ballast.BallastSystemSolver.xyzw"><code class="name flex">
<span>def <span class="ident">xyzw</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyzw(self):
    return self.BallastSystem.xyzw()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DAVE.solvers" href="index.html">DAVE.solvers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DAVE.solvers.ballast.force_vessel_to_evenkeel_and_draft" href="#DAVE.solvers.ballast.force_vessel_to_evenkeel_and_draft">force_vessel_to_evenkeel_and_draft</a></code></li>
<li><code><a title="DAVE.solvers.ballast.visualize_optimiaztion" href="#DAVE.solvers.ballast.visualize_optimiaztion">visualize_optimiaztion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="DAVE.solvers.ballast.BallastSystemSolver" href="#DAVE.solvers.ballast.BallastSystemSolver">BallastSystemSolver</a></code></h4>
<ul class="">
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.ballast_to" href="#DAVE.solvers.ballast.BallastSystemSolver.ballast_to">ballast_to</a></code></li>
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.optimize_multiple_partial" href="#DAVE.solvers.ballast.BallastSystemSolver.optimize_multiple_partial">optimize_multiple_partial</a></code></li>
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.optimize_tank" href="#DAVE.solvers.ballast.BallastSystemSolver.optimize_tank">optimize_tank</a></code></li>
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.optimize_using" href="#DAVE.solvers.ballast.BallastSystemSolver.optimize_using">optimize_using</a></code></li>
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.print" href="#DAVE.solvers.ballast.BallastSystemSolver.print">print</a></code></li>
<li><code><a title="DAVE.solvers.ballast.BallastSystemSolver.xyzw" href="#DAVE.solvers.ballast.BallastSystemSolver.xyzw">xyzw</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>