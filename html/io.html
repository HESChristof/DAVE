<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>DAVE.io.blender API documentation</title>
<meta name="description" content="Using this module a scene can be exported to Blender …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.io.blender</code></h1>
</header>
<section id="section-intro">
<p>Using this module a scene can be exported to Blender.</p>
<p>Blender is the free and open source 3D creation suite. It supports the entirety of the 3D pipeline—modeling, rigging, animation, simulation, rendering, compositing and motion tracking, video editing and 2D animation pipeline.
It can be downloaded from <a href="https://www.blender.org">https://www.blender.org</a></p>
<p>Only visuals will be exported.</p>
<p>For this to work every visual needs to have a corresponding .blend file. This file should be located in one of the resource-paths.
The name of the .blend file should be the same as the name of the .obj file.</p>
<p>The blender model
- should have the same origin as the .obj file
- should have all transformations applied (select object, control+A, all transformation)</p>
<p>A base blender file needs to be provided. The visuals will be added to this model. It will then be saved under a different name.</p>
<p>Requirements for the base blender file:
- Shall have a material called "Cable", this material will be assigned to each created cable.</p>
<p>All functions in this file one or more of the following arguments</p>
<ul>
<li>camera : a dictionary with ['position'] and ['direction'] which specifies the camera position and look direction</li>
<li>python_file : location for the generated python file</li>
<li>blender_base_file : .blend file to be used a starting scene</li>
<li>blender_result_file : .blend file to write to</li>
<li>blender_exe_path : location of the blender executable. Defaults to DAVE.constants.BLENDER_EXEC
: probably r"C:\Program Files\Blender Foundation\Blender\blender.exe"</li>
</ul>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Using this module a scene can be exported to Blender.
    
    Blender is the free and open source 3D creation suite. It supports the entirety of the 3D pipeline—modeling, rigging, animation, simulation, rendering, compositing and motion tracking, video editing and 2D animation pipeline.
    It can be downloaded from https://www.blender.org
    
    Only visuals will be exported.
    
    For this to work every visual needs to have a corresponding .blend file. This file should be located in one of the resource-paths.
    The name of the .blend file should be the same as the name of the .obj file.
    
    The blender model
    - should have the same origin as the .obj file
    - should have all transformations applied (select object, control+A, all transformation)
    
    A base blender file needs to be provided. The visuals will be added to this model. It will then be saved under a different name.
    
    Requirements for the base blender file:
    - Shall have a material called &#34;Cable&#34;, this material will be assigned to each created cable.

    All functions in this file one or more of the following arguments
    
    - camera : a dictionary with [&#39;position&#39;] and [&#39;direction&#39;] which specifies the camera position and look direction
    - python_file : location for the generated python file
    - blender_base_file : .blend file to be used a starting scene
    - blender_result_file : .blend file to write to
    - blender_exe_path : location of the blender executable. Defaults to DAVE.constants.BLENDER_EXEC
                       : probably r&#34;C:\Program Files\Blender Foundation\Blender\\blender.exe&#34;
    
    --- 
    
    
    

    

&#34;&#34;&#34;

&#34;&#34;&#34;
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Ruben de Bruin - 2019
&#34;&#34;&#34;


import DAVE.scene as dc
import DAVE.settings as consts
from scipy.spatial.transform import Rotation  # for conversion from axis-angle to euler
from os.path import splitext, basename
from os import system
from numpy import deg2rad
from pathlib import Path
import numpy as np


# utility functions for our python scripts are hard-coded here

BFUNC = &#34;&#34;&#34;

from mathutils import Vector, Quaternion

# These functions are inserted by DAVE.io.blender.py

def insert_objects(filepath,scale=(1,1,1),rotation=(0,0,0), offset=(0,0,0), orientation=(0,0,0,0), position=(0,0,0), orientations=[], positions=[], frames_per_dof = 1 ):
    \&#34;\&#34;\&#34;
    All meshes shall be joined
    
    First rotate (rotation)
    Then scale (scale)
    Then move (offset)

    Then global apply rotation rotate (orientation)
    Then apply global move (position)

    rotations in radians

    \&#34;\&#34;\&#34;
    print(&#39;Loading {}&#39;.format(filepath))

    with bpy.data.libraries.load(filepath=filepath, relative=False) as (data_from, data_to):
        data_to.objects.extend(data_from.objects)
    
    for object in data_to.objects:
        print(object.name)

        if object.type == &#39;MESH&#39;:    # only add meshes, materials are automatically included
            bpy.ops.object.add_named(name=object.name)
            # When you use bpy.ops.object.add() the newly created object becomes the active object
            # bpy.context.active_object
            active_object = bpy.context.view_layer.objects.active
            bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
            active_object.select_set(True)

            # apply local transform
            
            bpy.ops.transform.translate(value=offset)  # translate
            
            bpy.ops.transform.rotate(value=-rotation[0], orient_axis=&#39;Z&#39;) # blender rotates in opposite direction (2.80)
            bpy.ops.transform.rotate(value=-rotation[1], orient_axis=&#39;Y&#39;)
            bpy.ops.transform.rotate(value=-rotation[2], orient_axis=&#39;X&#39;)
            bpy.ops.transform.resize(value=scale)
            
            bpy.ops.transform.translate(value=(-offset[0], -offset[1], -offset[2])) # and translate back
            
            bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)

            # apply global transforms
            
            active_object.location = position
            active_object.rotation_mode = &#39;QUATERNION&#39;
            active_object.rotation_quaternion = (orientation[3], orientation[0], orientation[1],orientation[2])
            
            n_frame = 1
            for pos, orient in zip(positions, orientations):
                bpy.context.scene.frame_set(n_frame * frames_per_dof)
                n_frame += 1
                
                
                active_object.rotation_quaternion = (orient[3], orient[0], orient[1],orient[2])
                active_object.keyframe_insert(data_path=&#34;rotation_quaternion&#34;, index = -1)
                
                active_object.location = Vector(pos)
                active_object.keyframe_insert(data_path=&#34;location&#34;,index = -1)
                
                
            bpy.context.scene.frame_end = (n_frame-1) * frames_per_dof




            

def add_line(points, diameter, name=None, ani_points = None, frames_per_entry=1):

    bpy.ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    obj_data = bpy.context.active_object.data
    obj_data.bevel_depth = diameter/2
    
    n_points = len(points)
    if n_points &gt; 2:   # by default a curve has two points
        obj_data.splines[0].bezier_points.add(n_points-2)
    
    bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)  # back to object mode
    
    curve = bpy.context.active_object
    bp = curve.data.splines[0].bezier_points

    def setpoints(pts):
        end1 = bp[0]
        end1.co = pts[0]
        end1.handle_left = pts[0]
        end1.handle_right = pts[1]

        end2 = bp[1]
        end2.co = pts[1]
        end2.handle_left = pts[0]
        end2.handle_right = pts[1]

        if len(pts)&gt;2:

            end2.handle_right = pts[2]

            for i in range(2,len(pts)):
                
                end3 = bp[i]
                end3.co = pts[i]
                end3.handle_left = pts[i-1]
                if i &lt; len(pts)-1:
                    end3.handle_right = pts[i+1]
                else:
                    end3.handle_right = pts[i]


    if ani_points is not None:
        for i_frame, cur_points in enumerate(ani_points):
        
            n_frame = i_frame * frames_per_entry
            bpy.context.scene.frame_set(n_frame)
        
            setpoints(cur_points)
                        
            # insert keyframes
            for i_point in range(n_points):
                bp[i_point].keyframe_insert(data_path=&#39;handle_left&#39;, index=-1)
                bp[i_point].keyframe_insert(data_path=&#39;handle_right&#39;, index=-1)
                bp[i_point].keyframe_insert(data_path=&#39;co&#39;, index=-1)

    else:
        setpoints(points)

    if name is not None:
        bpy.context.active_object.name = name

    bpy.context.active_object.data.materials.append(bpy.data.materials[&#39;Cable&#39;])
    bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
    

def add_beam(points, direction, diameter, name=None, ani_points=None, ani_directions=None, frames_per_entry=1):
    bpy.ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    obj_data = bpy.context.active_object.data
    obj_data.bevel_depth = diameter / 2

    n_points = len(points)
    if n_points &gt; 2:  # by default a curve has two points
        obj_data.splines[0].bezier_points.add(n_points - 2)

    bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)  # back to object mode

    curve = bpy.context.active_object
    bp = curve.data.splines[0].bezier_points

    def setpoints(pts, directions):

        L = 0.2*((pts[0][0]-pts[1][0])**2+(pts[0][1]-pts[1][1])**2+(pts[0][2]-pts[1][2])**2)**0.5

        end1 = bp[0]
        end1.co = pts[0]
        end1.handle_left = (pts[0][0]-L*directions[0][0], pts[0][1]-L*directions[0][1],pts[0][2]-L*directions[0][2])
        end1.handle_right = (pts[0][0]+L*directions[0][0], pts[0][1]+L*directions[0][1],pts[0][2]+L*directions[0][2])

        end2 = bp[1]
        end2.co = pts[1]
        end2.handle_left = (pts[1][0]-L*directions[1][0], pts[1][1]-L*directions[1][1],pts[1][2]-L*directions[1][2])
        end2.handle_right = (pts[1][0]+L*directions[1][0], pts[1][1]+L*directions[1][1],pts[1][2]+L*directions[1][2])

    if ani_points is not None:
        for i_frame, (cur_points, cur_dir) in enumerate(zip(ani_points, ani_directions)):

            n_frame = i_frame * frames_per_entry
            bpy.context.scene.frame_set(n_frame)

            setpoints(cur_points, cur_dir)

            # insert keyframes
            for i_point in range(n_points):
                bp[i_point].keyframe_insert(data_path=&#39;handle_left&#39;, index=-1)
                bp[i_point].keyframe_insert(data_path=&#39;handle_right&#39;, index=-1)
                bp[i_point].keyframe_insert(data_path=&#39;co&#39;, index=-1)

    else:
        setpoints(points, direction)

    if name is not None:
        bpy.context.active_object.name = name

    bpy.context.active_object.data.materials.append(bpy.data.materials[&#39;Cable&#39;])
    bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

&#34;&#34;&#34;


def _to_euler(rotation):
    r = Rotation.from_rotvec(deg2rad(rotation))
    return r.as_euler(&#39;zyx&#39;,degrees=False)

def _to_quaternion(rotation):
    r = Rotation.from_rotvec(deg2rad(rotation))
    return r.as_quat()


def create_blend_and_open(scene, blender_result_file = None, blender_base_file=None, blender_exe_path=None, camera=None, animation_dofs=None):

    if blender_base_file is None:
        blender_base_file = consts.BLENDER_BASE_SCENE

    if blender_result_file is None:
        blender_result_file = consts.BLENDER_DEFAULT_OUTFILE

    create_blend(scene, blender_base_file, blender_result_file, blender_exe_path=blender_exe_path,camera=camera, animation_dofs=animation_dofs)
    command = &#39;&#34;{}&#34;&#39;.format(str(blender_result_file))
    system(command)

def create_blend(scene, blender_base_file, blender_result_file, blender_exe_path=None, camera=None,animation_dofs=None):
    tempfile = Path(consts.PATH_TEMP) / &#39;blender.py&#39;

    blender_py_file(scene, tempfile, blender_base_file, blender_result_file,camera=camera,animation_dofs=animation_dofs)

    if blender_exe_path is None:
        blender_exe_path = consts.BLENDER_EXEC

    command = &#39;&#34;&#34;{}&#34; -b --python &#34;{}&#34;&#34;&#39;.format(blender_exe_path, tempfile)
    print(command)
    system(command)

def blender_py_file(scene, python_file, blender_base_file, blender_result_file, camera = None, animation_dofs=None):

    code = &#39;# Auto-generated python file for blender\n# Execute using blender.exe -b --python &#34;{}&#34;\n\n&#39;.format(python_file)
    code += &#39;import bpy\n&#39;
    code += &#39;bpy.ops.wm.open_mainfile(filepath=r&#34;{}&#34;)\n&#39;.format(blender_base_file)
    code += &#39;\n&#39;
    code += BFUNC
    code += &#39;\n# Set 3d cursor to origin&#39;
    code += &#39;\nbpy.context.scene.cursor.location = (0.0, 0.0, 0.0)&#39;

    for visual in scene.nodes_of_type(dc.Visual):

        &#34;&#34;&#34;
        A Visual node contains a 3d visual, typically obtained from a .obj file.
        A visual node can be placed on an axis-type node.
    
        It is used for visualization. It does not affect the forces, dynamics or statics.
    
            visual.offset = [0, 0, 0] :: Offset (x,y,z) of the visual. Offset is applied after scaling
            visual.rotation = :: Rotation (rx,ry,rz) of the visual
            visual.scale :: Scaling of the visual. Scaling is applied before offset.
            visual.path :: Filename of the visual
    
            visual.parent :: Parent : Axis-type
    
            parent is an axis type and has .global_position and .global_rotation
        &#34;&#34;&#34;

        code += &#39;\n# Exporting {}&#39;.format(visual.name)

        # look for the file

        name,_ = splitext(basename(visual.path))

        filename = scene.get_resource_path(name + &#39;.blend&#39;)  # raises exception if file is not found

        # the offset needs to be rotated.

        rot = Rotation.from_rotvec(deg2rad(visual.parent.global_rotation))
        rotated_offset = rot.apply(visual.offset)

        if animation_dofs:
            code += &#39;\npositions = []&#39;
            code += &#39;\norientations = []&#39;
            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()

                code += &#39;\norientations.append([{},{},{},{}])&#39;.format(*_to_quaternion(visual.parent.global_rotation))

                position = visual.parent.global_position
                global_offset = visual.parent.to_glob_direction(visual.offset)

                glob_position = np.array(position) + np.array(global_offset)

                code += &#39;\npositions.append([{},{},{}])&#39;.format(*glob_position)

            code += &#39;\ninsert_objects(filepath=r&#34;{}&#34;, scale=({},{},{}), rotation=({},{},{}), offset=({},{},{}), orientation=({},{},{},{}), position=({},{},{}), positions=positions, orientations=orientations)&#39;.format(
                filename,
                *visual.scale,
                *_to_euler(visual.rotation),
                *rotated_offset,
                *_to_quaternion(visual.parent.global_rotation),
                *visual.parent.global_position)


        else:
            code += &#39;\ninsert_objects(filepath=r&#34;{}&#34;, scale=({},{},{}), rotation=({},{},{}), offset=({},{},{}), orientation=({},{},{},{}), position=({},{},{}))&#39;.format(
                        filename,
                        *visual.scale,
                        *_to_euler(visual.rotation),
                        *rotated_offset,
                        *_to_quaternion(visual.parent.global_rotation),
                        *visual.parent.global_position)





    for cable in scene.nodes_of_type(dc.Cable):

        points = cable.get_points_for_visual()
        dia = cable.diameter

        if dia &lt; consts.BLENDER_CABLE_DIA:
            dia = consts.BLENDER_CABLE_DIA

        code += &#39;\npoints=[&#39;
        for p in points:
            code += &#39;({},{},{}),&#39;.format(*p)
        code = code[:-1]
        code += &#39;]&#39;

        if animation_dofs:
            code += &#39;\nani_points = []&#39;
            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()
                points = cable.get_points_for_visual()
                code += &#39;\nframe_points=[&#39;
                for p in points:
                    code += &#39;({},{},{}),&#39;.format(*p)
                code = code[:-1]
                code += &#39;]&#39;
                code += &#39;\nani_points.append(frame_points)&#39;

            code += &#39;\nadd_line(points, diameter={}, name = &#34;{}&#34;, ani_points = ani_points)&#39;.format(dia, cable.name)

        else:

            code += &#39;\nadd_line(points, diameter={}, name = &#34;{}&#34;)&#39;.format(dia, cable.name)


    for beam in scene.nodes_of_type(dc.LinearBeam):
        pa = beam.master.global_position
        pb = beam.slave.global_position

        code += &#39;\npoints=[&#39;
        code += &#39;({},{},{}),&#39;.format(*pa)
        code += &#39;({},{},{})]&#39;.format(*pb)

        code += &#39;\ndirections=[&#39;
        code += &#39;({},{},{}),&#39;.format(*beam.master.ux)
        code += &#39;({},{},{})]&#39;.format(*beam.slave.ux)

        dia = consts.BLENDER_BEAM_DIA

        if animation_dofs:
            code += &#39;\nani_points = []&#39;
            code += &#39;\nani_dirs = []&#39;

            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()
                pa = beam.master.global_position
                pb = beam.slave.global_position

                code += &#39;\nf_points=[&#39;
                code += &#39;({},{},{}),&#39;.format(*pa)
                code += &#39;({},{},{})]&#39;.format(*pb)

                code += &#39;\nf_directions=[&#39;
                code += &#39;({},{},{}),&#39;.format(*beam.master.ux)
                code += &#39;({},{},{})]&#39;.format(*beam.slave.ux)

                code += &#39;\nani_points.append(f_points)&#39;
                code += &#39;\nani_dirs.append(f_directions)&#39;



            code += &#39;\nadd_beam(points, directions, diameter={}, name = &#34;{}&#34;, ani_points = ani_points,ani_directions = ani_dirs)&#39;.format(dia, beam.name)
        else:
            code += &#39;\nadd_beam(points, directions, diameter={}, name = &#34;{}&#34;)&#39;.format(dia, beam.name)



    if camera is not None:
        pos = camera[&#39;position&#39;]
        dir = camera[&#39;direction&#39;]

        code += &#39;\n\n# Set the active camera&#39;
        code += &#39;\nobj_camera = bpy.context.scene.camera&#39;
        code += &#39;\nobj_camera.location = ({},{},{})&#39;.format(*pos)
        code += &#39;\ndir = Vector(({},{},{}))\n&#39;.format(*dir)
        code += &#34;\nq = dir.to_track_quat(&#39;-Z&#39;,&#39;Y&#39;)\nobj_camera.rotation_euler = q.to_euler()&#34;

    code += &#39;\nbpy.ops.wm.save_mainfile(filepath=r&#34;{}&#34;)&#39;.format(blender_result_file)
    # bpy.ops.wm.quit_blender() # not needed

    print(code)

    file = open(python_file, &#39;w+&#39;)
    file.write(code)
    file.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DAVE.io.blender.blender_py_file"><code class="name flex">
<span>def <span class="ident">blender_py_file</span></span>(<span>scene, python_file, blender_base_file, blender_result_file, camera=None, animation_dofs=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blender_py_file(scene, python_file, blender_base_file, blender_result_file, camera = None, animation_dofs=None):

    code = &#39;# Auto-generated python file for blender\n# Execute using blender.exe -b --python &#34;{}&#34;\n\n&#39;.format(python_file)
    code += &#39;import bpy\n&#39;
    code += &#39;bpy.ops.wm.open_mainfile(filepath=r&#34;{}&#34;)\n&#39;.format(blender_base_file)
    code += &#39;\n&#39;
    code += BFUNC
    code += &#39;\n# Set 3d cursor to origin&#39;
    code += &#39;\nbpy.context.scene.cursor.location = (0.0, 0.0, 0.0)&#39;

    for visual in scene.nodes_of_type(dc.Visual):

        &#34;&#34;&#34;
        A Visual node contains a 3d visual, typically obtained from a .obj file.
        A visual node can be placed on an axis-type node.
    
        It is used for visualization. It does not affect the forces, dynamics or statics.
    
            visual.offset = [0, 0, 0] :: Offset (x,y,z) of the visual. Offset is applied after scaling
            visual.rotation = :: Rotation (rx,ry,rz) of the visual
            visual.scale :: Scaling of the visual. Scaling is applied before offset.
            visual.path :: Filename of the visual
    
            visual.parent :: Parent : Axis-type
    
            parent is an axis type and has .global_position and .global_rotation
        &#34;&#34;&#34;

        code += &#39;\n# Exporting {}&#39;.format(visual.name)

        # look for the file

        name,_ = splitext(basename(visual.path))

        filename = scene.get_resource_path(name + &#39;.blend&#39;)  # raises exception if file is not found

        # the offset needs to be rotated.

        rot = Rotation.from_rotvec(deg2rad(visual.parent.global_rotation))
        rotated_offset = rot.apply(visual.offset)

        if animation_dofs:
            code += &#39;\npositions = []&#39;
            code += &#39;\norientations = []&#39;
            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()

                code += &#39;\norientations.append([{},{},{},{}])&#39;.format(*_to_quaternion(visual.parent.global_rotation))

                position = visual.parent.global_position
                global_offset = visual.parent.to_glob_direction(visual.offset)

                glob_position = np.array(position) + np.array(global_offset)

                code += &#39;\npositions.append([{},{},{}])&#39;.format(*glob_position)

            code += &#39;\ninsert_objects(filepath=r&#34;{}&#34;, scale=({},{},{}), rotation=({},{},{}), offset=({},{},{}), orientation=({},{},{},{}), position=({},{},{}), positions=positions, orientations=orientations)&#39;.format(
                filename,
                *visual.scale,
                *_to_euler(visual.rotation),
                *rotated_offset,
                *_to_quaternion(visual.parent.global_rotation),
                *visual.parent.global_position)


        else:
            code += &#39;\ninsert_objects(filepath=r&#34;{}&#34;, scale=({},{},{}), rotation=({},{},{}), offset=({},{},{}), orientation=({},{},{},{}), position=({},{},{}))&#39;.format(
                        filename,
                        *visual.scale,
                        *_to_euler(visual.rotation),
                        *rotated_offset,
                        *_to_quaternion(visual.parent.global_rotation),
                        *visual.parent.global_position)





    for cable in scene.nodes_of_type(dc.Cable):

        points = cable.get_points_for_visual()
        dia = cable.diameter

        if dia &lt; consts.BLENDER_CABLE_DIA:
            dia = consts.BLENDER_CABLE_DIA

        code += &#39;\npoints=[&#39;
        for p in points:
            code += &#39;({},{},{}),&#39;.format(*p)
        code = code[:-1]
        code += &#39;]&#39;

        if animation_dofs:
            code += &#39;\nani_points = []&#39;
            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()
                points = cable.get_points_for_visual()
                code += &#39;\nframe_points=[&#39;
                for p in points:
                    code += &#39;({},{},{}),&#39;.format(*p)
                code = code[:-1]
                code += &#39;]&#39;
                code += &#39;\nani_points.append(frame_points)&#39;

            code += &#39;\nadd_line(points, diameter={}, name = &#34;{}&#34;, ani_points = ani_points)&#39;.format(dia, cable.name)

        else:

            code += &#39;\nadd_line(points, diameter={}, name = &#34;{}&#34;)&#39;.format(dia, cable.name)


    for beam in scene.nodes_of_type(dc.LinearBeam):
        pa = beam.master.global_position
        pb = beam.slave.global_position

        code += &#39;\npoints=[&#39;
        code += &#39;({},{},{}),&#39;.format(*pa)
        code += &#39;({},{},{})]&#39;.format(*pb)

        code += &#39;\ndirections=[&#39;
        code += &#39;({},{},{}),&#39;.format(*beam.master.ux)
        code += &#39;({},{},{})]&#39;.format(*beam.slave.ux)

        dia = consts.BLENDER_BEAM_DIA

        if animation_dofs:
            code += &#39;\nani_points = []&#39;
            code += &#39;\nani_dirs = []&#39;

            for dof in animation_dofs:
                scene._vfc.set_dofs(dof)
                scene.update()
                pa = beam.master.global_position
                pb = beam.slave.global_position

                code += &#39;\nf_points=[&#39;
                code += &#39;({},{},{}),&#39;.format(*pa)
                code += &#39;({},{},{})]&#39;.format(*pb)

                code += &#39;\nf_directions=[&#39;
                code += &#39;({},{},{}),&#39;.format(*beam.master.ux)
                code += &#39;({},{},{})]&#39;.format(*beam.slave.ux)

                code += &#39;\nani_points.append(f_points)&#39;
                code += &#39;\nani_dirs.append(f_directions)&#39;



            code += &#39;\nadd_beam(points, directions, diameter={}, name = &#34;{}&#34;, ani_points = ani_points,ani_directions = ani_dirs)&#39;.format(dia, beam.name)
        else:
            code += &#39;\nadd_beam(points, directions, diameter={}, name = &#34;{}&#34;)&#39;.format(dia, beam.name)



    if camera is not None:
        pos = camera[&#39;position&#39;]
        dir = camera[&#39;direction&#39;]

        code += &#39;\n\n# Set the active camera&#39;
        code += &#39;\nobj_camera = bpy.context.scene.camera&#39;
        code += &#39;\nobj_camera.location = ({},{},{})&#39;.format(*pos)
        code += &#39;\ndir = Vector(({},{},{}))\n&#39;.format(*dir)
        code += &#34;\nq = dir.to_track_quat(&#39;-Z&#39;,&#39;Y&#39;)\nobj_camera.rotation_euler = q.to_euler()&#34;

    code += &#39;\nbpy.ops.wm.save_mainfile(filepath=r&#34;{}&#34;)&#39;.format(blender_result_file)
    # bpy.ops.wm.quit_blender() # not needed

    print(code)

    file = open(python_file, &#39;w+&#39;)
    file.write(code)
    file.close()</code></pre>
</details>
</dd>
<dt id="DAVE.io.blender.create_blend"><code class="name flex">
<span>def <span class="ident">create_blend</span></span>(<span>scene, blender_base_file, blender_result_file, blender_exe_path=None, camera=None, animation_dofs=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_blend(scene, blender_base_file, blender_result_file, blender_exe_path=None, camera=None,animation_dofs=None):
    tempfile = Path(consts.PATH_TEMP) / &#39;blender.py&#39;

    blender_py_file(scene, tempfile, blender_base_file, blender_result_file,camera=camera,animation_dofs=animation_dofs)

    if blender_exe_path is None:
        blender_exe_path = consts.BLENDER_EXEC

    command = &#39;&#34;&#34;{}&#34; -b --python &#34;{}&#34;&#34;&#39;.format(blender_exe_path, tempfile)
    print(command)
    system(command)</code></pre>
</details>
</dd>
<dt id="DAVE.io.blender.create_blend_and_open"><code class="name flex">
<span>def <span class="ident">create_blend_and_open</span></span>(<span>scene, blender_result_file=None, blender_base_file=None, blender_exe_path=None, camera=None, animation_dofs=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_blend_and_open(scene, blender_result_file = None, blender_base_file=None, blender_exe_path=None, camera=None, animation_dofs=None):

    if blender_base_file is None:
        blender_base_file = consts.BLENDER_BASE_SCENE

    if blender_result_file is None:
        blender_result_file = consts.BLENDER_DEFAULT_OUTFILE

    create_blend(scene, blender_base_file, blender_result_file, blender_exe_path=blender_exe_path,camera=camera, animation_dofs=animation_dofs)
    command = &#39;&#34;{}&#34;&#39;.format(str(blender_result_file))
    system(command)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DAVE.io" href="index.html">DAVE.io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DAVE.io.blender.blender_py_file" href="#DAVE.io.blender.blender_py_file">blender_py_file</a></code></li>
<li><code><a title="DAVE.io.blender.create_blend" href="#DAVE.io.blender.create_blend">create_blend</a></code></li>
<li><code><a title="DAVE.io.blender.create_blend_and_open" href="#DAVE.io.blender.create_blend_and_open">create_blend_and_open</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>