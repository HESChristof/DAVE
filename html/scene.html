<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>DAVE.scene API documentation</title>
<meta name="description" content="This is the main module of the engine. It contains both the nodes and the scene.
For calculations, this, together with settings.py, are the only …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.scene</code></h1>
</header>
<section id="section-intro">
<p>This is the main module of the engine. It contains both the nodes and the scene.
For calculations, this, together with settings.py, are the only required files.</p>
<p>If this is the first time you use DAVE, please use the Gui and youtube to experiment.</p>
<p>The purpose of this part of the documentation is to explain the general principles of DAVE and to provide a reference.</p>
<h1 id="general">General</h1>
<h2 id="axis-systems">Axis systems</h2>
<p>Axis systems are right-handed.</p>
<p>In the global axis system the Z-axis points up.</p>
<p>The mean sea-surface is defined as Z=0</p>
<h2 id="units">Units</h2>
<p>The default unit system is m, kN, mT (metric tonne).
G and RHO are defined accordingly.</p>
<h2 id="3d-rotations">3D rotations</h2>
<p>Unfortunately there is no standard way of defining rotations in 3D.</p>
<p>DAVE uses a <a href="https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector">rotation vector</a> to represent rotations.
This means that the rotation is defined as a vector with three components (rx,ry,rz). The magnitude of the vector is the rotation in degrees.
The axis of rotation is the direction of the vector.</p>
<p>Some examples:</p>
<ul>
<li><code>(0,0,90)</code> : A rotation of 90 degrees about the Z-axis</li>
<li><code>(0,-10,0)</code> : A rotation of -10 degrees about the Y-axis</li>
<li><code>(10,10,0)</code> : A rotation of sqrt(10^2 + 10^2) about the (1,1,0) axis.</li>
</ul>
<p>Hint: If euler angles are needed then axis systems can be stacked to obtain the same result.</p>
<h2 id="filesystem-and-configuration">Filesystem and configuration</h2>
<p>By default DAVE will try to create a subfolder "DAVE_models" in the users HOME folder (%homepath% in windows,
~ in linux). This folder will be used for storing temporary files, the log file, and as default save location for assets and models.</p>
<p>DAVE can be configured by changing the settings in the settings.py file or by manually overriding them after importing settings.py and before importing scene.py</p>
<pre><code>import DAVE.settings
from DAVE.scene import *
from pathlib import Path

# override some of the settings
DAVE.settings.RESOURCE_PATH = [Path(r'c:\data')]
DAVE.settings.BLENDER_EXEC = r'C:\Program Files\Blender Foundation\Blender.82 alphalender.exe'

# now create the scene
s = Scene()

print(s.resources_paths)
</code></pre>
<p>All settings are defined in UPPERCASE.</p>
<h3 id="or">/ or \</h3>
<p>DAVE is multiplatform. It runs fine under windows as well as linux.
Windows uses a \ in path definitions while linux uses as /.
The python standard <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> library is used to deal with paths. In most situations however a string will work fine as well.</p>
<p>Note: Changing G or RHO has no effect at this moment as these values would also need to be changed in the equilibrium-core</p>
<h2 id="file-format">File format</h2>
<p>The standard file-format for saving DAVE scenes and nodes is <a href="https://en.wikipedia.org/wiki/Vanilla_software">vanilla</a> python.</p>
<p>When loading a model or asset from a file into a scene the contents of that file are executed in the python interpreter. In the interpreter a variable <code>s</code> is
available which refers to the current scene.</p>
<p>This makes it possible to define DAVE models in a very flexible way as arbitrary code can be executed when importing the model. Importing a model into DAVE is basically the same as running a file, so beware of the involed security implications.</p>
<h1 id="scene-and-nodes">Scene and nodes</h1>
<p>A node is an item or element in a model. For example a ship or a force.
A Scene is a collection of nodes.</p>
<p>The common way of working is as follows:</p>
<ol>
<li>Create a scene</li>
<li>Add nodes to it</li>
</ol>
<p>Nodes are added to the scene using .new_nodetype() where nodetype is the type of the node. Each node has a unique name. This is always needs to be provided to the .new_node function.
A complete list of node types and corresponding functions is provided later.</p>
<p>Example</p>
<pre><code>s = Scene()                               # create an empty scene
s.new_poi('point 1')                      # creates a poi with name anchor
s.new_poi('point 2', position = (10,0,0)) # create a second poi at x=10
s.new_cable('line',poiA = 'point 1', poiB = 'point 2')
      # creates a cable between the two points
s.save_scene(r'test.dave_asset')              # save to file
</code></pre>
<p>Nodes in a scene can be referenced by either name or by reference.
The .new_nodetype() functions return a reference to the newly created node.</p>
<pre><code>s = Scene()
a = s.new_axis('axis')
    # a is now a reference to node 'axis'

p1 = s.new_poi('poi_1', parent = a )       # refer by reference
p2 = s.new_poi('poi_2', parent = 'axis' )  # refer by name
</code></pre>
<p>A reference to a node can also be obtained from the scene using square brackets:</p>
<pre><code>s = Scene()
s.new_axis('axis')

a = s['axis']
print(a.position)
</code></pre>
<h1 id="nodes">Nodes</h1>
<p>The following node types can be used:</p>
<h2 id="geometry">Geometry</h2>
<p>The geometry of a scene is setup using <a title="DAVE.scene.Axis" href="#DAVE.scene.Axis"><code>Axis</code></a>, <a title="DAVE.scene.Poi" href="#DAVE.scene.Poi"><code>Poi</code></a> and <a title="DAVE.scene.Sheave" href="#DAVE.scene.Sheave"><code>Sheave</code></a> nodes.</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Provides</th>
<th align="left">Create using</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis"><code>Axis</code></a></td>
<td align="left">Axis system with position and orientation</td>
<td align="left"><a title="DAVE.scene.Scene.new_axis" href="#DAVE.scene.Scene.new_axis"><code>Scene.new_axis()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.Poi" href="#DAVE.scene.Poi"><code>Poi</code></a></td>
<td align="left">A position</td>
<td align="left"><a title="DAVE.scene.Scene.new_poi" href="#DAVE.scene.Scene.new_poi"><code>Scene.new_poi()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.Sheave" href="#DAVE.scene.Sheave"><code>Sheave</code></a></td>
<td align="left">A disk with a radius and axis direction</td>
<td align="left"><a title="DAVE.scene.Scene.new_sheave" href="#DAVE.scene.Scene.new_sheave"><code>Scene.new_sheave()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody"><code>RigidBody</code></a></td>
<td align="left">Same as axis system, but provides a weight as well</td>
<td align="left"><a title="DAVE.scene.Scene.new_rigidbody" href="#DAVE.scene.Scene.new_rigidbody"><code>Scene.new_rigidbody()</code></a></td>
</tr>
</tbody>
</table>
<p>A RigidBody is technically idential to an axis system. So everything that applies to Axis also applies to RigidBody
and everywhere where an axis system is used a rigidbody can be used as well.</p>
<ul>
<li>Axis can be placed on other axis systems.</li>
<li>Pois can be located on an axis system.</li>
<li>Sheaves need to be placed on a poi.</li>
</ul>
<p>If a node has a parent then this means that its position and orientation are expressed relative to that parent.
For nodes without a parent everything is defined relative to the global axis system.</p>
<h3 id="forces">Forces</h3>
<p>Geometry nodes are also used to transfer forces.</p>
<p>Axis and Poi type nodes can receive forces and moments and apply them to their parents. See <a title="DAVE.scene.Poi.applied_force_and_moment_global" href="#DAVE.scene.Poi.applied_force_and_moment_global"><code>Poi.applied_force_and_moment_global</code></a>,
<a title="DAVE.scene.Axis.applied_force" href="#DAVE.scene.Axis.applied_force"><code>Axis.applied_force</code></a> and <a title="DAVE.scene.Axis.connection_force" href="#DAVE.scene.Axis.connection_force"><code>Axis.connection_force</code></a>.
Cables running over sheave type nodes will apply the forces directly to the parent node of the sheave.</p>
<h3 id="degrees-of-freedom">Degrees of freedom</h3>
<p>Axis and RigidBodies can have all their six individual degrees of freedom either fixed or free. If a degree of freedom is free then this means that the
node is able to move/rotate in this degree of freedom.</p>
<h2 id="connectors">Connectors</h2>
<p>Connectors connect two or more nodes and can apply a force on them based on their positions and orientations.</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Provides</th>
<th align="left">Create using</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a title="DAVE.scene.Cable" href="#DAVE.scene.Cable"><code>Cable</code></a></td>
<td align="left">A finite length cable with linear stiffness. A cable runs between two Poi nodes and can run over multiple pois or sheaves. A cable may have a diameter.</td>
<td align="left"><a title="DAVE.scene.Scene.new_cable" href="#DAVE.scene.Scene.new_cable"><code>Scene.new_cable()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.LinearBeam" href="#DAVE.scene.LinearBeam"><code>LinearBeam</code></a></td>
<td align="left">A beam connects two axis systems with a linear beam element</td>
<td align="left"><a title="DAVE.scene.Scene.new_linear_beam" href="#DAVE.scene.Scene.new_linear_beam"><code>Scene.new_linear_beam()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d"><code>LC6d</code></a></td>
<td align="left">Connects two axis systems with six linear springs. Orientation of the springs is determined by the master axis system</td>
<td align="left"><a title="DAVE.scene.Scene.new_linear_connector_6d" href="#DAVE.scene.Scene.new_linear_connector_6d"><code>Scene.new_linear_connector_6d()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d"><code>Connector2d</code></a></td>
<td align="left">Connects two axis systems with two linear springs. Orientation of the springs is determined by shortest distance between the two axis systems</td>
<td align="left"><a title="DAVE.scene.Scene.new_connector2d" href="#DAVE.scene.Scene.new_connector2d"><code>Scene.new_connector2d()</code></a></td>
</tr>
</tbody>
</table>
<h2 id="forces_1">Forces</h2>
<p>Forces apply a force to a node. The magnitude of the force may depend on the position and/or orientation of the node.</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Provides</th>
<th align="left">Create using</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a title="DAVE.scene.Force" href="#DAVE.scene.Force"><code>Force</code></a></td>
<td align="left">An fixed force and/or moment applied on a Poi</td>
<td align="left"><a title="DAVE.scene.Scene.new_force" href="#DAVE.scene.Scene.new_force"><code>Scene.new_force()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring"><code>HydSpring</code></a></td>
<td align="left">A linear hydrostatic spring attached to an Axis</td>
<td align="left"><a title="DAVE.scene.Scene.new_hydspring" href="#DAVE.scene.Scene.new_hydspring"><code>Scene.new_hydspring()</code></a></td>
</tr>
<tr>
<td align="left"><a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy"><code>Buoyancy</code></a></td>
<td align="left">A buoyancy mesh attached to an Axis</td>
<td align="left"><a title="DAVE.scene.Scene.new_buoyancy" href="#DAVE.scene.Scene.new_buoyancy"><code>Scene.new_buoyancy()</code></a></td>
</tr>
</tbody>
</table>
<h2 id="visuals">Visuals</h2>
<p>(Almost) Everything gets better when visualized :-).</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Provides</th>
<th align="left">Create using</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a title="DAVE.scene.Visual" href="#DAVE.scene.Visual"><code>Visual</code></a></td>
<td align="left">Obj type 3D visuals can be attached to an Axis</td>
<td align="left"><a title="DAVE.scene.Scene.new_visual" href="#DAVE.scene.Scene.new_visual"><code>Scene.new_visual()</code></a></td>
</tr>
</tbody>
</table>
<h2 id="others">Others</h2>
<p><a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource"><code>TriMeshSource</code></a> is a node that defines a triangular mesh. It is not created directly but is created implicitly when
creating a buoyuany node. It may be accessed via <a title="DAVE.scene.Buoyancy.trimesh" href="#DAVE.scene.Buoyancy.trimesh"><code>Buoyancy.trimesh</code></a>. Multiple buoyancy nodes may share the same TriMeshSource.</p>
<h1 id="scene">Scene</h1>
<p>Apart from methods to create nodes, Scene also harbours functionality to delete, import, re-order and export nodes.</p>
<h2 id="creating-scenes">Creating scenes</h2>
<p>A Scene is not a singleton. Multiple scenes can exist next to eachother.</p>
<p>A new and empty Scene can be created as follows:</p>
<pre><code>s = Scene()
</code></pre>
<p>where <code>s</code> can be anything, for example <code>my_scene</code> but s is nice and short which is usefull as it will be used a lot.</p>
<p>Optionally a filename can be provided to the constructor. In that case that file will be imported.</p>
<pre><code>my_vessel = Scene('path/to/my_vessel.dave_asset')
</code></pre>
<p>It is also possible to create a (deep) copy of a scene. This is done as follows:</p>
<pre><code>copy_of_scene = Scene(copy_from = other_scene)
</code></pre>
<h2 id="adding-content">Adding content</h2>
<p>Nodes can be added to the scene using the s.new_poi, s.new_axis, etc.. functions which were introduced in the previous section.</p>
<p>Multiple nodes can be imported from file or directly from another Scene object using <a title="DAVE.scene.Scene.load_scene" href="#DAVE.scene.Scene.load_scene"><code>Scene.load_scene()</code></a> or <a title="DAVE.scene.Scene.import_scene" href="#DAVE.scene.Scene.import_scene"><code>Scene.import_scene()</code></a> respectively.</p>
<p>Note: Beware of name-conflicts when importing. The <a title="DAVE.scene.Scene.import_scene" href="#DAVE.scene.Scene.import_scene"><code>Scene.import_scene()</code></a> provides the option to add a prefix to names of imported nodes.</p>
<h2 id="access-nodes">Access nodes</h2>
<p>A list of nodes is maintained as the ._nodes property of a scene. It is advised not to use this directly.</p>
<p>Obtaining a reference to a single node can be done using its name:</p>
<pre><code>node = s['node_name']
</code></pre>
<p>This is the reason why all node names should be unique. To get a list of all available node names use <a title="DAVE.scene.Scene.print_node_tree" href="#DAVE.scene.Scene.print_node_tree"><code>Scene.print_node_tree()</code></a></p>
<p>It is also possible to:</p>
<ul>
<li>Get all nodes of a type, use : <a title="DAVE.scene.Scene.nodes_of_type" href="#DAVE.scene.Scene.nodes_of_type"><code>Scene.nodes_of_type()</code></a></li>
<li>Get all nodes that depend on a node : <a title="DAVE.scene.Scene.nodes_depending_on" href="#DAVE.scene.Scene.nodes_depending_on"><code>Scene.nodes_depending_on()</code></a></li>
<li>Get all child nodes : <a title="DAVE.scene.Scene.nodes_with_parent" href="#DAVE.scene.Scene.nodes_with_parent"><code>Scene.nodes_with_parent()</code></a></li>
</ul>
<h2 id="deleting-nodes">Deleting nodes</h2>
<p>Removing nodes can be tricky due to nodes depending on eachother. For example deleting a poi which is also used a endpoint for a cable will cause problems for that cable.
The same applies to axis systems with nodes on it (children)</p>
<p><a title="DAVE.scene.Scene.clear" href="#DAVE.scene.Scene.clear"><code>Scene.clear()</code></a> can be used to delete all nodes from a scene.</p>
<p>To delete a single node there are two options:</p>
<ol>
<li><a title="DAVE.scene.Scene.delete" href="#DAVE.scene.Scene.delete"><code>Scene.delete()</code></a>. This deletes a node from the scene. All nodes that depend on this node will be deleted as well.</li>
<li><a title="DAVE.scene.Scene.dissolve" href="#DAVE.scene.Scene.dissolve"><code>Scene.dissolve()</code></a>. This "evaporates" the node. Attempts to maintain child nodes. Often used in combination with the containerize option of <a title="DAVE.scene.Scene.import_scene" href="#DAVE.scene.Scene.import_scene"><code>Scene.import_scene()</code></a></li>
</ol>
<h2 id="saving-or-exporting">Saving or exporting</h2>
<p>The standard file-format for saving DAVE scenes and nodes is <a href="https://en.wikipedia.org/wiki/Vanilla_software">vanilla</a> python.</p>
<p>The contents of a Scene can be save using <a title="DAVE.scene.Scene.save_scene" href="#DAVE.scene.Scene.save_scene"><code>Scene.save_scene()</code></a>. The python code to re-create the scene can be obtained using <a title="DAVE.scene.Scene.give_python_code" href="#DAVE.scene.Scene.give_python_code"><code>Scene.give_python_code()</code></a>.</p>
<h2 id="solving">Solving</h2>
<p>Solving static equilibrium is done using <a title="DAVE.scene.Scene.solve_statics" href="#DAVE.scene.Scene.solve_statics"><code>Scene.solve_statics()</code></a>. If there is a static equilibrium condition then this function will attempt to find it by changing the non-fixed degrees of freedom of the scene.</p>
<h2 id="optimalizations">Optimalizations</h2>
<p>A goal-seek function is available: <a title="DAVE.scene.Scene.goal_seek" href="#DAVE.scene.Scene.goal_seek"><code>Scene.goal_seek()</code></a>.</p>
<h2 id="resources">Resources</h2>
<p>In the default resource system the resources may be located in any of the folders listed in <a title="DAVE.scene.Scene.resources_paths" href="#DAVE.scene.Scene.resources_paths"><code>Scene.resources_paths</code></a>.
The value of this property is initialized with <code>DAVE.settings.RESOURCE_PATH</code>.</p>
<p><a title="DAVE.scene.Scene.get_resource_list" href="#DAVE.scene.Scene.get_resource_list"><code>Scene.get_resource_list()</code></a> can be used to obtain a list of all available resources. <a title="DAVE.scene.Scene.get_resource_path" href="#DAVE.scene.Scene.get_resource_path"><code>Scene.get_resource_path()</code></a> can
be used to obtain a full path to a resource with a known name.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    This is the main module of the engine. It contains both the nodes and the scene.
    For calculations, this, together with settings.py, are the only required files.

    If this is the first time you use DAVE, please use the Gui and youtube to experiment.

    The purpose of this part of the documentation is to explain the general principles of DAVE and to provide a reference.

    #General#

    ##Axis systems##

    Axis systems are right-handed.

    In the global axis system the Z-axis points up.

    The mean sea-surface is defined as Z=0

    ##Units##

    The default unit system is m, kN, mT (metric tonne).
    G and RHO are defined accordingly.

    ##3D rotations##

    Unfortunately there is no standard way of defining rotations in 3D.

    DAVE uses a [rotation vector](https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector) to represent rotations.
    This means that the rotation is defined as a vector with three components (rx,ry,rz). The magnitude of the vector is the rotation in degrees.
    The axis of rotation is the direction of the vector.

    Some examples:

    - `(0,0,90)` : A rotation of 90 degrees about the Z-axis
    - `(0,-10,0)` : A rotation of -10 degrees about the Y-axis
    - `(10,10,0)` : A rotation of sqrt(10^2 + 10^2) about the (1,1,0) axis.

    Hint: If euler angles are needed then axis systems can be stacked to obtain the same result.

    ##Filesystem and configuration##

    By default DAVE will try to create a subfolder &#34;DAVE_models&#34; in the users HOME folder (%homepath% in windows,  ~ in linux). This folder will be used for storing temporary files, the log file, and as default save location for assets and models.

    DAVE can be configured by changing the settings in the settings.py file or by manually overriding them after importing settings.py and before importing scene.py



        import DAVE.settings
        from DAVE.scene import *
        from pathlib import Path

        # override some of the settings
        DAVE.settings.RESOURCE_PATH = [Path(r&#39;c:\data&#39;)]
        DAVE.settings.BLENDER_EXEC = r&#39;C:\Program Files\Blender Foundation\Blender\2.82 alpha\blender.exe&#39;

        # now create the scene
        s = Scene()

        print(s.resources_paths)

    All settings are defined in UPPERCASE.

    ###/ or \\ ###

    DAVE is multiplatform. It runs fine under windows as well as linux.
    Windows uses a \\ in path definitions while linux uses as /.
    The python standard [pathlib](https://docs.python.org/3/library/pathlib.html) library is used to deal with paths. In most situations however a string will work fine as well.

    Note: Changing G or RHO has no effect at this moment as these values would also need to be changed in the equilibrium-core

    ##File format##

    The standard file-format for saving DAVE scenes and nodes is [vanilla](https://en.wikipedia.org/wiki/Vanilla_software) python.

    When loading a model or asset from a file into a scene the contents of that file are executed in the python interpreter. In the interpreter a variable `s` is
    available which refers to the current scene.

    This makes it possible to define DAVE models in a very flexible way as arbitrary code can be executed when importing the model. Importing a model into DAVE is basically the same as running a file, so beware of the involed security implications.


    # Scene and nodes #
    A node is an item or element in a model. For example a ship or a force.
    A Scene is a collection of nodes.

    The common way of working is as follows:

    1. Create a scene
    2. Add nodes to it

    Nodes are added to the scene using .new_nodetype() where nodetype is the type of the node. Each node has a unique name. This is always needs to be provided to the .new_node function.
    A complete list of node types and corresponding functions is provided later.

    Example

        s = Scene()                               # create an empty scene
        s.new_poi(&#39;point 1&#39;)                      # creates a poi with name anchor
        s.new_poi(&#39;point 2&#39;, position = (10,0,0)) # create a second poi at x=10
        s.new_cable(&#39;line&#39;,poiA = &#39;point 1&#39;, poiB = &#39;point 2&#39;)
              # creates a cable between the two points
        s.save_scene(r&#39;test.dave_asset&#39;)              # save to file


    Nodes in a scene can be referenced by either name or by reference.
    The .new_nodetype() functions return a reference to the newly created node.

        s = Scene()
        a = s.new_axis(&#39;axis&#39;)
            # a is now a reference to node &#39;axis&#39;

        p1 = s.new_poi(&#39;poi_1&#39;, parent = a )       # refer by reference
        p2 = s.new_poi(&#39;poi_2&#39;, parent = &#39;axis&#39; )  # refer by name

    A reference to a node can also be obtained from the scene using square brackets:

        s = Scene()
        s.new_axis(&#39;axis&#39;)

        a = s[&#39;axis&#39;]
        print(a.position)


    #Nodes#

    The following node types can be used:

    ##Geometry##

    The geometry of a scene is setup using `Axis`, `Poi` and `Sheave` nodes.

    |  Type | Provides  | Create using |
    |:---------------- |:------------------------------- |:-----|
    | `DAVE.scene.Axis` | Axis system with position and orientation  |  `DAVE.scene.Scene.new_axis` |
    | `DAVE.scene.Poi` | A position  |  `DAVE.scene.Scene.new_poi` |
    | `DAVE.scene.Sheave` | A disk with a radius and axis direction  |  `DAVE.scene.Scene.new_sheave` |
    | `RigidBody` | Same as axis system, but provides a weight as well  |  `DAVE.scene.Scene.new_rigidbody` |

    A RigidBody is technically idential to an axis system. So everything that applies to Axis also applies to RigidBody
    and everywhere where an axis system is used a rigidbody can be used as well.

    - Axis can be placed on other axis systems.
    - Pois can be located on an axis system.
    - Sheaves need to be placed on a poi.

    If a node has a parent then this means that its position and orientation are expressed relative to that parent.
    For nodes without a parent everything is defined relative to the global axis system.


    ###Forces###

    Geometry nodes are also used to transfer forces.

    Axis and Poi type nodes can receive forces and moments and apply them to their parents. See `Poi.applied_force_and_moment_global`,
    `Axis.applied_force` and `Axis.connection_force`.
    Cables running over sheave type nodes will apply the forces directly to the parent node of the sheave.

    ###Degrees of freedom###

    Axis and RigidBodies can have all their six individual degrees of freedom either fixed or free. If a degree of freedom is free then this means that the
    node is able to move/rotate in this degree of freedom.



    ##Connectors##

    Connectors connect two or more nodes and can apply a force on them based on their positions and orientations.

    |  Type | Provides  | Create using |
    |:---------------- |:------------------------------- |:-----|
    | `Cable` | A finite length cable with linear stiffness. A cable runs between two Poi nodes and can run over multiple pois or sheaves. A cable may have a diameter.   |  `Scene.new_cable` |
    | `LinearBeam` | A beam connects two axis systems with a linear beam element   |  `Scene.new_linear_beam` |
    | `LC6d` | Connects two axis systems with six linear springs. Orientation of the springs is determined by the master axis system   |  `Scene.new_linear_connector_6d` |
    | `Connector2d` | Connects two axis systems with two linear springs. Orientation of the springs is determined by shortest distance between the two axis systems |  `Scene.new_connector2d` |


    ##Forces##

    Forces apply a force to a node. The magnitude of the force may depend on the position and/or orientation of the node.

    |  Type | Provides  | Create using |
    |:---------------- |:------------------------------- |:-----|
    | `Force` | An fixed force and/or moment applied on a Poi |  `Scene.new_force` |
    | `HydSpring` | A linear hydrostatic spring attached to an Axis  |  `Scene.new_hydspring` |
    | `Buoyancy` | A buoyancy mesh attached to an Axis  |  `Scene.new_buoyancy` |

    ##Visuals##

    (Almost) Everything gets better when visualized :-).

    |  Type | Provides  | Create using |
    |:---------------- |:------------------------------- |:-----|
    | `Visual` | Obj type 3D visuals can be attached to an Axis |  `Scene.new_visual` |

    ##Others###

    `TriMeshSource` is a node that defines a triangular mesh. It is not created directly but is created implicitly when
    creating a buoyuany node. It may be accessed via `Buoyancy.trimesh`. Multiple buoyancy nodes may share the same TriMeshSource.




    #Scene#
    
    Apart from methods to create nodes, Scene also harbours functionality to delete, import, re-order and export nodes.

    ##Creating scenes##

    A Scene is not a singleton. Multiple scenes can exist next to eachother.

    A new and empty Scene can be created as follows:

        s = Scene()

     where `s` can be anything, for example `my_scene` but s is nice and short which is usefull as it will be used a lot.

     Optionally a filename can be provided to the constructor. In that case that file will be imported.

        my_vessel = Scene(&#39;path/to/my_vessel.dave_asset&#39;)

    It is also possible to create a (deep) copy of a scene. This is done as follows:

        copy_of_scene = Scene(copy_from = other_scene)


    ##Adding content##

    Nodes can be added to the scene using the s.new_poi, s.new_axis, etc.. functions which were introduced in the previous section.


    Multiple nodes can be imported from file or directly from another Scene object using `Scene.load_scene()` or `Scene.import_scene()` respectively.

    Note: Beware of name-conflicts when importing. The `Scene.import_scene` provides the option to add a prefix to names of imported nodes.


    ##Access nodes##

    A list of nodes is maintained as the ._nodes property of a scene. It is advised not to use this directly.

    Obtaining a reference to a single node can be done using its name:

        node = s[&#39;node_name&#39;]

    This is the reason why all node names should be unique. To get a list of all available node names use `Scene.print_node_tree()`

    It is also possible to:

    - Get all nodes of a type, use : `Scene.nodes_of_type()`
    - Get all nodes that depend on a node : `Scene.nodes_depending_on()`
    - Get all child nodes : `Scene.nodes_with_parent()`

    ##Deleting nodes##

    Removing nodes can be tricky due to nodes depending on eachother. For example deleting a poi which is also used a endpoint for a cable will cause problems for that cable.
    The same applies to axis systems with nodes on it (children)

    `Scene.clear` can be used to delete all nodes from a scene.

    To delete a single node there are two options:

    1. `Scene.delete`. This deletes a node from the scene. All nodes that depend on this node will be deleted as well.
    2. `Scene.dissolve`. This &#34;evaporates&#34; the node. Attempts to maintain child nodes. Often used in combination with the containerize option of `Scene.import_scene`

    ##Saving or exporting##

    The standard file-format for saving DAVE scenes and nodes is [vanilla](https://en.wikipedia.org/wiki/Vanilla_software) python.

    The contents of a Scene can be save using `Scene.save_scene`. The python code to re-create the scene can be obtained using `Scene.give_python_code`.

    ##Solving##

    Solving static equilibrium is done using `Scene.solve_statics`. If there is a static equilibrium condition then this function will attempt to find it by changing the non-fixed degrees of freedom of the scene.

    ##Optimalizations##

    A goal-seek function is available: `Scene.goal_seek`.

    ##Resources##

    In the default resource system the resources may be located in any of the folders listed in `Scene.resources_paths`.
    The value of this property is initialized with `DAVE.settings.RESOURCE_PATH`.

    `Scene.get_resource_list` can be used to obtain a list of all available resources. `Scene.get_resource_path` can
    be used to obtain a full path to a resource with a known name.


&#34;&#34;&#34;

&#34;&#34;&#34;
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Ruben de Bruin - 2019
&#34;&#34;&#34;

import pyo3d
import numpy as np
import DAVE.settings as vfc
from DAVE.tools import *
from os.path import isfile, split, dirname, exists
from os import listdir
from pathlib import Path
import datetime


# we are wrapping all methods of pyo3d such that:
# - code-completion is more robust
# - we can do some additional checks. pyo3d is written for speed, not robustness.
# - pyo3d is not a hard dependency
#
# notes and choices:
# - properties are returned as tuple to make sure they are not editable.
#    --&gt; node.position[2] = 5 is not allowed



class Node:
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes&#34;&#34;&#34;

    def __init__(self, scene):
        self._scene = scene
        self._name = &#39;no name&#39;

    def give_python_code(self):
        &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
        return &#34;# No python code generated for element {}&#34;.format(self.name)

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    def _delete_vfc(self):
        pass

class CoreConnectedNode(Node):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes with a connected eqCore element&#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene)
        self._vfNode = vfNode

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._vfNode.name

    @name.setter
    def name(self, name):
        if not name == self._vfNode.name:
            self._scene._verify_name_available(name)
            self._vfNode.name = name

    def _delete_vfc(self):
        self._scene._vfc.delete(self._vfNode.name)

class NodeWithParent(CoreConnectedNode):
    &#34;&#34;&#34;
    NodeWithParent

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;parent&#34; property.
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)
        self._parent = None
        self._None_parent_acceptable = False

    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the node. Should be another axis or None&#34;&#34;&#34;
        if self._vfNode.parent is None:
            return None
        else:
            return self._parent
            # return Axis(self._scene, self._vfNode.parent)

    @parent.setter
    def parent(self, var):
        &#34;&#34;&#34;Assigns a new parent. Keeps the local position and rotations the same

        See also: change_parent_to
        &#34;&#34;&#34;

        if var is None:

            if not self._None_parent_acceptable:
                raise ValueError(&#39;None is not an acceptable parent for {} of {}&#39;.format(self.name, type(self)))

            self._parent = None
            self._vfNode.parent = None
        else:
            if isinstance(var, Axis):
                self._parent = var
                self._vfNode.parent = var._vfNode
            elif isinstance(var, Poi):
                self._parent = var
                self._vfNode.parent = var._vfNode
            else:
                raise Exception(&#39;Parent can only be set to an instance of Axis or Poi, not to a {}&#39;.format(type(var)))

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        try:
            self.rotation
            has_rotation = True
        except:
            has_rotation = False

        try:
            self.position
            has_position = True
        except:
            has_position = False

        # it is possible that this function is called on an object without position/rotation
        # in that case just fall-back to a change of parent
        if not has_position and not has_rotation:
            self.parent = new_parent
            return

        # check new_parent
        if new_parent is not None:

            if not isinstance(new_parent, Axis):
                if not has_rotation:
                    if not isinstance(new_parent, Poi):
                        raise TypeError(
                            &#39;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#39;.format(
                                type(new_parent)))
                else:
                    raise TypeError(
                        &#39;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#39;.format(
                            type(new_parent)))

        glob_pos = self.global_position

        if has_rotation:
            glob_rot = self.global_rotation

        self.parent = new_parent

        if new_parent is None:
            self.position = glob_pos
            if has_rotation:
                self.rotation = glob_rot

        else:
            self.position = new_parent.to_loc_position(glob_pos)
            if has_rotation:
                self.rotation = new_parent.to_loc_direction(glob_rot)


class Visual(Node):
    &#34;&#34;&#34;
    Visual

    .. image:: ./images/visual.png

    A Visual node contains a 3d visual, typically obtained from a .obj file.
    A visual node can be placed on an axis-type node.

    It is used for visualization. It does not affect the forces, dynamics or statics.

    The visual can be given an offset, rotation and scale. These are applied in the following order

    1. rotate
    2. scale
    3. offset

    Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.

    &#34;&#34;&#34;

    def __init__(self, scene):

        # Note: Visual does not have a corresponding vfCore element
        self.scene = scene

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Offset (x,y,z) of the visual. Offset is applied after scaling&#34;&#34;&#34;
        self.rotation = [0, 0, 0]
        &#34;&#34;&#34;Rotation (rx,ry,rz) of the visual&#34;&#34;&#34;

        self.scale = [1,1,1]
        &#34;&#34;&#34;Scaling of the visual. Scaling is applied before offset.&#34;&#34;&#34;

        self.path = &#39;&#39;
        &#34;&#34;&#34;Filename of the visual&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)


        code += &#34;\ns.new_visual(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}), &#34;.format(*self.offset)
        code += &#34;\n            rotation=({}, {}, {}), &#34;.format(*self.rotation)
        code += &#34;\n            scale=({}, {}, {}) )&#34;.format(*self.scale)

        return code

    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)



class Axis(NodeWithParent):
    &#34;&#34;&#34;
    Axis

    Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
    Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
    The possible movements of an axis can be controlled in each degree of freedom using the &#34;fixed&#34; property.

    Notes:
         - circular references are not allowed: It is not allowed to place a on b and b on a

    &#34;&#34;&#34;

    def __init__(self, scene, vfAxis):
        super().__init__(scene, vfAxis)
        self._None_parent_acceptable = True

    @property
    def fixed(self):
        &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
        True means that that degree of freedom will not change when solving statics.
        False means a that is may be changed in order to find equilibrium.

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

        See Also: set_free, set_fixed
        &#34;&#34;&#34;
        return self._vfNode.fixed

    @fixed.setter
    def fixed(self, var):
        if var == True:
            var = (True,True,True,True,True,True)
        if var == False:
            var = (False, False, False, False, False, False)

        self._vfNode.fixed = var

    def set_free(self):
        &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
        self._vfNode.set_free()

    def set_fixed(self):
        &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;
        self._vfNode.set_fixed()

    @property
    def x(self):
        &#34;&#34;&#34;The x-component of the position vector&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    def x(self, var):
        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    def y(self, var):
        a = self.position
        self.position = (a[0], var , a[2])

    @z.setter
    def z(self, var):
        a = self.position
        self.position = (a[0], a[1], var)



    @property
    def position(self):
        &#34;&#34;&#34;Position of the axis (x,y,z)
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    def position(self, var):
        assert3f(var, &#34;Position &#34;)
        self._vfNode.position = var
        self._scene._geometry_changed()

    @property
    def rx(self):
        &#34;&#34;&#34;The x-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[0]

    @property
    def ry(self):
        &#34;&#34;&#34;The y-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[1]

    @property
    def rz(self):
        &#34;&#34;&#34;The z-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[2]

    @rx.setter
    def rx(self, var):
        a = self.rotation
        self.rotation = (var, a[1], a[2])

    @ry.setter
    def ry(self, var):
        a = self.rotation
        self.rotation = (a[0], var , a[2])

    @rz.setter
    def rz(self, var):
        a = self.rotation
        self.rotation = (a[0], a[1], var)

    @property
    def rotation(self):
        &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
        Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.rotation)

    @rotation.setter
    def rotation(self, var):
        # convert to degrees
        assert3f(var, &#34;Rotation &#34;)
        self._vfNode.rotation = np.deg2rad(var)
        self._scene._geometry_changed()

    # we need to over-ride the parent property to be able to call _geometry_changed afterwards
    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;&#34;&#34;&#34;
        return super().parent

    @parent.setter
    def parent(self, val):
        NodeWithParent.parent.fset(self, val)
        self._scene._geometry_changed()

    @property
    def gx(self):
        &#34;&#34;&#34;The x-component of the global position vector&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;The y-component of the global position vector&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;The z-component of the global position vector&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    def gx(self, var):
        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    def gy(self, var):
        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    def gz(self, var):
        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;The global position of the origin.&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    def global_position(self, val):
        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    @property
    def grx(self):
        &#34;&#34;&#34;The x-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[0]

    @property
    def gry(self):
        &#34;&#34;&#34;The y-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[1]

    @property
    def grz(self):
        &#34;&#34;&#34;The z-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[2]

    @grx.setter
    def grx(self, var):
        a = self.global_rotation
        self.global_rotation = (var, a[1], a[2])

    @gry.setter
    def gry(self, var):
        a = self.global_rotation
        self.global_rotation = (a[0], var, a[2])

    @grz.setter
    def grz(self, var):
        a = self.global_rotation
        self.global_rotation = (a[0], a[1], var)

    @property
    def global_rotation(self):
        &#34;&#34;&#34;The rotation of the axis in degrees. Expressed in the global axis system&#34;&#34;&#34;
        return tuple(np.rad2deg(self._vfNode.global_rotation))

    @global_rotation.setter
    def global_rotation(self, val):
        assert3f(val, &#34;Global Rotation&#34;)
        if self.parent:
            self.rotation = self.parent.to_loc_rotation(val)
        else:
            self.rotation = val

    @property
    def global_transform(self):
        &#34;&#34;&#34;Read-only: The global tranform of the axis system.&#34;&#34;&#34;
        return self._vfNode.global_transform

    @property
    def connection_force(self):
        &#34;&#34;&#34;Returns the force and moment that this axis applies on its parent [Parent axis system]&#34;&#34;&#34;
        return self._vfNode.connection_force

    @property
    def connection_force_x(self):
        &#34;&#34;&#34;The x-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[0]

    @property
    def connection_force_y(self):
        &#34;&#34;&#34;The y-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[1]

    @property
    def connection_force_z(self):
        &#34;&#34;&#34;The z-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[2]

    @property
    def connection_moment_x(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[3]

    @property
    def connection_moment_y(self):
        &#34;&#34;&#34;The my-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[4]

    @property
    def connection_moment_z(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[5]

    @property
    def applied_force(self):
        &#34;&#34;&#34;Returns the force and moment that is applied on this axis [Global axis system]
        &#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def equilibrium_error(self):
        &#34;&#34;&#34;Returns the force and moment that remains on this axis (applied-force minus connection force) [Parent axis system]
        &#34;&#34;&#34;
        return self._vfNode.equilibrium_error

    def to_loc_position(self, value):
        &#34;&#34;&#34;Returns the local position of a point in the global axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_loc_direction
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_point(value)

    def to_glob_position(self, value):
        &#34;&#34;&#34;Returns the global position of a point in the local axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_glob_direction
        &#34;&#34;&#34;
        return self._vfNode.local_to_global_point(value)

    def to_loc_direction(self, value):
        &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
        This considers only the rotation of the axis system.
        See Also: to_loc_position
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_vector(value)

    def to_glob_direction(self, value):
        &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
        This considers only the rotation of the axis system.
        See Also: to_glob_position&#34;&#34;&#34;
        return self._vfNode.local_to_global_vector(value)

    def to_loc_rotation(self, value):
        &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
            See Also: to_loc_position, to_loc_direction
             &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))

    def to_glob_rotation(self, value):
        &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
            See Also: to_loc_position, to_loc_direction
             &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        # check new_parent
        if new_parent is not None:
            if not isinstance(new_parent, Axis):
                raise TypeError(
                    &#39;Only None or Axis-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#39;.format(
                    type(new_parent)))

        glob_pos = self.global_position
        glob_rot = self.global_rotation
        self.parent = new_parent
        self.global_position = glob_pos
        self.global_rotation = glob_rot



    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_axis(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n           parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        if self.fixed[0]:
            code += &#34;\n           position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n           position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                     {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                     {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n           rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n           rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                     {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                     {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.rotation[2])

        code += &#34;\n           fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        return code

class Poi(NodeWithParent):
    &#34;&#34;&#34;A location on an axis&#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a poi
    def __init__(self, scene, vfPoi):
        super().__init__(scene, vfPoi)
        self._None_parent_acceptable = True


    @property
    def x(self):
        &#34;&#34;&#34;x component of local position&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;y component of local position&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        return self.position[2]

    @x.setter
    def x(self, var):
        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    def y(self, var):
        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    def z(self, var):
        &#34;&#34;&#34;z component of local position&#34;&#34;&#34;
        a = self.position
        self.position = (a[0], a[1], var)


    @property
    def position(self):
        &#34;&#34;&#34;Local position&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    def position(self, new_position):
        assert3f(new_position)
        self._vfNode.position = new_position

    @property
    def applied_force_and_moment_global(self):
        &#34;&#34;&#34;Returns the applied force in the parent axis system&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def gx(self):
        &#34;&#34;&#34;x component of global position&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;y component of global position&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;z component of global position&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    def gx(self, var):
        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    def gy(self, var):
        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    def gz(self, var):
        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;Global position&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    def global_position(self, val):
        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_poi(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n          parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        code += &#34;\n          position=({},&#34;.format(self.position[0])
        code += &#34;\n                    {},&#34;.format(self.position[1])
        code += &#34;\n                    {}))&#34;.format(self.position[2])

        return code


#
class RigidBody(Axis):
    &#34;&#34;&#34;A Rigid body, internally composed of an axis, a poi (cog) and a force (gravity)&#34;&#34;&#34;

    def __init__(self, scene, axis, poi, force):
        super().__init__(scene, axis)

        # The axis is the Node
        # poi and force are added separately

        self._vfPoi = poi
        self._vfForce = force

    # override the following properties
    # - name : sets the names of poi and force as well

    def _delete_vfc(self):
        super()._delete_vfc()
        self._scene._vfc.delete(self._vfPoi.name)
        self._scene._vfc.delete(self._vfForce.name)

    @property  # can not define a setter without a getter..?
    def name(self):
        return super().name

    @name.setter
    def name(self, newname):
        # super().name = newname
        super(RigidBody, self.__class__).name.fset(self, newname)
        self._vfPoi.name = newname + vfc.VF_NAME_SPLIT + &#34;cog&#34;
        self._vfForce.name = newname + vfc.VF_NAME_SPLIT + &#34;gravity&#34;

    @property
    def cogx(self):
        return self.cog[0]

    @property
    def cogy(self):
        return self.cog[1]

    @property
    def cogz(self):
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Control the cog position of the body&#34;&#34;&#34;
        return self._vfPoi.position

    @cogx.setter
    def cogx(self, var):
        a = self.cog
        self.cog = (var, a[1], a[2])

    @cogy.setter
    def cogy(self, var):
        a = self.cog
        self.cog = (a[0], var, a[2])

    @cogz.setter
    def cogz(self, var):
        a = self.cog
        self.cog = (a[0], a[1], var)

    @cog.setter
    def cog(self, newcog):
        assert3f(newcog)
        self._vfPoi.position = newcog

    @property
    def mass(self):
        &#34;&#34;&#34;Control the static mass of the body&#34;&#34;&#34;
        return self._vfForce.force[2] / -vfc.G

    @mass.setter
    def mass(self, newmass):
        assert1f(newmass)
        self._vfForce.force = (0, 0, -vfc.G * newmass)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_rigidbody(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                mass={},&#34;.format(self.mass)
        code += &#34;\n                cog=({},&#34;.format(self.cog[0])
        code += &#34;\n                     {},&#34;.format(self.cog[1])
        code += &#34;\n                     {}),&#34;.format(self.cog[2])

        if self.parent:
            code += &#34;\n                parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        if self.fixed[0]:
            code += &#34;\n                position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n                position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                          {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                          {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n                rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n                rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                          {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                          {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.rotation[2])

        code += &#34;\n                fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        return code


#

class Cable(CoreConnectedNode):
    &#34;&#34;&#34;A Cable represents a linear elastic wire running from a Poi to another Poi.

    A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.

    Intermediate pois or sheaves may be added.

    - Pois are considered as sheaves with a zero diameter.
    - Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.

    For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
    cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.

    This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.

    Notes:
        If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
        This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.


    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._pois = list()

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the cable in [kN] (Readonly, calculated)&#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def stretch(self):
        &#34;&#34;&#34;Stretch of the cable in [m] (Readonly, calculated)&#34;&#34;&#34;
        return self._vfNode.stretch

    @property
    def length(self):
        &#34;&#34;&#34;Length in rest [m]&#34;&#34;&#34;
        return self._vfNode.Length

    @length.setter
    def length(self, val):
        if val &lt; 1e-9:
            raise Exception(&#39;Length shall be more than 0 (otherwise stiffness EA/L becomes infinite)&#39;)
        self._vfNode.Length = val

    @property
    def EA(self):
        &#34;&#34;&#34;Stiffness of the cable in [kN]&#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    def EA(self, ea):
        self._vfNode.EA = ea

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the cable [m]&#34;&#34;&#34;
        return self._vfNode.diameter

    @diameter.setter
    def diameter(self, diameter):
        self._vfNode.diameter = diameter

    def get_points_for_visual(self):
        &#34;&#34;&#34;Returns an list of 3D locations which can be used for visualization
        &#34;&#34;&#34;
        return self._vfNode.global_points

    def check_endpoints(self):
        &#34;&#34;&#34;Verifies that the endpoints are Pois&#34;&#34;&#34;
        if isinstance(self._pois[0], Sheave):
            raise ValueError(
                &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as start&#39;.format(self.name, self._pois[0].name))

        if isinstance(self._pois[-1], Sheave):
            raise ValueError(
                &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as endpoint&#39;.format(self.name, self._pois[-1].name))



    def _update_pois(self):
        self._vfNode.clear_connections()
        for point in self._pois:

            if isinstance(point, Poi):
                try:
                    self._vfNode.add_connection_poi(point._vfNode)
                except:
                    self._vfNode.add_connection(point._vfNode)
            if isinstance(point, Sheave):
                self._vfNode.add_connection_sheave(point._vfNode)

    def add_connection(self, apoi):
        &#34;&#34;&#34;Adds a poi to the list of connection points&#34;&#34;&#34;

        if isinstance(apoi, str):
            apoi = self._scene[apoi]

        if not (isinstance(apoi, Poi) or isinstance(apoi, Sheave)):
            raise TypeError(&#39;Provided point should be a Poi&#39;)

        if self._pois:  # check for not empty
            if self._pois[-1] == apoi:
                raise Exception(&#39;The same poi can not be added directly after itself: {}&#39;.format(apoi.name))

        self._pois.append(apoi)
        self._update_pois()

    def clear_connections(self):
        &#34;&#34;&#34;Removes all connections&#34;&#34;&#34;
        self._pois.clear()
        self._update_pois()

    def give_poi_names(self):
        &#34;&#34;&#34;Returns a list with the names of all the pois&#34;&#34;&#34;
        r = list()
        for p in self._pois:
            r.append(p.name)
        return r

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        poi_names = self.give_poi_names()
        n_sheaves = len(poi_names)-2

        code += &#34;\ns.new_cable(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            poiA=&#39;{}&#39;,&#34;.format(poi_names[0])
        code += &#34;\n            poiB=&#39;{}&#39;,&#34;.format(poi_names[-1])
        code += &#34;\n            length={},&#34;.format(self.length)

        if self.diameter != 0:
            code += &#34;\n            diameter={},&#34;.format(self.diameter)

        if len(poi_names) &lt;= 2:
            code += &#34;\n            EA={})&#34;.format(self.EA)
        else:
            code += &#34;\n            EA={},&#34;.format(self.EA)

            if n_sheaves == 1:
                code += &#34;\n            sheaves = [&#39;{}&#39;])&#34;.format(poi_names[1])
            else:
                code += &#34;\n            sheaves = [&#39;{}&#39;,&#34;.format(poi_names[1])
                for i in range(n_sheaves-2):
                    code += &#34;\n                       &#39;{}&#39;,&#34;.format(poi_names[2+i])
                code += &#34;\n                       &#39;{}&#39;]),&#34;.format(poi_names[-2])


        return code


class Force(NodeWithParent):
    &#34;&#34;&#34;A Force models a force and moment on a poi.

    Both are expressed in the global axis system.

    &#34;&#34;&#34;

    @property
    def force(self):
        &#34;&#34;&#34;
        Gets or sets the x,y and z force components.

        Example s[&#39;wind&#39;].force = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.force

    @force.setter
    def force(self, val):
        assert3f(val)
        self._vfNode.force = val

    @property
    def moment(self):
        &#34;&#34;&#34;
        Gets or sets the x,y and z moment components.

        Example s[&#39;wind&#39;].moment = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.moment


    @moment.setter
    def moment(self, val):
        assert3f(val)
        self._vfNode.moment = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_force(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            force=({}, {}, {}),&#34;.format(*self.force)
        code += &#34;\n            moment=({}, {}, {}) )&#34;.format(*self.moment)
        return code

class Sheave(NodeWithParent):
    &#34;&#34;&#34;A Sheave models sheave with axis and diameter.


    &#34;&#34;&#34;

    @property
    def axis(self):
        &#34;&#34;&#34;
        Gets or sets direction of the sheave axis
        &#34;&#34;&#34;
        return self._vfNode.axis_direction

    @axis.setter
    def axis(self, val):
        assert3f(val)
        if np.linalg.norm(val) == 0:
            raise ValueError(&#39;Axis can not be 0,0,0&#39;)
        self._vfNode.axis_direction = val

    @property
    def radius(self):
        &#34;&#34;&#34;
        Gets or sets radius of the sheave
        &#34;&#34;&#34;
        return self._vfNode.radius


    @radius.setter
    def radius(self, val):
        assert1f(val)
        self._vfNode.radius = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_sheave(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            axis=({}, {}, {}),&#34;.format(*self.axis)
        code += &#34;\n            radius={} )&#34;.format(self.radius)
        return code


class HydSpring(NodeWithParent):
    &#34;&#34;&#34;A HydSpring models a linearized hydrostatic spring.

    The cob (center of buoyancy) is defined in the parent axis system.
    All other properties are defined relative to the cob.

    &#34;&#34;&#34;

    @property
    def cob(self):
        &#34;&#34;&#34;Center of buoyancy in parent axis system&#34;&#34;&#34;
        return self._vfNode.position

    @cob.setter
    def cob(self, val):
        assert3f(val)
        self._vfNode.position = val

    @property
    def BMT(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for roll&#34;&#34;&#34;
        return self._vfNode.BMT

    @BMT.setter
    def BMT(self, val):
        self._vfNode.BMT = val

    @property
    def BML(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch&#34;&#34;&#34;
        return self._vfNode.BML

    @BML.setter
    def BML(self, val):
        self._vfNode.BML = val

    @property
    def COFX(self):
        &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
        return self._vfNode.COFX

    @COFX.setter
    def COFX(self, val):
        self._vfNode.COFX = val

    @property
    def COFY(self):
        &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
        return self._vfNode.COFY

    @COFY.setter
    def COFY(self, val):
        self._vfNode.COFY = val

    @property
    def kHeave(self):
        &#34;&#34;&#34;Heave stiffness in kN/m&#34;&#34;&#34;
        return self._vfNode.kHeave

    @kHeave.setter
    def kHeave(self, val):
        self._vfNode.kHeave = val

    @property
    def waterline(self):
        &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is)&#34;&#34;&#34;
        return self._vfNode.waterline

    @waterline.setter
    def waterline(self, val):
        self._vfNode.waterline = val

    @property
    def displacement_kN(self):
        &#34;&#34;&#34;Displacement in [kN] when waterline is at waterline-elevation&#34;&#34;&#34;
        return self._vfNode.displacement_kN

    @displacement_kN.setter
    def displacement_kN(self, val):
        self._vfNode.displacement_kN = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_hydspring(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            cob=({}, {}, {}),&#34;.format(*self.cob)
        code += &#34;\n            BMT={},&#34;.format(self.BMT)
        code += &#34;\n            BML={},&#34;.format(self.BML)
        code += &#34;\n            COFX={},&#34;.format(self.COFX)
        code += &#34;\n            COFY={},&#34;.format(self.COFY)
        code += &#34;\n            kHeave={},&#34;.format(self.kHeave)
        code += &#34;\n            waterline={},&#34;.format(self.waterline)
        code += &#34;\n            displacement_kN={} )&#34;.format(self.displacement_kN)

        return code

class LC6d(CoreConnectedNode):
    &#34;&#34;&#34;A LC6d models a Linear Connector with 6 dofs.

    It connects two Axis elements with six linear springs.
    The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:

      - rotation_x = arc-tan ( uy[0] / uy[1] )
      - rotation_y = arc-tan ( -ux[0] / ux[2] )
      - rotation_z = arc-tan ( ux[0] / ux [1] )

    which works fine for small rotations and rotations about only a single axis.

    Try to avoid using very high stiffness settings to create fixed connections. It is better to use use the &#34;fixed&#34;
    property of axis systems to create joints.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def stiffness(self):
        &#34;&#34;&#34;Stiffness of the connector (kx, ky, kz, krx, kry, krz)&#34;&#34;&#34;
        return self._vfNode.stiffness

    @stiffness.setter
    def stiffness(self, val):
        self._vfNode.stiffness = val

    @property
    def master(self):
        &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
        return self._master

    @master.setter
    def master(self,val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode


    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)


        code += &#34;\ns.new_linear_connector_6d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            stiffness=({}, {}, {}, &#34;.format(*self.stiffness[:3])
        code += &#34;\n                       {}, {}, {}) )&#34;.format(*self.stiffness[3:])

        return code


class Connector2d(CoreConnectedNode):
    &#34;&#34;&#34;A Connector2d linear connector with acts both on linear displacement and angular displacement.

    * the linear stiffness is defined by k_linear and is defined over the actual shortest direction between master and slave.
    * the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def angle(self):
        &#34;&#34;&#34;Actual angle between master and slave [deg] (read-only)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.angle)

    @property
    def force(self):
        &#34;&#34;&#34;Actual force between master and slave [kN] (read-only)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def moment(self):
        &#34;&#34;&#34;Actual moment between master and slave [kN*m] (read-only)&#34;&#34;&#34;
        return self._vfNode.moment

    @property
    def axis(self):
        &#34;&#34;&#34;Actual rotation axis between master and slave (read-only)&#34;&#34;&#34;
        return self._vfNode.axis

    @property
    def k_linear(self):
        &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.k_linear

    @k_linear.setter
    def k_linear(self, value):
        self._vfNode.k_linear = value

    @property
    def k_angular(self):
        &#34;&#34;&#34;Linear stiffness [kN*m/rad]&#34;&#34;&#34;
        return self._vfNode.k_angular

    @k_angular.setter
    def k_angular(self, value):
        self._vfNode.k_angular = value

    @property
    def master(self):
        &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
        return self._master

    @master.setter
    def master(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_connector2d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            k_linear ={},&#34;.format(self.k_linear)
        code += &#34;\n            k_angular ={})&#34;.format(self.k_angular)

        return code


class LinearBeam(CoreConnectedNode):
    &#34;&#34;&#34;A LinearBeam models a FEM-like linear beam element.

    A LinearBeam node connects two Axis elements with six linear springs.

    By definition the beam runs in the X-direction of the master axis system. So it may be needed to create a
    dedicated Axis element for the beam to control the orientation.

    The beam is defined using the following properties:

    *  EIy  - bending stiffness about y-axis
    *  EIz  - bending stiffness about z-axis
    *  GIp  - torsional stiffness about x-axis
    *  EA   - axis stiffness in x-direction
    *  L    - the un-stretched length of the beam

    The beam element is in rest if the slave axis system

    1. has the same global orientation as the master system
    2. is at global position equal to the global position of local point (L,0,0) of the master axis. (aka: the end of the beam)


    The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
    is determined as follows:

    First the direction from master to slave is determined: D
    The axis of rotation is the cross-product of the unit x-axis and D    AXIS = ux x D
    The angle of rotation is the angle between the master x-axis and D

    The rotation about the rotated X-axis is undefined.
    
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def EIy(self):
        return self._vfNode.EIy
    @EIy.setter
    def EIy(self,value):
        self._vfNode.EIy = value

    @property
    def EIz(self):
        return self._vfNode.EIz

    @EIz.setter
    def EIz(self, value):
        self._vfNode.EIz = value

    @property
    def GIp(self):
        return self._vfNode.GIp

    @GIp.setter
    def GIp(self, value):
        self._vfNode.GIp = value

    @property
    def EA(self):
        return self._vfNode.EA

    @EA.setter
    def EA(self, value):
        self._vfNode.EA = value

    @property
    def master(self):
        return self._master

    @property
    def L(self):
        return self._vfNode.L

    @L.setter
    def L(self, value):
        self._vfNode.L = value

    @master.setter
    def master(self,val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode


    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_linearbeam(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            EIy ={},&#34;.format(self.EIy)
        code += &#34;\n            EIz ={},&#34;.format(self.EIz)
        code += &#34;\n            GIp ={},&#34;.format(self.GIp)
        code += &#34;\n            EA ={},&#34;.format(self.EA)
        code += &#34;\n            L ={}) # L can possibly be omitted&#34;.format(self.L)

        return code


class TriMeshSource(Node):
    &#34;&#34;&#34;
    TriMesh

    A TriMesh node contains triangular mesh which can be used for buoyancy or contact

    &#34;&#34;&#34;

    def __init__(self, scene, source):

        # Note: Visual does not have a corresponding vfCore Node in the scene but does have a vfCore
        self.scene = scene
        self._TriMesh = source
        self._new_mesh = True             # cheat for visuals

        self._path = &#39;&#39;                   # stores the data that was used to load the obj
        self._offset = (0,0,0)
        self._scale = (1,1,1)
        self._rotation = (0,0,0)

    def AddVertex(self, x,y,z):
        self._TriMesh.AddVertex(x,y,z)

    def AddFace(self, i,j,k):
        self._TriMesh.AddFace(i,j,k)

    def get_extends(self):
        &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

        Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

        &#34;&#34;&#34;

        t = self._TriMesh

        if t.nFaces == 0:
            return (0,0,0,0)

        v = t.GetVertex(0)
        xn = v[0]
        xp = v[0]
        yn = v[1]
        yp = v[1]
        zn = v[2]
        zp = v[2]

        for i in range(t.nVertices):
            v = t.GetVertex(i)
            x = v[0]
            y= v[1]
            z = v[2]

            if x&lt;xn:
                xn = x
            if x&gt;xp:
                xp = x
            if y &lt; yn:
                yn = y
            if y &gt; yp:
                yp = y
            if z &lt; zn:
                zn = z
            if z &gt; zp:
                zp = z

        return (xn,xp,yn,yp,zn, zp)





    def make_cube(self):
        &#34;&#34;&#34;Sets the mesh to a cube&#34;&#34;&#34;

        from vtk import vtkCubeSource
        cube = vtkCubeSource()
        self.load_vtk_polydataSource(cube)

    def _fromVTKpolydata(self,polydata, offset = None, rotation = None, scale = None):

        import vtk

        tri = vtk.vtkTriangleFilter()

        tri.SetInputConnection(polydata)


        scaleFilter = vtk.vtkTransformPolyDataFilter()
        rotationFilter = vtk.vtkTransformPolyDataFilter()

        s = vtk.vtkTransform()
        s.Identity()
        r = vtk.vtkTransform()
        r.Identity()

        scaleFilter.SetInputConnection(tri.GetOutputPort())
        rotationFilter.SetInputConnection(scaleFilter.GetOutputPort())

        if scale is not None:
            s.Scale(*scale)

        if rotation is not None:
            q = rotation
            angle = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2) ** (0.5)
            if angle &gt; 0:
                r.RotateWXYZ(angle, q[0] / angle, q[1] / angle, q[2] / angle)

        if offset is None:
            offset = [0,0,0]

        scaleFilter.SetTransform(s)
        rotationFilter.SetTransform(r)
        rotationFilter.Update()

        data = rotationFilter.GetOutput()
        self._TriMesh.Clear()

        for i in range(data.GetNumberOfPoints()):
            point = data.GetPoint(i)
            self._TriMesh.AddVertex(point[0] + offset[0], point[1] + offset[1], point[2] + offset[2])

        for i in range(data.GetNumberOfCells()):
            cell = data.GetCell(i)

            if isinstance(cell,vtk.vtkLine):
                print(&#34;Cell nr {} is a line, not adding to mesh&#34;.format(i))
                continue

            id0 = cell.GetPointId(0)
            id1 = cell.GetPointId(1)
            id2 = cell.GetPointId(2)
            self._TriMesh.AddFace(id0, id1, id2)

        # check if anything was loaded
        if self._TriMesh.nFaces == 0:
            raise Exception(&#39;No faces in poly-data - no geometry added (hint: empty obj file?)&#39;)
        self._new_mesh = True

    def load_vtk_polydataSource(self, polydata):
        &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

        The vtk TriangleFilter is used to triangulate the source

        Examples:
            cube = vtk.vtkCubeSource()
            cube.SetXLength(122)
            cube.SetYLength(38)
            cube.SetZLength(10)
            trimesh.load_vtk_polydataSource(cube)
        &#34;&#34;&#34;

        self._fromVTKpolydata(polydata.GetOutputPort())


    def load_obj(self, filename, offset = None, rotation = None, scale = None):
        &#34;&#34;&#34;Loads an .obj file and and triangulates it.

        Order of modifications:

        1. rotate
        2. scale
        3. offset

        Args:
            filename: (str or path): file to load
            offset: : offset
            rotation:  : rotation
            scale:  scale

        &#34;&#34;&#34;
        if not exists(filename):
            raise ValueError(&#39;File {} does not exit&#39;.format(filename))

        filename = str(filename)

        import vtk
        obj = vtk.vtkOBJReader()
        obj.SetFileName(filename)

        # Add cleaning
        cln = vtk.vtkCleanPolyData()
        cln.SetInputConnection(obj.GetOutputPort())

        self._fromVTKpolydata(cln.GetOutputPort(), offset=offset, rotation=rotation, scale=scale)

        self._path = split(filename)[1]
        self._scale = scale
        self._offset = offset
        self._rotation = rotation

        if self._scale is None:
            self._scale = (1.0, 1.0, 1.0)
        if self._offset is None:
            self._offset = (0.0, 0.0, 0.0)
        if self._rotation is None:
            self._rotation = (0.0, 0.0, 0.0)

    def give_python_code(self):
        code = &#34;# No code generated for TriMeshSource&#34;
        return code

    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)





class Buoyancy(NodeWithParent):
    &#34;&#34;&#34;Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
    The calculation of buoyancy is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point towards to water.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a buoyancy
    def __init__(self, scene, vfBuoyancy):
        super().__init__(scene, vfBuoyancy)
        self._None_parent_acceptable = True
        self._trimesh = TriMeshSource(self._scene, self._vfNode.trimesh) # the tri-mesh is wrapped in a custom object

    @property
    def trimesh(self):
        return self._trimesh

    @property
    def cob(self):
        &#34;&#34;&#34;Returns the GLOBAL position of the center of buoyancy

        To convert to local coordinates use the .to_loc_position() function of the parent.

        &#34;&#34;&#34;
        return self._vfNode.cob

    @property
    def displacement(self):
        &#34;&#34;&#34;Returns displaced volume in m^3&#34;&#34;&#34;
        return self._vfNode.displacement

    # @trimesh.setter
    # def trimesh(self, new_mesh):
    #     raise Exception()
    #     if isinstance(new_mesh, TriMeshSource):
    #         self._vfNode.trimesh = new_mesh._TriMesh
    #         self._trimesh = new_mesh
    #     else:
    #         raise TypeError(&#39;new_mesh should be a TriMeshSource object but is a {}&#39;.format(type(new_mesh)))

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_buoyancy(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent.name)
        code += &#34;\nmesh.trimesh.load_obj(s.get_resource_path(r&#39;{}&#39;), scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(self.trimesh._path, *self.trimesh._scale, *self.trimesh._rotation, *self.trimesh._offset)

        return code



class Scene:
    &#34;&#34;&#34;
    A Scene is the main component of virtual-float.

    It provides a world to place nodes (elements) in.
    It interfaces with the virtual-float core for all calculations.

    _vfc : DAVE Core
    &#34;&#34;&#34;

    def __init__(self, filename = None, copy_from = None):
        &#34;&#34;&#34;Creates a new Scene

        Args:
            filename: (str or Path) Insert contents from this file into the newly created scene
            copy_from:  (Scene) Copy nodes from this other scene into the newly created scene
        &#34;&#34;&#34;

        self.verbose = True
        &#34;&#34;&#34;Report actions using print()&#34;&#34;&#34;

        self._vfc = pyo3d.Scene()
        &#34;&#34;&#34;_vfc : DAVE Core, where the actual magic happens&#34;&#34;&#34;

        self._nodes = []
        &#34;&#34;&#34;Contains a list of all nodes in the scene&#34;&#34;&#34;

        self.static_tolerance = 0.01
        &#34;&#34;&#34;Desired tolerance when solving statics&#34;&#34;&#34;

        self.resources_paths = []
        &#34;&#34;&#34;A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.&#34;&#34;&#34;
        self.resources_paths.extend(vfc.RESOURCE_PATH)


        self._name_prefix = &#34;&#34;
        &#34;&#34;&#34;An optional prefix to be applied to node names. Used when importing scenes.&#34;&#34;&#34;

        if filename is not None:
            self.load_scene(filename)

        if copy_from is not None:
            self.import_scene(copy_from, containerize=False)

    def clear(self):
        &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

        self._nodes = []
        del self._vfc
        self._vfc = pyo3d.Scene()


    # =========== private functions =============
    def _print(self,what):
        if self.verbose:
            print(what)

    def _prefix_name(self, name):
        return self._name_prefix + name

    def _verify_name_available(self, name):
        &#34;&#34;&#34;Throws an error if a node with name &#39;name&#39; already exists&#34;&#34;&#34;
        if name in self._vfc.names:
            raise Exception(&#34;The name &#39;{}&#39; is already in use. Pick a unique name&#34;.format(name))

    def _node_from_node_or_str(self, node):
        &#34;&#34;&#34;If node is a string, then returns the node with that name,
        if node is a node, then returns that node

        Raises:
            ValueError if a string is passed with an non-existing node
        &#34;&#34;&#34;

        if isinstance(node, Node):
            return node
        if isinstance(node, str):
            return self[node]
        raise ValueError(&#39;Node should be a Node or a string, not a {}&#39;.format(type(node)))

    def _node_from_node(self, node, reqtype):
        &#34;&#34;&#34;Gets a node from the specified type

        Returns None if node is None
        Returns node if node is already a reqtype type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        if node is None:
            return None

        # node is a string then get the node with this name
        if type(node) == str:
            node = self[self._name_prefix + node]

        reqtype = make_iterable(reqtype)

        for r in reqtype:
            if isinstance(node, r):
                return node

        if issubclass(type(node), Node):
            raise Exception(
                &#34;Element with name {} can not be used , it should be a {} or derived type but is a {}.&#34;.format(
                    node.name, reqtype, type(node)))

        raise Exception(&#39;This is not an acceptable input argument {}&#39;.format(node))

    def _parent_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an axis type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        return self._node_from_node(node, Axis)

    def _poi_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Poi)

    def _poi_or_sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, [Poi, Sheave])

    def _geometry_changed(self):
        &#34;&#34;&#34;Notify the scene that the geometry has changed and that the global transforms are invalid&#34;&#34;&#34;
        self._vfc.geometry_changed()

    # ======== resources =========

    def get_resource_path(self, name):
        &#34;&#34;&#34;Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
        that is found.
        If name is a full path to an existing file, then that is returned.

        See Also:
            resource_paths


        Returns:
            Full path to resource

        Raises:
            FileExistsError if resource is not found

        &#34;&#34;&#34;

        if isfile(name):
            return name

        for res in self.resources_paths:
            p = Path(res)

            full = p / name
            if isfile(full):
                return full

        # prepare feedback for error
        ext = str(name).split(&#39;.&#39;)[-1]  # everything after the last .

        print(&#34;The following resources with extension {} are available with &#34;.format(ext))
        available = self.get_resource_list(ext)
        for a in available:
            print(a)

        raise FileExistsError(&#39;Resource &#34;{}&#34; not found in resource paths&#39;.format(name))

    def get_resource_list(self, extension):
        &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

        r = []

        for dir in self.resources_paths:
            try:
                files = listdir(dir)
                for file in files:
                    if file.endswith(extension):
                        if file not in r:
                            r.append(file)
            except FileNotFoundError:
                pass

        return r



    # ======== element functions =========

    def node_by_name(self, node_name):
        for N in self._nodes:
            if N.name == node_name:
                return N

        self.print_node_tree()
        raise ValueError(&#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name))

    def __getitem__(self, node_name):
        &#34;&#34;&#34;Returns a node with name&#34;&#34;&#34;
        return self.node_by_name(node_name)

    def nodes_of_type(self, node_class):
        &#34;&#34;&#34;Returns all nodes of the specified type

        Examples:
            pois = scene.nodes_of_type(DAVE.Poi)
        &#34;&#34;&#34;
        r = list()
        for n in self._nodes:
            if isinstance(n, node_class):
                r.append(n)
        return r

    def sort_nodes_by_dependency(self):
        &#34;&#34;&#34;Sorts the nodes such that a node only depends on nodes earlier in the list.&#34;&#34;&#34;

        self._vfc.state_update()  # use the function from the core.
        new_list = []
        for name in self._vfc.names:  # and then build a new list using the names
            if vfc.VF_NAME_SPLIT in name:
                continue
            new_list.append(self[name])

        # and add the nodes without a vfc-core connection
        for node in self._nodes:
            if not node in new_list:
                new_list.append(node)

        self._nodes = new_list

    def name_available(self, name):
        &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        return not (name in names)

    def available_name_like(self, like):
        &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
        if self.name_available(like):
            return like
        counter = 1
        while True:
            name = like + &#39;_&#39; + str(counter)
            if self.name_available(name):
                return name
            counter += 1

    def nodes_depending_on(self, node):
        &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
        This function should be used to determine dependencies of Core-connected elements.

        For making node-trees please use nodes_with_parent instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_with_parent
        &#34;&#34;&#34;

        if isinstance(node, Node):
            node = node.name

        # check the node type
        _node = self[node]
        if not isinstance(_node, CoreConnectedNode):
            return []
        else:
            names =  self._vfc.elements_depending_on(node)

        r = []
        for name in names:
            try:
                r.append(self[name].name)
            except:
                pass

        # check visuals as well (which are not core-connected)
        for v in self.nodes_of_type(Visual):
            if v.parent is _node:
                r.append(v.name)

        return r

    def nodes_with_parent(self, node):
        &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
        For checking physical connections use nodes_depending_on instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_depending_on
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        r = []

        for n in self._nodes:

            try:
                parent = n.parent
            except AttributeError:
                continue

            if parent == node:
                r.append(n.name)

        return r



    def delete(self, node):
        &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

        See Also:
            dissolve
        &#34;&#34;&#34;

        depending_nodes = self.nodes_depending_on(node)

        if isinstance(node, str):
            node = self[node]

        self._print(&#39;Deleting {} [{}]&#39;.format(node.name, str(type(node)).split(&#39;.&#39;)[-1][:-2]))

        # remove the vtk node
        self._print(&#39;removing vfc node&#39;)
        node._delete_vfc()
        self._nodes.remove(node)

        # then delete the dependencies

        for d in depending_nodes:
            if not self.name_available(d):  # element is still here
                self.delete(d)


    def dissolve(self, node):
        &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

        1. Look for nodes that have this node as parent
        2. Attach those nodes to the parent of this node.
        3. Delete this node.

        There are many situations in which this will fail because an it is impossible to dissolve
        the element. For example a poi can only be dissolved when nothing is attached to it.

        For now this function only works on AXIS

        &#34;&#34;&#34;

        if isinstance(node, str):
            node=  self[node]

        if not type(node) == Axis:
            raise TypeError(&#39;Only nodes of type Axis can be dissolved at this moment&#39;)

        for d in self.nodes_depending_on(node):
            self[d].change_parent_to(node.parent)

        self.delete(node)



    # ========= The most important function ========

    def solve_statics(self, silent=False):
        &#34;&#34;&#34;Solves statics

        Args:
            silent: Do not print if successfully solved

        Returns:
            bool: True if successful, False otherwise.

        &#34;&#34;&#34;
        succes = self._vfc.state_solve_statics()

        if self.verify_equilibrium():
            if not silent:
                self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
            return True

        d = np.array(self._vfc.get_dofs())
        if np.any(np.abs(d)&gt;2000):
            print(&#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;)
            return False

        return False

    def verify_equilibrium(self, tol = 1e-2):
        &#34;&#34;&#34;Checks if the current state is an equilibrium

        Returns:
            bool: True if successful, False if not an equilibrium.

        &#34;&#34;&#34;
        return (self._vfc.Emaxabs &lt; tol)



    # ====== goal seek ========

    def goal_seek(self, set_node, set_property, target, change_node, change_property, bracket=None, tol=1e-3):
        &#34;&#34;&#34;goal_seek

        Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
        some property of some node to a specified value. Just like excel.

        Args:
            set_node (Node or str):     node to be evaluated
            set_property (str): property of that node to be evaluated
            target (number):       target value for that property
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            range(optional)  : specify the possible search-interval

        Returns:
            bool: True if successful, False otherwise.

        Examples:
            Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
            &gt;&gt;&gt; s.goal_seek(&#39;Barge&#39;,&#39;rx&#39;,0,&#39;Barge&#39;,&#39;cogy&#39;)

        &#34;&#34;&#34;

        set_node = self._node_from_node_or_str(set_node)
        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = getattr(set_node, set_property)
        self._print(&#39;Attempting to set {}.{} to {} (now {})&#39;.format(set_node.name, set_property, target, test))

        initial = getattr(change_node, change_property)
        self._print(&#39;By changing the value of {}.{} (now {})&#39;.format(change_node.name, change_property, initial))

        def set_and_get(x):
            setattr(change_node, change_property,x)
            self.solve_statics(silent=True)
            result = getattr(set_node, set_property)
            self._print(&#39;setting {} results in {}&#39;.format(x,result))
            return result-target

        from scipy.optimize import root_scalar
        x0 = initial
        x1 = initial+0.0001

        if bracket is not None:
            res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket,xtol = tol)
        else:
            res = root_scalar(set_and_get, x0=x0, x1=x1,xtol = tol)

        self._print(res)

        # evaluate result
        final_value = getattr(set_node, set_property)
        if abs(final_value-target) &gt; 1e-3:
            raise ValueError(&#34;Target not reached. Target was {}, reached value is {}&#34;.format(target, final_value))


        return True




    # ======== create functions =========

    def new_axis(self, name, parent=None, position=None, rotation=None, fixed = True):
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Returns:
            Reference to newly created axis

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)



        # then create
        a = self._vfc.new_axis(name)

        new_node = Axis(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position
        if rotation is not None:
            new_node.rotation = rotation

        if isinstance(fixed, bool):
            if fixed:
                new_node.set_fixed()
            else:
                new_node.set_free()
        else:
            new_node.fixed = fixed


        self._nodes.append(new_node)
        return new_node

    def new_visual(self, name, path, parent=None, offset=None, rotation=None, scale = None):
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the resource
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            scale : optional, scale of the visual (x,y,z).

        Returns:
            Reference to newly created visual

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        self.get_resource_path(path) # raises error when resource is not found


        # then create

        new_node = Visual(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        if b is not None:
            new_node.parent = b
        if offset is not None:
            new_node.offset = offset
        if rotation is not None:
            new_node.rotation = rotation
        if scale is not None:
            new_node.scale = scale

        self._nodes.append(new_node)
        return new_node


    def new_poi(self, name, parent=None, position=None):
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)


        Returns:
            Reference to newly created poi

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)

        # then create
        a = self._vfc.new_poi(name)

        new_node = Poi(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position

        self._nodes.append(new_node)
        return new_node

    def new_rigidbody(self, name, mass=0, cog=(0, 0, 0),
                      parent=None, position=None, rotation=None, fixed = True ):
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            mass: optional, [0] mass in mT
            cog: optional, (0,0,0) cog-position in (m,m,m)
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Examples:
            scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

        Returns:
            Reference to newly created RigidBody

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)


        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a
        p.position = cog

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p
        g.force = (0, 0, -vfc.G * mass)

        r = RigidBody(self, a, p, g)

        # and set properties
        if b is not None:
            r.parent = b
        if position is not None:
            r.position = position
        if rotation is not None:
            r.rotation = rotation

        if isinstance(fixed, bool):
            if fixed:
                r.set_fixed()
            else:
                r.set_free()
        else:
            r.fixed = fixed

        self._nodes.append(r)
        return r

    def new_cable(self, name, poiA, poiB, length=-1, EA=0, diameter=0, sheaves=None):
        &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            poiA : A Poi element to connect the first end of the cable to
            poiB : A Poi element to connect the other end of the cable to
            length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
            EA [0] : stiffness of the cable in kN/m; default

            sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from poiA to poiB

        Examples:

            scene.new_cable(&#39;cable_name&#39; poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;)  # minimal use

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=poi_start, poiB = poi_end, sheaves=[sheave1, sheave2])

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

        Notes:
            The default options for length and EA can be used to measure distances between points

        Returns:
            Reference to newly created Cable

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        assert1f(length, &#39;length&#39;)
        assert1f(EA, &#39;EA&#39;)

        poiA = self._poi_from_node(poiA)
        poiB = self._poi_from_node(poiB)

        pois = [poiA]
        if sheaves is not None:

            if isinstance(sheaves, Poi): # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, Sheave): # single sheave as poi or string
                sheaves = [sheaves]


            if isinstance(sheaves, str):
                sheaves = [sheaves]


            for s in sheaves:
                # s may be a poi or a sheave
                pois.append(self._poi_or_sheave_from_node(s))


        pois.append(poiB)

        # default options
        if length == -1:
            length = np.linalg.norm(np.array(poiA.global_position) - np.array(poiB.global_position))

            if length&lt;1e-9:
                raise Exception(&#39;Length not provided and endpoints are at the same global position. Can not determine a suitable default length (&gt;0)&#39;)



        # more checks
        if length&lt;1e-9:
            raise Exception(&#39;Length should be more than 0&#39;)

        if EA&lt;0:
            raise Exception(&#39;EA should be more than 0&#39;)

        assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

        if diameter&lt;0:
            raise Exception(&#34;Diameter should be &gt;= 0&#34;)

        # then create
        a = self._vfc.new_cable(name)
        new_node = Cable(self, a)
        new_node.length = length
        new_node.EA = EA
        new_node.diameter = diameter

        for poi in pois:
            new_node.add_connection(poi)

        # and add to the scene
        self._nodes.append(new_node)
        return new_node

    def new_force(self, name, parent=None, force=None, moment=None):
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        if force is not None:
            assert3f(force, &#34;Force &#34;)

        if moment is not None:
            assert3f(moment, &#34;Moment &#34;)


        # then create
        a = self._vfc.new_force(name)

        new_node = Force(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if force is not None:
            new_node.force = force
        if moment is not None:
            new_node.moment = moment

        self._nodes.append(new_node)
        return new_node

    def new_sheave(self, name, parent, axis, radius=0):
        &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            axis: direction of the axis of rotation (x,y,z)
            radius: optional, radius of the sheave


        Returns:
            Reference to newly created sheave

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert3f(axis, &#34;Axis of rotation &#34;)

        assert1f(radius, &#34;Radius of sheave&#34;)

        # then create
        a = self._vfc.new_sheave(name)

        new_node = Sheave(self, a)

        # and set properties
        new_node.parent = b
        new_node.axis = axis
        new_node.radius = radius

        self._nodes.append(new_node)
        return new_node

    def new_hydspring(self, name, parent, cob,
                      BMT, BML, COFX, COFY, kHeave, waterline, displacement_kN):
        &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            cob: position of the CoB (x,y,z) in the parent axis system
            BMT: Vertical distance between CoB and meta-center for roll
            BML: Vertical distance between CoB and meta-center for pitch
            COFX: X-location of center of flotation (center of waterplane) relative to CoB
            COFY: Y-location of center of flotation (center of waterplane) relative to CoB
            kHeave : heave stiffness (typically Awl * rho * g)
            waterline : Z-position (elevation) of the waterline relative to CoB
            displacement_kN : displacement (typically volume * rho * g)


        Returns:
            Reference to newly created hydrostatic spring

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)
        assert3f(cob, &#34;CoB &#34;)
        assert1f(BMT, &#34;BMT &#34;)
        assert1f(BML, &#34;BML &#34;)
        assert1f(COFX, &#34;COFX &#34;)
        assert1f(COFY, &#34;COFY &#34;)
        assert1f(kHeave, &#34;kHeave &#34;)
        assert1f(waterline, &#34;waterline &#34;)
        assert1f(displacement_kN, &#34;displacement_kN &#34;)

        # then create
        a = self._vfc.new_hydspring(name)
        new_node = HydSpring(self, a)

        new_node.cob = cob
        new_node.parent = b
        new_node.BMT = BMT
        new_node.BML = BML
        new_node.COFX = COFX
        new_node.COFY = COFY
        new_node.kHeave = kHeave
        new_node.waterline = waterline
        new_node.displacement_kN = displacement_kN

        self._nodes.append(new_node)

        return new_node

    def new_linear_connector_6d(self, name, slave, master, stiffness = None):
        &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]
            stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

        See :py:class:`LC6d` for details

        Returns:
            Reference to newly created connector

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        if stiffness is not None:
            assert6f(stiffness, &#34;Stiffness &#34;)
        else:
            stiffness = (0,0,0,0,0,0)

        # then create
        a = self._vfc.new_linearconnector6d(name)

        new_node = LC6d(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.stiffness = stiffness

        self._nodes.append(new_node)
        return new_node

    def new_connector2d(self, name, master, slave, k_linear=0, k_angular=0):
        &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]

            k_linear : linear stiffness in kN/m
            k_angular : angular stiffness in kN*m / rad

        Returns:
            Reference to newly created connector2d

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        assert1f(k_linear, &#34;Linear stiffness&#34;)
        assert1f(k_angular, &#34;Angular stiffness&#34;)

        # then create
        a = self._vfc.new_connector2d(name)

        new_node = Connector2d(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.k_linear = k_linear
        new_node.k_angular = k_angular

        self._nodes.append(new_node)
        return new_node

    def new_linear_beam(self, name, master, slave, EIy=0, EIz=0, GIp=0, EA=0, L=None):
        &#34;&#34;&#34;Creates a new *linear beam* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]

            All stiffness terms default to 0
            The length defaults to the distance between master and slave


        See :py:class:`LinearBeam` for details

        Returns:
            Reference to newly created beam

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        if L is None:
            L = np.linalg.norm(np.array(m.global_position)- np.array(s.global_position))
        else:
            if L &lt;= 0:
                raise ValueError(&#39;L should be &gt; 0 as stiffness is defined per length.&#39;)


        # then create
        a = self._vfc.new_linearbeam(name)

        new_node = LinearBeam(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.EIy = EIy
        new_node.EIz = EIz
        new_node.GIp = GIp
        new_node.EA = EA
        new_node.L = L

        self._nodes.append(new_node)
        return new_node


    def new_buoyancy(self, name, parent=None):
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            trimesh: optional, TriMesh object


        Returns:
            Reference to newly created buoyancy

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        # then create
        a = self._vfc.new_buoyancy(name)
        new_node = Buoyancy(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        self._nodes.append(new_node)
        return new_node

    def print_python_code(self):
        &#34;&#34;&#34;Prints the python code that generates the current scene

        See also: give_python_code
        &#34;&#34;&#34;
        for line in self.give_python_code().split(&#39;\n&#39;):
            print(line)

    def give_python_code(self):
        &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

        import datetime
        import getpass

        self.sort_nodes_by_dependency()

        code = &#34;# auto generated pyhton code&#34;
        try:
            code += &#34;\n# By {}&#34;.format(getpass.getuser())
        except:
            code += &#34;\n# By an unknown&#34;

        code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#39;.&#39;)[0])

        code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
        code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
        code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
        code += &#34;\ndef solved(number):\n    return number\n&#34;

        for n in self._nodes:
            code += &#39;\n&#39; + n.give_python_code()

        return code

    def save_scene(self, filename):
        &#34;&#34;&#34;Saves the scene to a file

        This saves the scene in its current state to a file.
        Opening the saved file will reproduce exactly this scene.

        This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
        This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
        So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
        the results of that update will not be reflected in the saved model.

        If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

        Args:
            filename : filename or file-path to save the file. Default extension is .dave_asset

        Returns:
            the full path to the saved file

        &#34;&#34;&#34;

        code = self.give_python_code()

        filename = Path(filename)

        # add .dave_asset extension
        if filename.suffix != &#39;.dave_asset&#39;:
            filename = Path(str(filename) + &#39;.dave_asset&#39;)

        # add path if not provided
        if not filename.is_absolute():
            try:
                filename = Path(self.resources_paths[-1]) / filename
            except:
                pass # save in current folder

        # make sure directory exists
        directory = filename.parent
        if not directory.exists():
            directory.mkdir()


        f = open(filename,&#39;w+&#39;)
        f.write(code)
        f.close()

        self._print(&#39;Saved as {}&#39;.format(filename))

        return filename

    def print_node_tree(self):

        self.sort_nodes_by_dependency()

        to_be_printed = []
        for n in self._nodes:
            to_be_printed.append(n.name)

        # to_be_printed.reverse()

        def print_deps(name, spaces):

            node = self[name]
            deps = self.nodes_with_parent(node)
            print(spaces + name + &#39; [&#39; + str(type(node)).split(&#39;.&#39;)[-1][:-2] + &#39;]&#39;)

            if deps is not None:
                for dep in deps:
                    if spaces == &#34;&#34;:
                        spaces_plus = &#39; |-&gt; &#39;
                    else:
                        spaces_plus = &#39; |   &#39; + spaces
                    print_deps(dep, spaces_plus)

            to_be_printed.remove(name)

        while to_be_printed:
            name = to_be_printed[0]
            print_deps(name, &#39;&#39;)

    def load_scene(self, filename = None):
        &#34;&#34;&#34;Loads the contents of filename into the current scene.

        This function is typically used on an empty scene.

        Filename is appended with .dave_asset if needed.
        File is searched for in the resource-paths.

        See also: import scene&#34;&#34;&#34;

        if filename is None:
            raise Exception(&#39;Please provide a file-name&#39;)

        filename = Path(filename)

        if filename.suffix != &#39;.dave_asset&#39;:
            filename = Path(str(filename) + &#39;.dave_asset&#39;)

        filename = self.get_resource_path(filename)

        print(&#39;Loading {}&#39;.format(filename))

        f = open(file=filename, mode = &#39;r&#39;)
        s = self
        code = &#39;&#39;

        for line in f:
            code += line + &#39;\n&#39;

        exec(code, {}, {&#39;s&#39;: s})


    def import_scene(self, other, prefix = &#34;&#34;, containerize = True):
        &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

        To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

        Returns:
            Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
        &#34;&#34;&#34;

        if isinstance(other, Path):
            other = str(other)

        if isinstance(other, str):
            other = Scene(other)

        if not isinstance(other, Scene):
            raise TypeError(&#39;Other should be a Scene but is a &#39; + str(type(other)))

        old_prefix = self._name_prefix
        imported_element_names = []

        for n in other._nodes:
            imported_element_names.append(prefix + n.name)


        # check for double names

        for new_node_name in imported_element_names:
            if not self.name_available(new_node_name):
                raise NameError(&#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(new_node_name))


        self._name_prefix = prefix

        code = other.give_python_code()

        s = self
        exec(code)

        self._name_prefix = old_prefix # restore

        # Move all imported elements without a parent into a newly created axis system
        if containerize:

            container_name = s.available_name_like(&#39;import_container&#39;)

            c = self.new_axis(prefix + container_name)

            for name in imported_element_names:

                node = self[name]
                if not isinstance(node, NodeWithParent):
                    continue

                if node.parent is None:
                    node.change_parent_to(c)

            return c

        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="DAVE.scene.Axis"><code class="flex name class">
<span>class <span class="ident">Axis</span></span>
<span>(</span><span>scene, vfAxis)</span>
</code></dt>
<dd>
<section class="desc"><p>Axis</p>
<p>Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
The possible movements of an axis can be controlled in each degree of freedom using the "fixed" property.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>circular references are not allowed: It is not allowed to place a on b and b on a</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axis(NodeWithParent):
    &#34;&#34;&#34;
    Axis

    Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
    Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
    The possible movements of an axis can be controlled in each degree of freedom using the &#34;fixed&#34; property.

    Notes:
         - circular references are not allowed: It is not allowed to place a on b and b on a

    &#34;&#34;&#34;

    def __init__(self, scene, vfAxis):
        super().__init__(scene, vfAxis)
        self._None_parent_acceptable = True

    @property
    def fixed(self):
        &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
        True means that that degree of freedom will not change when solving statics.
        False means a that is may be changed in order to find equilibrium.

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

        See Also: set_free, set_fixed
        &#34;&#34;&#34;
        return self._vfNode.fixed

    @fixed.setter
    def fixed(self, var):
        if var == True:
            var = (True,True,True,True,True,True)
        if var == False:
            var = (False, False, False, False, False, False)

        self._vfNode.fixed = var

    def set_free(self):
        &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
        self._vfNode.set_free()

    def set_fixed(self):
        &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;
        self._vfNode.set_fixed()

    @property
    def x(self):
        &#34;&#34;&#34;The x-component of the position vector&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    def x(self, var):
        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    def y(self, var):
        a = self.position
        self.position = (a[0], var , a[2])

    @z.setter
    def z(self, var):
        a = self.position
        self.position = (a[0], a[1], var)



    @property
    def position(self):
        &#34;&#34;&#34;Position of the axis (x,y,z)
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    def position(self, var):
        assert3f(var, &#34;Position &#34;)
        self._vfNode.position = var
        self._scene._geometry_changed()

    @property
    def rx(self):
        &#34;&#34;&#34;The x-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[0]

    @property
    def ry(self):
        &#34;&#34;&#34;The y-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[1]

    @property
    def rz(self):
        &#34;&#34;&#34;The z-component of the rotation vector&#34;&#34;&#34;
        return self.rotation[2]

    @rx.setter
    def rx(self, var):
        a = self.rotation
        self.rotation = (var, a[1], a[2])

    @ry.setter
    def ry(self, var):
        a = self.rotation
        self.rotation = (a[0], var , a[2])

    @rz.setter
    def rz(self, var):
        a = self.rotation
        self.rotation = (a[0], a[1], var)

    @property
    def rotation(self):
        &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
        Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.rotation)

    @rotation.setter
    def rotation(self, var):
        # convert to degrees
        assert3f(var, &#34;Rotation &#34;)
        self._vfNode.rotation = np.deg2rad(var)
        self._scene._geometry_changed()

    # we need to over-ride the parent property to be able to call _geometry_changed afterwards
    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;&#34;&#34;&#34;
        return super().parent

    @parent.setter
    def parent(self, val):
        NodeWithParent.parent.fset(self, val)
        self._scene._geometry_changed()

    @property
    def gx(self):
        &#34;&#34;&#34;The x-component of the global position vector&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;The y-component of the global position vector&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;The z-component of the global position vector&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    def gx(self, var):
        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    def gy(self, var):
        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    def gz(self, var):
        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;The global position of the origin.&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    def global_position(self, val):
        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    @property
    def grx(self):
        &#34;&#34;&#34;The x-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[0]

    @property
    def gry(self):
        &#34;&#34;&#34;The y-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[1]

    @property
    def grz(self):
        &#34;&#34;&#34;The z-component of the global rotation vector&#34;&#34;&#34;
        return self.global_rotation[2]

    @grx.setter
    def grx(self, var):
        a = self.global_rotation
        self.global_rotation = (var, a[1], a[2])

    @gry.setter
    def gry(self, var):
        a = self.global_rotation
        self.global_rotation = (a[0], var, a[2])

    @grz.setter
    def grz(self, var):
        a = self.global_rotation
        self.global_rotation = (a[0], a[1], var)

    @property
    def global_rotation(self):
        &#34;&#34;&#34;The rotation of the axis in degrees. Expressed in the global axis system&#34;&#34;&#34;
        return tuple(np.rad2deg(self._vfNode.global_rotation))

    @global_rotation.setter
    def global_rotation(self, val):
        assert3f(val, &#34;Global Rotation&#34;)
        if self.parent:
            self.rotation = self.parent.to_loc_rotation(val)
        else:
            self.rotation = val

    @property
    def global_transform(self):
        &#34;&#34;&#34;Read-only: The global tranform of the axis system.&#34;&#34;&#34;
        return self._vfNode.global_transform

    @property
    def connection_force(self):
        &#34;&#34;&#34;Returns the force and moment that this axis applies on its parent [Parent axis system]&#34;&#34;&#34;
        return self._vfNode.connection_force

    @property
    def connection_force_x(self):
        &#34;&#34;&#34;The x-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[0]

    @property
    def connection_force_y(self):
        &#34;&#34;&#34;The y-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[1]

    @property
    def connection_force_z(self):
        &#34;&#34;&#34;The z-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[2]

    @property
    def connection_moment_x(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[3]

    @property
    def connection_moment_y(self):
        &#34;&#34;&#34;The my-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[4]

    @property
    def connection_moment_z(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
        return self.connection_force[5]

    @property
    def applied_force(self):
        &#34;&#34;&#34;Returns the force and moment that is applied on this axis [Global axis system]
        &#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def equilibrium_error(self):
        &#34;&#34;&#34;Returns the force and moment that remains on this axis (applied-force minus connection force) [Parent axis system]
        &#34;&#34;&#34;
        return self._vfNode.equilibrium_error

    def to_loc_position(self, value):
        &#34;&#34;&#34;Returns the local position of a point in the global axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_loc_direction
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_point(value)

    def to_glob_position(self, value):
        &#34;&#34;&#34;Returns the global position of a point in the local axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_glob_direction
        &#34;&#34;&#34;
        return self._vfNode.local_to_global_point(value)

    def to_loc_direction(self, value):
        &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
        This considers only the rotation of the axis system.
        See Also: to_loc_position
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_vector(value)

    def to_glob_direction(self, value):
        &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
        This considers only the rotation of the axis system.
        See Also: to_glob_position&#34;&#34;&#34;
        return self._vfNode.local_to_global_vector(value)

    def to_loc_rotation(self, value):
        &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
            See Also: to_loc_position, to_loc_direction
             &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))

    def to_glob_rotation(self, value):
        &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
            See Also: to_loc_position, to_loc_direction
             &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        # check new_parent
        if new_parent is not None:
            if not isinstance(new_parent, Axis):
                raise TypeError(
                    &#39;Only None or Axis-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#39;.format(
                    type(new_parent)))

        glob_pos = self.global_position
        glob_rot = self.global_rotation
        self.parent = new_parent
        self.global_position = glob_pos
        self.global_rotation = glob_rot



    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_axis(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n           parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        if self.fixed[0]:
            code += &#34;\n           position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n           position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                     {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                     {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n           rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n           rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                     {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                     {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.rotation[2])

        code += &#34;\n           fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Axis.applied_force"><code class="name">var <span class="ident">applied_force</span></code></dt>
<dd>
<section class="desc"><p>Returns the force and moment that is applied on this axis [Global axis system]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def applied_force(self):
    &#34;&#34;&#34;Returns the force and moment that is applied on this axis [Global axis system]
    &#34;&#34;&#34;
    return self._vfNode.applied_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force"><code class="name">var <span class="ident">connection_force</span></code></dt>
<dd>
<section class="desc"><p>Returns the force and moment that this axis applies on its parent [Parent axis system]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force(self):
    &#34;&#34;&#34;Returns the force and moment that this axis applies on its parent [Parent axis system]&#34;&#34;&#34;
    return self._vfNode.connection_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_x"><code class="name">var <span class="ident">connection_force_x</span></code></dt>
<dd>
<section class="desc"><p>The x-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_x(self):
    &#34;&#34;&#34;The x-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_y"><code class="name">var <span class="ident">connection_force_y</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_y(self):
    &#34;&#34;&#34;The y-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_z"><code class="name">var <span class="ident">connection_force_z</span></code></dt>
<dd>
<section class="desc"><p>The z-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_z(self):
    &#34;&#34;&#34;The z-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_x"><code class="name">var <span class="ident">connection_moment_x</span></code></dt>
<dd>
<section class="desc"><p>The mx-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_x(self):
    &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[3]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_y"><code class="name">var <span class="ident">connection_moment_y</span></code></dt>
<dd>
<section class="desc"><p>The my-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_y(self):
    &#34;&#34;&#34;The my-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[4]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_z"><code class="name">var <span class="ident">connection_moment_z</span></code></dt>
<dd>
<section class="desc"><p>The mx-component of the connection-force vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_z(self):
    &#34;&#34;&#34;The mx-component of the connection-force vector&#34;&#34;&#34;
    return self.connection_force[5]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.equilibrium_error"><code class="name">var <span class="ident">equilibrium_error</span></code></dt>
<dd>
<section class="desc"><p>Returns the force and moment that remains on this axis (applied-force minus connection force) [Parent axis system]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def equilibrium_error(self):
    &#34;&#34;&#34;Returns the force and moment that remains on this axis (applied-force minus connection force) [Parent axis system]
    &#34;&#34;&#34;
    return self._vfNode.equilibrium_error</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.fixed"><code class="name">var <span class="ident">fixed</span></code></dt>
<dd>
<section class="desc"><p>Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
True means that that degree of freedom will not change when solving statics.
False means a that is may be changed in order to find equilibrium.</p>
<p>These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p>
<p>See Also: set_free, set_fixed</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed(self):
    &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
    True means that that degree of freedom will not change when solving statics.
    False means a that is may be changed in order to find equilibrium.

    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

    See Also: set_free, set_fixed
    &#34;&#34;&#34;
    return self._vfNode.fixed</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_position"><code class="name">var <span class="ident">global_position</span></code></dt>
<dd>
<section class="desc"><p>The global position of the origin.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_position(self):
    &#34;&#34;&#34;The global position of the origin.&#34;&#34;&#34;
    return self._vfNode.global_position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_rotation"><code class="name">var <span class="ident">global_rotation</span></code></dt>
<dd>
<section class="desc"><p>The rotation of the axis in degrees. Expressed in the global axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_rotation(self):
    &#34;&#34;&#34;The rotation of the axis in degrees. Expressed in the global axis system&#34;&#34;&#34;
    return tuple(np.rad2deg(self._vfNode.global_rotation))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_transform"><code class="name">var <span class="ident">global_transform</span></code></dt>
<dd>
<section class="desc"><p>Read-only: The global tranform of the axis system.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_transform(self):
    &#34;&#34;&#34;Read-only: The global tranform of the axis system.&#34;&#34;&#34;
    return self._vfNode.global_transform</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.grx"><code class="name">var <span class="ident">grx</span></code></dt>
<dd>
<section class="desc"><p>The x-component of the global rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grx(self):
    &#34;&#34;&#34;The x-component of the global rotation vector&#34;&#34;&#34;
    return self.global_rotation[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gry"><code class="name">var <span class="ident">gry</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the global rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gry(self):
    &#34;&#34;&#34;The y-component of the global rotation vector&#34;&#34;&#34;
    return self.global_rotation[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.grz"><code class="name">var <span class="ident">grz</span></code></dt>
<dd>
<section class="desc"><p>The z-component of the global rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grz(self):
    &#34;&#34;&#34;The z-component of the global rotation vector&#34;&#34;&#34;
    return self.global_rotation[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gx"><code class="name">var <span class="ident">gx</span></code></dt>
<dd>
<section class="desc"><p>The x-component of the global position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gx(self):
    &#34;&#34;&#34;The x-component of the global position vector&#34;&#34;&#34;
    return self.global_position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gy"><code class="name">var <span class="ident">gy</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the global position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gy(self):
    &#34;&#34;&#34;The y-component of the global position vector&#34;&#34;&#34;
    return self.global_position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gz"><code class="name">var <span class="ident">gz</span></code></dt>
<dd>
<section class="desc"><p>The z-component of the global position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gz(self):
    &#34;&#34;&#34;The z-component of the global position vector&#34;&#34;&#34;
    return self.global_position[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<section class="desc"><p>Determines the parent of the axis. Should either be another axis or 'None'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;&#34;&#34;&#34;
    return super().parent</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Position of the axis (x,y,z)
These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    &#34;&#34;&#34;Position of the axis (x,y,z)
    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rotation"><code class="name">var <span class="ident">rotation</span></code></dt>
<dd>
<section class="desc"><p>Rotation of the axis about its origin (rx,ry,rz).
Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation(self):
    &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
    Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
    return np.rad2deg(self._vfNode.rotation)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rx"><code class="name">var <span class="ident">rx</span></code></dt>
<dd>
<section class="desc"><p>The x-component of the rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rx(self):
    &#34;&#34;&#34;The x-component of the rotation vector&#34;&#34;&#34;
    return self.rotation[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.ry"><code class="name">var <span class="ident">ry</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ry(self):
    &#34;&#34;&#34;The y-component of the rotation vector&#34;&#34;&#34;
    return self.rotation[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rz"><code class="name">var <span class="ident">rz</span></code></dt>
<dd>
<section class="desc"><p>The z-component of the rotation vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rz(self):
    &#34;&#34;&#34;The z-component of the rotation vector&#34;&#34;&#34;
    return self.rotation[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<section class="desc"><p>The x-component of the position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34;The x-component of the position vector&#34;&#34;&#34;
    return self.position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
    return self.position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"><p>The y-component of the position vector</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    &#34;&#34;&#34;The y-component of the position vector&#34;&#34;&#34;
    return self.position[2]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Axis.set_fixed"><code class="name flex">
<span>def <span class="ident">set_fixed</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets .fixed to (True,True,True,True,True,True)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fixed(self):
    &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;
    self._vfNode.set_fixed()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.set_free"><code class="name flex">
<span>def <span class="ident">set_free</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets .fixed to (False,False,False,False,False,False)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_free(self):
    &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
    self._vfNode.set_free()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_direction"><code class="name flex">
<span>def <span class="ident">to_glob_direction</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the global direction of a point in the local axis system.
This considers only the rotation of the axis system.
See Also: to_glob_position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_direction(self, value):
    &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
    This considers only the rotation of the axis system.
    See Also: to_glob_position&#34;&#34;&#34;
    return self._vfNode.local_to_global_vector(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_position"><code class="name flex">
<span>def <span class="ident">to_glob_position</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the global position of a point in the local axis system.
This considers the position and the rotation of the axis system.
See Also: to_glob_direction</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_position(self, value):
    &#34;&#34;&#34;Returns the global position of a point in the local axis system.
    This considers the position and the rotation of the axis system.
    See Also: to_glob_direction
    &#34;&#34;&#34;
    return self._vfNode.local_to_global_point(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_rotation"><code class="name flex">
<span>def <span class="ident">to_glob_rotation</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the global rotation. Used for rotating rotations.
See Also: to_loc_position, to_loc_direction</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_rotation(self, value):
    &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
         &#34;&#34;&#34;
    return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_direction"><code class="name flex">
<span>def <span class="ident">to_loc_direction</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the local direction of a point in the global axis system.
This considers only the rotation of the axis system.
See Also: to_loc_position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_direction(self, value):
    &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
    This considers only the rotation of the axis system.
    See Also: to_loc_position
    &#34;&#34;&#34;
    return self._vfNode.global_to_local_vector(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_position"><code class="name flex">
<span>def <span class="ident">to_loc_position</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the local position of a point in the global axis system.
This considers the position and the rotation of the axis system.
See Also: to_loc_direction</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_position(self, value):
    &#34;&#34;&#34;Returns the local position of a point in the global axis system.
    This considers the position and the rotation of the axis system.
    See Also: to_loc_direction
    &#34;&#34;&#34;
    return self._vfNode.global_to_local_point(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_rotation"><code class="name flex">
<span>def <span class="ident">to_loc_rotation</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the local rotation. Used for rotating rotations.
See Also: to_loc_position, to_loc_direction</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_rotation(self, value):
    &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
         &#34;&#34;&#34;
    return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Buoyancy"><code class="flex name class">
<span>class <span class="ident">Buoyancy</span></span>
<span>(</span><span>scene, vfBuoyancy)</span>
</code></dt>
<dd>
<section class="desc"><p>Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
The calculation of buoyancy is as accurate as the provided geometry.</p>
<p>There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.</p>
<p>The normals of the panels should point towards to water.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Buoyancy(NodeWithParent):
    &#34;&#34;&#34;Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
    The calculation of buoyancy is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point towards to water.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a buoyancy
    def __init__(self, scene, vfBuoyancy):
        super().__init__(scene, vfBuoyancy)
        self._None_parent_acceptable = True
        self._trimesh = TriMeshSource(self._scene, self._vfNode.trimesh) # the tri-mesh is wrapped in a custom object

    @property
    def trimesh(self):
        return self._trimesh

    @property
    def cob(self):
        &#34;&#34;&#34;Returns the GLOBAL position of the center of buoyancy

        To convert to local coordinates use the .to_loc_position() function of the parent.

        &#34;&#34;&#34;
        return self._vfNode.cob

    @property
    def displacement(self):
        &#34;&#34;&#34;Returns displaced volume in m^3&#34;&#34;&#34;
        return self._vfNode.displacement

    # @trimesh.setter
    # def trimesh(self, new_mesh):
    #     raise Exception()
    #     if isinstance(new_mesh, TriMeshSource):
    #         self._vfNode.trimesh = new_mesh._TriMesh
    #         self._trimesh = new_mesh
    #     else:
    #         raise TypeError(&#39;new_mesh should be a TriMeshSource object but is a {}&#39;.format(type(new_mesh)))

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_buoyancy(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent.name)
        code += &#34;\nmesh.trimesh.load_obj(s.get_resource_path(r&#39;{}&#39;), scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(self.trimesh._path, *self.trimesh._scale, *self.trimesh._rotation, *self.trimesh._offset)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Buoyancy.cob"><code class="name">var <span class="ident">cob</span></code></dt>
<dd>
<section class="desc"><p>Returns the GLOBAL position of the center of buoyancy</p>
<p>To convert to local coordinates use the .to_loc_position() function of the parent.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cob(self):
    &#34;&#34;&#34;Returns the GLOBAL position of the center of buoyancy

    To convert to local coordinates use the .to_loc_position() function of the parent.

    &#34;&#34;&#34;
    return self._vfNode.cob</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.displacement"><code class="name">var <span class="ident">displacement</span></code></dt>
<dd>
<section class="desc"><p>Returns displaced volume in m^3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displacement(self):
    &#34;&#34;&#34;Returns displaced volume in m^3&#34;&#34;&#34;
    return self._vfNode.displacement</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.trimesh"><code class="name">var <span class="ident">trimesh</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trimesh(self):
    return self._trimesh</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Cable"><code class="flex name class">
<span>class <span class="ident">Cable</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<section class="desc"><p>A Cable represents a linear elastic wire running from a Poi to another Poi.</p>
<p>A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.</p>
<p>Intermediate pois or sheaves may be added.</p>
<ul>
<li>Pois are considered as sheaves with a zero diameter.</li>
<li>Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.</li>
</ul>
<p>For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.</p>
<p>This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.</p>
<h2 id="notes">Notes</h2>
<p>If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cable(CoreConnectedNode):
    &#34;&#34;&#34;A Cable represents a linear elastic wire running from a Poi to another Poi.

    A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.

    Intermediate pois or sheaves may be added.

    - Pois are considered as sheaves with a zero diameter.
    - Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.

    For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
    cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.

    This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.

    Notes:
        If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
        This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.


    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._pois = list()

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the cable in [kN] (Readonly, calculated)&#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def stretch(self):
        &#34;&#34;&#34;Stretch of the cable in [m] (Readonly, calculated)&#34;&#34;&#34;
        return self._vfNode.stretch

    @property
    def length(self):
        &#34;&#34;&#34;Length in rest [m]&#34;&#34;&#34;
        return self._vfNode.Length

    @length.setter
    def length(self, val):
        if val &lt; 1e-9:
            raise Exception(&#39;Length shall be more than 0 (otherwise stiffness EA/L becomes infinite)&#39;)
        self._vfNode.Length = val

    @property
    def EA(self):
        &#34;&#34;&#34;Stiffness of the cable in [kN]&#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    def EA(self, ea):
        self._vfNode.EA = ea

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the cable [m]&#34;&#34;&#34;
        return self._vfNode.diameter

    @diameter.setter
    def diameter(self, diameter):
        self._vfNode.diameter = diameter

    def get_points_for_visual(self):
        &#34;&#34;&#34;Returns an list of 3D locations which can be used for visualization
        &#34;&#34;&#34;
        return self._vfNode.global_points

    def check_endpoints(self):
        &#34;&#34;&#34;Verifies that the endpoints are Pois&#34;&#34;&#34;
        if isinstance(self._pois[0], Sheave):
            raise ValueError(
                &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as start&#39;.format(self.name, self._pois[0].name))

        if isinstance(self._pois[-1], Sheave):
            raise ValueError(
                &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as endpoint&#39;.format(self.name, self._pois[-1].name))



    def _update_pois(self):
        self._vfNode.clear_connections()
        for point in self._pois:

            if isinstance(point, Poi):
                try:
                    self._vfNode.add_connection_poi(point._vfNode)
                except:
                    self._vfNode.add_connection(point._vfNode)
            if isinstance(point, Sheave):
                self._vfNode.add_connection_sheave(point._vfNode)

    def add_connection(self, apoi):
        &#34;&#34;&#34;Adds a poi to the list of connection points&#34;&#34;&#34;

        if isinstance(apoi, str):
            apoi = self._scene[apoi]

        if not (isinstance(apoi, Poi) or isinstance(apoi, Sheave)):
            raise TypeError(&#39;Provided point should be a Poi&#39;)

        if self._pois:  # check for not empty
            if self._pois[-1] == apoi:
                raise Exception(&#39;The same poi can not be added directly after itself: {}&#39;.format(apoi.name))

        self._pois.append(apoi)
        self._update_pois()

    def clear_connections(self):
        &#34;&#34;&#34;Removes all connections&#34;&#34;&#34;
        self._pois.clear()
        self._update_pois()

    def give_poi_names(self):
        &#34;&#34;&#34;Returns a list with the names of all the pois&#34;&#34;&#34;
        r = list()
        for p in self._pois:
            r.append(p.name)
        return r

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        poi_names = self.give_poi_names()
        n_sheaves = len(poi_names)-2

        code += &#34;\ns.new_cable(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            poiA=&#39;{}&#39;,&#34;.format(poi_names[0])
        code += &#34;\n            poiB=&#39;{}&#39;,&#34;.format(poi_names[-1])
        code += &#34;\n            length={},&#34;.format(self.length)

        if self.diameter != 0:
            code += &#34;\n            diameter={},&#34;.format(self.diameter)

        if len(poi_names) &lt;= 2:
            code += &#34;\n            EA={})&#34;.format(self.EA)
        else:
            code += &#34;\n            EA={},&#34;.format(self.EA)

            if n_sheaves == 1:
                code += &#34;\n            sheaves = [&#39;{}&#39;])&#34;.format(poi_names[1])
            else:
                code += &#34;\n            sheaves = [&#39;{}&#39;,&#34;.format(poi_names[1])
                for i in range(n_sheaves-2):
                    code += &#34;\n                       &#39;{}&#39;,&#34;.format(poi_names[2+i])
                code += &#34;\n                       &#39;{}&#39;]),&#34;.format(poi_names[-2])


        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Cable.EA"><code class="name">var <span class="ident">EA</span></code></dt>
<dd>
<section class="desc"><p>Stiffness of the cable in [kN]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EA(self):
    &#34;&#34;&#34;Stiffness of the cable in [kN]&#34;&#34;&#34;
    return self._vfNode.EA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.diameter"><code class="name">var <span class="ident">diameter</span></code></dt>
<dd>
<section class="desc"><p>Diameter of the cable [m]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def diameter(self):
    &#34;&#34;&#34;Diameter of the cable [m]&#34;&#34;&#34;
    return self._vfNode.diameter</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<section class="desc"><p>Length in rest [m]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self):
    &#34;&#34;&#34;Length in rest [m]&#34;&#34;&#34;
    return self._vfNode.Length</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.stretch"><code class="name">var <span class="ident">stretch</span></code></dt>
<dd>
<section class="desc"><p>Stretch of the cable in [m] (Readonly, calculated)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stretch(self):
    &#34;&#34;&#34;Stretch of the cable in [m] (Readonly, calculated)&#34;&#34;&#34;
    return self._vfNode.stretch</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.tension"><code class="name">var <span class="ident">tension</span></code></dt>
<dd>
<section class="desc"><p>Tension in the cable in [kN] (Readonly, calculated)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tension(self):
    &#34;&#34;&#34;Tension in the cable in [kN] (Readonly, calculated)&#34;&#34;&#34;
    return self._vfNode.tension</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Cable.add_connection"><code class="name flex">
<span>def <span class="ident">add_connection</span></span>(<span>self, apoi)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a poi to the list of connection points</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_connection(self, apoi):
    &#34;&#34;&#34;Adds a poi to the list of connection points&#34;&#34;&#34;

    if isinstance(apoi, str):
        apoi = self._scene[apoi]

    if not (isinstance(apoi, Poi) or isinstance(apoi, Sheave)):
        raise TypeError(&#39;Provided point should be a Poi&#39;)

    if self._pois:  # check for not empty
        if self._pois[-1] == apoi:
            raise Exception(&#39;The same poi can not be added directly after itself: {}&#39;.format(apoi.name))

    self._pois.append(apoi)
    self._update_pois()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.check_endpoints"><code class="name flex">
<span>def <span class="ident">check_endpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Verifies that the endpoints are Pois</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_endpoints(self):
    &#34;&#34;&#34;Verifies that the endpoints are Pois&#34;&#34;&#34;
    if isinstance(self._pois[0], Sheave):
        raise ValueError(
            &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as start&#39;.format(self.name, self._pois[0].name))

    if isinstance(self._pois[-1], Sheave):
        raise ValueError(
            &#39;First and last connection of a cable {} should be of type &lt;Poi&gt;. It is not allowed to use Sheave {} as endpoint&#39;.format(self.name, self._pois[-1].name))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.clear_connections"><code class="name flex">
<span>def <span class="ident">clear_connections</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes all connections</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_connections(self):
    &#34;&#34;&#34;Removes all connections&#34;&#34;&#34;
    self._pois.clear()
    self._update_pois()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.get_points_for_visual"><code class="name flex">
<span>def <span class="ident">get_points_for_visual</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an list of 3D locations which can be used for visualization</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_for_visual(self):
    &#34;&#34;&#34;Returns an list of 3D locations which can be used for visualization
    &#34;&#34;&#34;
    return self._vfNode.global_points</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.give_poi_names"><code class="name flex">
<span>def <span class="ident">give_poi_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list with the names of all the pois</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_poi_names(self):
    &#34;&#34;&#34;Returns a list with the names of all the pois&#34;&#34;&#34;
    r = list()
    for p in self._pois:
        r.append(p.name)
    return r</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Connector2d"><code class="flex name class">
<span>class <span class="ident">Connector2d</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<section class="desc"><p>A Connector2d linear connector with acts both on linear displacement and angular displacement.</p>
<ul>
<li>the linear stiffness is defined by k_linear and is defined over the actual shortest direction between master and slave.</li>
<li>the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connector2d(CoreConnectedNode):
    &#34;&#34;&#34;A Connector2d linear connector with acts both on linear displacement and angular displacement.

    * the linear stiffness is defined by k_linear and is defined over the actual shortest direction between master and slave.
    * the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def angle(self):
        &#34;&#34;&#34;Actual angle between master and slave [deg] (read-only)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.angle)

    @property
    def force(self):
        &#34;&#34;&#34;Actual force between master and slave [kN] (read-only)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def moment(self):
        &#34;&#34;&#34;Actual moment between master and slave [kN*m] (read-only)&#34;&#34;&#34;
        return self._vfNode.moment

    @property
    def axis(self):
        &#34;&#34;&#34;Actual rotation axis between master and slave (read-only)&#34;&#34;&#34;
        return self._vfNode.axis

    @property
    def k_linear(self):
        &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.k_linear

    @k_linear.setter
    def k_linear(self, value):
        self._vfNode.k_linear = value

    @property
    def k_angular(self):
        &#34;&#34;&#34;Linear stiffness [kN*m/rad]&#34;&#34;&#34;
        return self._vfNode.k_angular

    @k_angular.setter
    def k_angular(self, value):
        self._vfNode.k_angular = value

    @property
    def master(self):
        &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
        return self._master

    @master.setter
    def master(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_connector2d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            k_linear ={},&#34;.format(self.k_linear)
        code += &#34;\n            k_angular ={})&#34;.format(self.k_angular)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Connector2d.angle"><code class="name">var <span class="ident">angle</span></code></dt>
<dd>
<section class="desc"><p>Actual angle between master and slave [deg] (read-only)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def angle(self):
    &#34;&#34;&#34;Actual angle between master and slave [deg] (read-only)&#34;&#34;&#34;
    return np.rad2deg(self._vfNode.angle)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.axis"><code class="name">var <span class="ident">axis</span></code></dt>
<dd>
<section class="desc"><p>Actual rotation axis between master and slave (read-only)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axis(self):
    &#34;&#34;&#34;Actual rotation axis between master and slave (read-only)&#34;&#34;&#34;
    return self._vfNode.axis</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.force"><code class="name">var <span class="ident">force</span></code></dt>
<dd>
<section class="desc"><p>Actual force between master and slave [kN] (read-only)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def force(self):
    &#34;&#34;&#34;Actual force between master and slave [kN] (read-only)&#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.k_angular"><code class="name">var <span class="ident">k_angular</span></code></dt>
<dd>
<section class="desc"><p>Linear stiffness [kN*m/rad]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k_angular(self):
    &#34;&#34;&#34;Linear stiffness [kN*m/rad]&#34;&#34;&#34;
    return self._vfNode.k_angular</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.k_linear"><code class="name">var <span class="ident">k_linear</span></code></dt>
<dd>
<section class="desc"><p>Linear stiffness [kN/m]</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k_linear(self):
    &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
    return self._vfNode.k_linear</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.master"><code class="name">var <span class="ident">master</span></code></dt>
<dd>
<section class="desc"><p>Master axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def master(self):
    &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
    return self._master</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.moment"><code class="name">var <span class="ident">moment</span></code></dt>
<dd>
<section class="desc"><p>Actual moment between master and slave [kN*m] (read-only)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment(self):
    &#34;&#34;&#34;Actual moment between master and slave [kN*m] (read-only)&#34;&#34;&#34;
    return self._vfNode.moment</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.slave"><code class="name">var <span class="ident">slave</span></code></dt>
<dd>
<section class="desc"><p>Slave axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slave(self):
    &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
    return self._slave</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.CoreConnectedNode"><code class="flex name class">
<span>class <span class="ident">CoreConnectedNode</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<section class="desc"><p>ABSTRACT CLASS - Properties defined here are applicable to all derived classes
Master class for all nodes with a connected eqCore element</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoreConnectedNode(Node):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes with a connected eqCore element&#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene)
        self._vfNode = vfNode

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._vfNode.name

    @name.setter
    def name(self, name):
        if not name == self._vfNode.name:
            self._scene._verify_name_available(name)
            self._vfNode.name = name

    def _delete_vfc(self):
        self._scene._vfc.delete(self._vfNode.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></li>
<li><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></li>
<li><a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d">Connector2d</a></li>
<li><a title="DAVE.scene.LinearBeam" href="#DAVE.scene.LinearBeam">LinearBeam</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Force"><code class="flex name class">
<span>class <span class="ident">Force</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<section class="desc"><p>A Force models a force and moment on a poi.</p>
<p>Both are expressed in the global axis system.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Force(NodeWithParent):
    &#34;&#34;&#34;A Force models a force and moment on a poi.

    Both are expressed in the global axis system.

    &#34;&#34;&#34;

    @property
    def force(self):
        &#34;&#34;&#34;
        Gets or sets the x,y and z force components.

        Example s[&#39;wind&#39;].force = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.force

    @force.setter
    def force(self, val):
        assert3f(val)
        self._vfNode.force = val

    @property
    def moment(self):
        &#34;&#34;&#34;
        Gets or sets the x,y and z moment components.

        Example s[&#39;wind&#39;].moment = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.moment


    @moment.setter
    def moment(self, val):
        assert3f(val)
        self._vfNode.moment = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_force(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            force=({}, {}, {}),&#34;.format(*self.force)
        code += &#34;\n            moment=({}, {}, {}) )&#34;.format(*self.moment)
        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Force.force"><code class="name">var <span class="ident">force</span></code></dt>
<dd>
<section class="desc"><p>Gets or sets the x,y and z force components.</p>
<p>Example s['wind'].force = (12,34,56)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def force(self):
    &#34;&#34;&#34;
    Gets or sets the x,y and z force components.

    Example s[&#39;wind&#39;].force = (12,34,56)
    &#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.moment"><code class="name">var <span class="ident">moment</span></code></dt>
<dd>
<section class="desc"><p>Gets or sets the x,y and z moment components.</p>
<p>Example s['wind'].moment = (12,34,56)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment(self):
    &#34;&#34;&#34;
    Gets or sets the x,y and z moment components.

    Example s[&#39;wind&#39;].moment = (12,34,56)
    &#34;&#34;&#34;
    return self._vfNode.moment</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.HydSpring"><code class="flex name class">
<span>class <span class="ident">HydSpring</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<section class="desc"><p>A HydSpring models a linearized hydrostatic spring.</p>
<p>The cob (center of buoyancy) is defined in the parent axis system.
All other properties are defined relative to the cob.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HydSpring(NodeWithParent):
    &#34;&#34;&#34;A HydSpring models a linearized hydrostatic spring.

    The cob (center of buoyancy) is defined in the parent axis system.
    All other properties are defined relative to the cob.

    &#34;&#34;&#34;

    @property
    def cob(self):
        &#34;&#34;&#34;Center of buoyancy in parent axis system&#34;&#34;&#34;
        return self._vfNode.position

    @cob.setter
    def cob(self, val):
        assert3f(val)
        self._vfNode.position = val

    @property
    def BMT(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for roll&#34;&#34;&#34;
        return self._vfNode.BMT

    @BMT.setter
    def BMT(self, val):
        self._vfNode.BMT = val

    @property
    def BML(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch&#34;&#34;&#34;
        return self._vfNode.BML

    @BML.setter
    def BML(self, val):
        self._vfNode.BML = val

    @property
    def COFX(self):
        &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
        return self._vfNode.COFX

    @COFX.setter
    def COFX(self, val):
        self._vfNode.COFX = val

    @property
    def COFY(self):
        &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
        return self._vfNode.COFY

    @COFY.setter
    def COFY(self, val):
        self._vfNode.COFY = val

    @property
    def kHeave(self):
        &#34;&#34;&#34;Heave stiffness in kN/m&#34;&#34;&#34;
        return self._vfNode.kHeave

    @kHeave.setter
    def kHeave(self, val):
        self._vfNode.kHeave = val

    @property
    def waterline(self):
        &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is)&#34;&#34;&#34;
        return self._vfNode.waterline

    @waterline.setter
    def waterline(self, val):
        self._vfNode.waterline = val

    @property
    def displacement_kN(self):
        &#34;&#34;&#34;Displacement in [kN] when waterline is at waterline-elevation&#34;&#34;&#34;
        return self._vfNode.displacement_kN

    @displacement_kN.setter
    def displacement_kN(self, val):
        self._vfNode.displacement_kN = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_hydspring(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            cob=({}, {}, {}),&#34;.format(*self.cob)
        code += &#34;\n            BMT={},&#34;.format(self.BMT)
        code += &#34;\n            BML={},&#34;.format(self.BML)
        code += &#34;\n            COFX={},&#34;.format(self.COFX)
        code += &#34;\n            COFY={},&#34;.format(self.COFY)
        code += &#34;\n            kHeave={},&#34;.format(self.kHeave)
        code += &#34;\n            waterline={},&#34;.format(self.waterline)
        code += &#34;\n            displacement_kN={} )&#34;.format(self.displacement_kN)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.HydSpring.BML"><code class="name">var <span class="ident">BML</span></code></dt>
<dd>
<section class="desc"><p>Vertical distance between cob and metacenter for pitch</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def BML(self):
    &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch&#34;&#34;&#34;
    return self._vfNode.BML</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.BMT"><code class="name">var <span class="ident">BMT</span></code></dt>
<dd>
<section class="desc"><p>Vertical distance between cob and metacenter for roll</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def BMT(self):
    &#34;&#34;&#34;Vertical distance between cob and metacenter for roll&#34;&#34;&#34;
    return self._vfNode.BMT</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.COFX"><code class="name">var <span class="ident">COFX</span></code></dt>
<dd>
<section class="desc"><p>Horizontal x-position Center of Floatation (center of waterplane area), relative to cob</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def COFX(self):
    &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
    return self._vfNode.COFX</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.COFY"><code class="name">var <span class="ident">COFY</span></code></dt>
<dd>
<section class="desc"><p>Horizontal y-position Center of Floatation (center of waterplane area), relative to cob</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def COFY(self):
    &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob&#34;&#34;&#34;
    return self._vfNode.COFY</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.cob"><code class="name">var <span class="ident">cob</span></code></dt>
<dd>
<section class="desc"><p>Center of buoyancy in parent axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cob(self):
    &#34;&#34;&#34;Center of buoyancy in parent axis system&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.displacement_kN"><code class="name">var <span class="ident">displacement_kN</span></code></dt>
<dd>
<section class="desc"><p>Displacement in [kN] when waterline is at waterline-elevation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displacement_kN(self):
    &#34;&#34;&#34;Displacement in [kN] when waterline is at waterline-elevation&#34;&#34;&#34;
    return self._vfNode.displacement_kN</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.kHeave"><code class="name">var <span class="ident">kHeave</span></code></dt>
<dd>
<section class="desc"><p>Heave stiffness in kN/m</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kHeave(self):
    &#34;&#34;&#34;Heave stiffness in kN/m&#34;&#34;&#34;
    return self._vfNode.kHeave</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.waterline"><code class="name">var <span class="ident">waterline</span></code></dt>
<dd>
<section class="desc"><p>Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def waterline(self):
    &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is)&#34;&#34;&#34;
    return self._vfNode.waterline</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.LC6d"><code class="flex name class">
<span>class <span class="ident">LC6d</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<section class="desc"><p>A LC6d models a Linear Connector with 6 dofs.</p>
<p>It connects two Axis elements with six linear springs.
The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:</p>
<ul>
<li>rotation_x = arc-tan ( uy[0] / uy[1] )</li>
<li>rotation_y = arc-tan ( -ux[0] / ux[2] )</li>
<li>rotation_z = arc-tan ( ux[0] / ux [1] )</li>
</ul>
<p>which works fine for small rotations and rotations about only a single axis.</p>
<p>Try to avoid using very high stiffness settings to create fixed connections. It is better to use use the "fixed"
property of axis systems to create joints.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LC6d(CoreConnectedNode):
    &#34;&#34;&#34;A LC6d models a Linear Connector with 6 dofs.

    It connects two Axis elements with six linear springs.
    The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:

      - rotation_x = arc-tan ( uy[0] / uy[1] )
      - rotation_y = arc-tan ( -ux[0] / ux[2] )
      - rotation_z = arc-tan ( ux[0] / ux [1] )

    which works fine for small rotations and rotations about only a single axis.

    Try to avoid using very high stiffness settings to create fixed connections. It is better to use use the &#34;fixed&#34;
    property of axis systems to create joints.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def stiffness(self):
        &#34;&#34;&#34;Stiffness of the connector (kx, ky, kz, krx, kry, krz)&#34;&#34;&#34;
        return self._vfNode.stiffness

    @stiffness.setter
    def stiffness(self, val):
        self._vfNode.stiffness = val

    @property
    def master(self):
        &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
        return self._master

    @master.setter
    def master(self,val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode


    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)


        code += &#34;\ns.new_linear_connector_6d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            stiffness=({}, {}, {}, &#34;.format(*self.stiffness[:3])
        code += &#34;\n                       {}, {}, {}) )&#34;.format(*self.stiffness[3:])

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.LC6d.master"><code class="name">var <span class="ident">master</span></code></dt>
<dd>
<section class="desc"><p>Master axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def master(self):
    &#34;&#34;&#34;Master axis system&#34;&#34;&#34;
    return self._master</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.slave"><code class="name">var <span class="ident">slave</span></code></dt>
<dd>
<section class="desc"><p>Slave axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slave(self):
    &#34;&#34;&#34;Slave axis system&#34;&#34;&#34;
    return self._slave</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.stiffness"><code class="name">var <span class="ident">stiffness</span></code></dt>
<dd>
<section class="desc"><p>Stiffness of the connector (kx, ky, kz, krx, kry, krz)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stiffness(self):
    &#34;&#34;&#34;Stiffness of the connector (kx, ky, kz, krx, kry, krz)&#34;&#34;&#34;
    return self._vfNode.stiffness</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.LinearBeam"><code class="flex name class">
<span>class <span class="ident">LinearBeam</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<section class="desc"><p>A LinearBeam models a FEM-like linear beam element.</p>
<p>A LinearBeam node connects two Axis elements with six linear springs.</p>
<p>By definition the beam runs in the X-direction of the master axis system. So it may be needed to create a
dedicated Axis element for the beam to control the orientation.</p>
<p>The beam is defined using the following properties:</p>
<ul>
<li>EIy
- bending stiffness about y-axis</li>
<li>EIz
- bending stiffness about z-axis</li>
<li>GIp
- torsional stiffness about x-axis</li>
<li>EA
- axis stiffness in x-direction</li>
<li>L
- the un-stretched length of the beam</li>
</ul>
<p>The beam element is in rest if the slave axis system</p>
<ol>
<li>has the same global orientation as the master system</li>
<li>is at global position equal to the global position of local point (L,0,0) of the master axis. (aka: the end of the beam)</li>
</ol>
<p>The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
is determined as follows:</p>
<p>First the direction from master to slave is determined: D
The axis of rotation is the cross-product of the unit x-axis and D
AXIS = ux x D
The angle of rotation is the angle between the master x-axis and D</p>
<p>The rotation about the rotated X-axis is undefined.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearBeam(CoreConnectedNode):
    &#34;&#34;&#34;A LinearBeam models a FEM-like linear beam element.

    A LinearBeam node connects two Axis elements with six linear springs.

    By definition the beam runs in the X-direction of the master axis system. So it may be needed to create a
    dedicated Axis element for the beam to control the orientation.

    The beam is defined using the following properties:

    *  EIy  - bending stiffness about y-axis
    *  EIz  - bending stiffness about z-axis
    *  GIp  - torsional stiffness about x-axis
    *  EA   - axis stiffness in x-direction
    *  L    - the un-stretched length of the beam

    The beam element is in rest if the slave axis system

    1. has the same global orientation as the master system
    2. is at global position equal to the global position of local point (L,0,0) of the master axis. (aka: the end of the beam)


    The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
    is determined as follows:

    First the direction from master to slave is determined: D
    The axis of rotation is the cross-product of the unit x-axis and D    AXIS = ux x D
    The angle of rotation is the angle between the master x-axis and D

    The rotation about the rotated X-axis is undefined.
    
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._master = None
        self._slave = None

    @property
    def EIy(self):
        return self._vfNode.EIy
    @EIy.setter
    def EIy(self,value):
        self._vfNode.EIy = value

    @property
    def EIz(self):
        return self._vfNode.EIz

    @EIz.setter
    def EIz(self, value):
        self._vfNode.EIz = value

    @property
    def GIp(self):
        return self._vfNode.GIp

    @GIp.setter
    def GIp(self, value):
        self._vfNode.GIp = value

    @property
    def EA(self):
        return self._vfNode.EA

    @EA.setter
    def EA(self, value):
        self._vfNode.EA = value

    @property
    def master(self):
        return self._master

    @property
    def L(self):
        return self._vfNode.L

    @L.setter
    def L(self, value):
        self._vfNode.L = value

    @master.setter
    def master(self,val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._master = val
        self._vfNode.master = val._vfNode

    @property
    def slave(self):
        return self._slave

    @slave.setter
    def slave(self, val):
        if not isinstance(val, Axis):
            raise TypeError(&#39;Provided master should be a Axis&#39;)

        self._slave = val
        self._vfNode.slave = val._vfNode


    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_linearbeam(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            master=&#39;{}&#39;,&#34;.format(self.master.name)
        code += &#34;\n            slave=&#39;{}&#39;,&#34;.format(self.slave.name)
        code += &#34;\n            EIy ={},&#34;.format(self.EIy)
        code += &#34;\n            EIz ={},&#34;.format(self.EIz)
        code += &#34;\n            GIp ={},&#34;.format(self.GIp)
        code += &#34;\n            EA ={},&#34;.format(self.EA)
        code += &#34;\n            L ={}) # L can possibly be omitted&#34;.format(self.L)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.LinearBeam.EA"><code class="name">var <span class="ident">EA</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EA(self):
    return self._vfNode.EA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.EIy"><code class="name">var <span class="ident">EIy</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EIy(self):
    return self._vfNode.EIy</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.EIz"><code class="name">var <span class="ident">EIz</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EIz(self):
    return self._vfNode.EIz</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.GIp"><code class="name">var <span class="ident">GIp</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def GIp(self):
    return self._vfNode.GIp</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.L"><code class="name">var <span class="ident">L</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def L(self):
    return self._vfNode.L</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.master"><code class="name">var <span class="ident">master</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def master(self):
    return self._master</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LinearBeam.slave"><code class="name">var <span class="ident">slave</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slave(self):
    return self._slave</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<section class="desc"><p>ABSTRACT CLASS - Properties defined here are applicable to all derived classes
Master class for all nodes</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes&#34;&#34;&#34;

    def __init__(self, scene):
        self._scene = scene
        self._name = &#39;no name&#39;

    def give_python_code(self):
        &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
        return &#34;# No python code generated for element {}&#34;.format(self.name)

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    def _delete_vfc(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Visual" href="#DAVE.scene.Visual">Visual</a></li>
<li><a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Node.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Name of the node (str), must be unique</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Node.give_python_code"><code class="name flex">
<span>def <span class="ident">give_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the python code that can be executed to re-create this node</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_python_code(self):
    &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
    return &#34;# No python code generated for element {}&#34;.format(self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.scene.NodeWithParent"><code class="flex name class">
<span>class <span class="ident">NodeWithParent</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<section class="desc"><p>NodeWithParent</p>
<p>Do not use this class directly.
This is a base-class for all nodes that have a "parent" property.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeWithParent(CoreConnectedNode):
    &#34;&#34;&#34;
    NodeWithParent

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;parent&#34; property.
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)
        self._parent = None
        self._None_parent_acceptable = False

    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the node. Should be another axis or None&#34;&#34;&#34;
        if self._vfNode.parent is None:
            return None
        else:
            return self._parent
            # return Axis(self._scene, self._vfNode.parent)

    @parent.setter
    def parent(self, var):
        &#34;&#34;&#34;Assigns a new parent. Keeps the local position and rotations the same

        See also: change_parent_to
        &#34;&#34;&#34;

        if var is None:

            if not self._None_parent_acceptable:
                raise ValueError(&#39;None is not an acceptable parent for {} of {}&#39;.format(self.name, type(self)))

            self._parent = None
            self._vfNode.parent = None
        else:
            if isinstance(var, Axis):
                self._parent = var
                self._vfNode.parent = var._vfNode
            elif isinstance(var, Poi):
                self._parent = var
                self._vfNode.parent = var._vfNode
            else:
                raise Exception(&#39;Parent can only be set to an instance of Axis or Poi, not to a {}&#39;.format(type(var)))

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        try:
            self.rotation
            has_rotation = True
        except:
            has_rotation = False

        try:
            self.position
            has_position = True
        except:
            has_position = False

        # it is possible that this function is called on an object without position/rotation
        # in that case just fall-back to a change of parent
        if not has_position and not has_rotation:
            self.parent = new_parent
            return

        # check new_parent
        if new_parent is not None:

            if not isinstance(new_parent, Axis):
                if not has_rotation:
                    if not isinstance(new_parent, Poi):
                        raise TypeError(
                            &#39;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#39;.format(
                                type(new_parent)))
                else:
                    raise TypeError(
                        &#39;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#39;.format(
                            type(new_parent)))

        glob_pos = self.global_position

        if has_rotation:
            glob_rot = self.global_rotation

        self.parent = new_parent

        if new_parent is None:
            self.position = glob_pos
            if has_rotation:
                self.rotation = glob_rot

        else:
            self.position = new_parent.to_loc_position(glob_pos)
            if has_rotation:
                self.rotation = new_parent.to_loc_direction(glob_rot)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></li>
<li><a title="DAVE.scene.Poi" href="#DAVE.scene.Poi">Poi</a></li>
<li><a title="DAVE.scene.Force" href="#DAVE.scene.Force">Force</a></li>
<li><a title="DAVE.scene.Sheave" href="#DAVE.scene.Sheave">Sheave</a></li>
<li><a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring">HydSpring</a></li>
<li><a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy">Buoyancy</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.NodeWithParent.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<section class="desc"><p>Determines the parent of the node. Should be another axis or None</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;Determines the parent of the node. Should be another axis or None&#34;&#34;&#34;
    if self._vfNode.parent is None:
        return None
    else:
        return self._parent</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.NodeWithParent.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<section class="desc"><p>Assigns a new parent to the node but keeps the global position and rotation the same.</p>
<p>See also: .parent (property)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_parent</code></strong></dt>
<dd>new parent node</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

    See also: .parent (property)

    Args:
        new_parent: new parent node

    &#34;&#34;&#34;

    try:
        self.rotation
        has_rotation = True
    except:
        has_rotation = False

    try:
        self.position
        has_position = True
    except:
        has_position = False

    # it is possible that this function is called on an object without position/rotation
    # in that case just fall-back to a change of parent
    if not has_position and not has_rotation:
        self.parent = new_parent
        return

    # check new_parent
    if new_parent is not None:

        if not isinstance(new_parent, Axis):
            if not has_rotation:
                if not isinstance(new_parent, Poi):
                    raise TypeError(
                        &#39;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#39;.format(
                            type(new_parent)))
            else:
                raise TypeError(
                    &#39;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#39;.format(
                        type(new_parent)))

    glob_pos = self.global_position

    if has_rotation:
        glob_rot = self.global_rotation

    self.parent = new_parent

    if new_parent is None:
        self.position = glob_pos
        if has_rotation:
            self.rotation = glob_rot

    else:
        self.position = new_parent.to_loc_position(glob_pos)
        if has_rotation:
            self.rotation = new_parent.to_loc_direction(glob_rot)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Poi"><code class="flex name class">
<span>class <span class="ident">Poi</span></span>
<span>(</span><span>scene, vfPoi)</span>
</code></dt>
<dd>
<section class="desc"><p>A location on an axis</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Poi(NodeWithParent):
    &#34;&#34;&#34;A location on an axis&#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a poi
    def __init__(self, scene, vfPoi):
        super().__init__(scene, vfPoi)
        self._None_parent_acceptable = True


    @property
    def x(self):
        &#34;&#34;&#34;x component of local position&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;y component of local position&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        return self.position[2]

    @x.setter
    def x(self, var):
        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    def y(self, var):
        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    def z(self, var):
        &#34;&#34;&#34;z component of local position&#34;&#34;&#34;
        a = self.position
        self.position = (a[0], a[1], var)


    @property
    def position(self):
        &#34;&#34;&#34;Local position&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    def position(self, new_position):
        assert3f(new_position)
        self._vfNode.position = new_position

    @property
    def applied_force_and_moment_global(self):
        &#34;&#34;&#34;Returns the applied force in the parent axis system&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def gx(self):
        &#34;&#34;&#34;x component of global position&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;y component of global position&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;z component of global position&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    def gx(self, var):
        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    def gy(self, var):
        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    def gz(self, var):
        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;Global position&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    def global_position(self, val):
        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_poi(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent:
            code += &#34;\n          parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        code += &#34;\n          position=({},&#34;.format(self.position[0])
        code += &#34;\n                    {},&#34;.format(self.position[1])
        code += &#34;\n                    {}))&#34;.format(self.position[2])

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Poi.applied_force_and_moment_global"><code class="name">var <span class="ident">applied_force_and_moment_global</span></code></dt>
<dd>
<section class="desc"><p>Returns the applied force in the parent axis system</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def applied_force_and_moment_global(self):
    &#34;&#34;&#34;Returns the applied force in the parent axis system&#34;&#34;&#34;
    return self._vfNode.applied_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.global_position"><code class="name">var <span class="ident">global_position</span></code></dt>
<dd>
<section class="desc"><p>Global position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_position(self):
    &#34;&#34;&#34;Global position&#34;&#34;&#34;
    return self._vfNode.global_position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.gx"><code class="name">var <span class="ident">gx</span></code></dt>
<dd>
<section class="desc"><p>x component of global position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gx(self):
    &#34;&#34;&#34;x component of global position&#34;&#34;&#34;
    return self.global_position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.gy"><code class="name">var <span class="ident">gy</span></code></dt>
<dd>
<section class="desc"><p>y component of global position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gy(self):
    &#34;&#34;&#34;y component of global position&#34;&#34;&#34;
    return self.global_position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.gz"><code class="name">var <span class="ident">gz</span></code></dt>
<dd>
<section class="desc"><p>z component of global position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gz(self):
    &#34;&#34;&#34;z component of global position&#34;&#34;&#34;
    return self.global_position[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Local position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    &#34;&#34;&#34;Local position&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<section class="desc"><p>x component of local position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34;x component of local position&#34;&#34;&#34;
    return self.position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<section class="desc"><p>y component of local position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34;y component of local position&#34;&#34;&#34;
    return self.position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Poi.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    return self.position[2]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.RigidBody"><code class="flex name class">
<span>class <span class="ident">RigidBody</span></span>
<span>(</span><span>scene, axis, poi, force)</span>
</code></dt>
<dd>
<section class="desc"><p>A Rigid body, internally composed of an axis, a poi (cog) and a force (gravity)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBody(Axis):
    &#34;&#34;&#34;A Rigid body, internally composed of an axis, a poi (cog) and a force (gravity)&#34;&#34;&#34;

    def __init__(self, scene, axis, poi, force):
        super().__init__(scene, axis)

        # The axis is the Node
        # poi and force are added separately

        self._vfPoi = poi
        self._vfForce = force

    # override the following properties
    # - name : sets the names of poi and force as well

    def _delete_vfc(self):
        super()._delete_vfc()
        self._scene._vfc.delete(self._vfPoi.name)
        self._scene._vfc.delete(self._vfForce.name)

    @property  # can not define a setter without a getter..?
    def name(self):
        return super().name

    @name.setter
    def name(self, newname):
        # super().name = newname
        super(RigidBody, self.__class__).name.fset(self, newname)
        self._vfPoi.name = newname + vfc.VF_NAME_SPLIT + &#34;cog&#34;
        self._vfForce.name = newname + vfc.VF_NAME_SPLIT + &#34;gravity&#34;

    @property
    def cogx(self):
        return self.cog[0]

    @property
    def cogy(self):
        return self.cog[1]

    @property
    def cogz(self):
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Control the cog position of the body&#34;&#34;&#34;
        return self._vfPoi.position

    @cogx.setter
    def cogx(self, var):
        a = self.cog
        self.cog = (var, a[1], a[2])

    @cogy.setter
    def cogy(self, var):
        a = self.cog
        self.cog = (a[0], var, a[2])

    @cogz.setter
    def cogz(self, var):
        a = self.cog
        self.cog = (a[0], a[1], var)

    @cog.setter
    def cog(self, newcog):
        assert3f(newcog)
        self._vfPoi.position = newcog

    @property
    def mass(self):
        &#34;&#34;&#34;Control the static mass of the body&#34;&#34;&#34;
        return self._vfForce.force[2] / -vfc.G

    @mass.setter
    def mass(self, newmass):
        assert1f(newmass)
        self._vfForce.force = (0, 0, -vfc.G * newmass)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_rigidbody(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                mass={},&#34;.format(self.mass)
        code += &#34;\n                cog=({},&#34;.format(self.cog[0])
        code += &#34;\n                     {},&#34;.format(self.cog[1])
        code += &#34;\n                     {}),&#34;.format(self.cog[2])

        if self.parent:
            code += &#34;\n                parent=&#39;{}&#39;,&#34;.format(self.parent.name)

        # position

        if self.fixed[0]:
            code += &#34;\n                position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n                position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                          {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                          {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n                rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n                rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                          {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                          {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.rotation[2])

        code += &#34;\n                fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.RigidBody.cog"><code class="name">var <span class="ident">cog</span></code></dt>
<dd>
<section class="desc"><p>Control the cog position of the body</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog(self):
    &#34;&#34;&#34;Control the cog position of the body&#34;&#34;&#34;
    return self._vfPoi.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogx"><code class="name">var <span class="ident">cogx</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogx(self):
    return self.cog[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogy"><code class="name">var <span class="ident">cogy</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogy(self):
    return self.cog[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogz"><code class="name">var <span class="ident">cogz</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogz(self):
    return self.cog[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<section class="desc"><p>Control the static mass of the body</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass(self):
    &#34;&#34;&#34;Control the static mass of the body&#34;&#34;&#34;
    return self._vfForce.force[2] / -vfc.G</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Axis.applied_force" href="#DAVE.scene.Axis.applied_force">applied_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force" href="#DAVE.scene.Axis.connection_force">connection_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_x" href="#DAVE.scene.Axis.connection_force_x">connection_force_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_y" href="#DAVE.scene.Axis.connection_force_y">connection_force_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_z" href="#DAVE.scene.Axis.connection_force_z">connection_force_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_x" href="#DAVE.scene.Axis.connection_moment_x">connection_moment_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_y" href="#DAVE.scene.Axis.connection_moment_y">connection_moment_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_z" href="#DAVE.scene.Axis.connection_moment_z">connection_moment_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.equilibrium_error" href="#DAVE.scene.Axis.equilibrium_error">equilibrium_error</a></code></li>
<li><code><a title="DAVE.scene.Axis.fixed" href="#DAVE.scene.Axis.fixed">fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_position" href="#DAVE.scene.Axis.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_rotation" href="#DAVE.scene.Axis.global_rotation">global_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_transform" href="#DAVE.scene.Axis.global_transform">global_transform</a></code></li>
<li><code><a title="DAVE.scene.Axis.grx" href="#DAVE.scene.Axis.grx">grx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gry" href="#DAVE.scene.Axis.gry">gry</a></code></li>
<li><code><a title="DAVE.scene.Axis.grz" href="#DAVE.scene.Axis.grz">grz</a></code></li>
<li><code><a title="DAVE.scene.Axis.gx" href="#DAVE.scene.Axis.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gy" href="#DAVE.scene.Axis.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Axis.gz" href="#DAVE.scene.Axis.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Axis.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Axis.parent" href="#DAVE.scene.Axis.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Axis.position" href="#DAVE.scene.Axis.position">position</a></code></li>
<li><code><a title="DAVE.scene.Axis.rotation" href="#DAVE.scene.Axis.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.rx" href="#DAVE.scene.Axis.rx">rx</a></code></li>
<li><code><a title="DAVE.scene.Axis.ry" href="#DAVE.scene.Axis.ry">ry</a></code></li>
<li><code><a title="DAVE.scene.Axis.rz" href="#DAVE.scene.Axis.rz">rz</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_fixed" href="#DAVE.scene.Axis.set_fixed">set_fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_free" href="#DAVE.scene.Axis.set_free">set_free</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_direction" href="#DAVE.scene.Axis.to_glob_direction">to_glob_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_position" href="#DAVE.scene.Axis.to_glob_position">to_glob_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_rotation" href="#DAVE.scene.Axis.to_glob_rotation">to_glob_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_direction" href="#DAVE.scene.Axis.to_loc_direction">to_loc_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_position" href="#DAVE.scene.Axis.to_loc_position">to_loc_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_rotation" href="#DAVE.scene.Axis.to_loc_rotation">to_loc_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.x" href="#DAVE.scene.Axis.x">x</a></code></li>
<li><code><a title="DAVE.scene.Axis.y" href="#DAVE.scene.Axis.y">y</a></code></li>
<li><code><a title="DAVE.scene.Axis.z" href="#DAVE.scene.Axis.z">z</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>filename=None, copy_from=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A Scene is the main component of virtual-float.</p>
<p>It provides a world to place nodes (elements) in.
It interfaces with the virtual-float core for all calculations.</p>
<p>_vfc : DAVE Core</p>
<p>Creates a new Scene</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>(str or Path) Insert contents from this file into the newly created scene</dd>
<dt><strong><code>copy_from</code></strong></dt>
<dd>(Scene) Copy nodes from this other scene into the newly created scene</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene:
    &#34;&#34;&#34;
    A Scene is the main component of virtual-float.

    It provides a world to place nodes (elements) in.
    It interfaces with the virtual-float core for all calculations.

    _vfc : DAVE Core
    &#34;&#34;&#34;

    def __init__(self, filename = None, copy_from = None):
        &#34;&#34;&#34;Creates a new Scene

        Args:
            filename: (str or Path) Insert contents from this file into the newly created scene
            copy_from:  (Scene) Copy nodes from this other scene into the newly created scene
        &#34;&#34;&#34;

        self.verbose = True
        &#34;&#34;&#34;Report actions using print()&#34;&#34;&#34;

        self._vfc = pyo3d.Scene()
        &#34;&#34;&#34;_vfc : DAVE Core, where the actual magic happens&#34;&#34;&#34;

        self._nodes = []
        &#34;&#34;&#34;Contains a list of all nodes in the scene&#34;&#34;&#34;

        self.static_tolerance = 0.01
        &#34;&#34;&#34;Desired tolerance when solving statics&#34;&#34;&#34;

        self.resources_paths = []
        &#34;&#34;&#34;A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.&#34;&#34;&#34;
        self.resources_paths.extend(vfc.RESOURCE_PATH)


        self._name_prefix = &#34;&#34;
        &#34;&#34;&#34;An optional prefix to be applied to node names. Used when importing scenes.&#34;&#34;&#34;

        if filename is not None:
            self.load_scene(filename)

        if copy_from is not None:
            self.import_scene(copy_from, containerize=False)

    def clear(self):
        &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

        self._nodes = []
        del self._vfc
        self._vfc = pyo3d.Scene()


    # =========== private functions =============
    def _print(self,what):
        if self.verbose:
            print(what)

    def _prefix_name(self, name):
        return self._name_prefix + name

    def _verify_name_available(self, name):
        &#34;&#34;&#34;Throws an error if a node with name &#39;name&#39; already exists&#34;&#34;&#34;
        if name in self._vfc.names:
            raise Exception(&#34;The name &#39;{}&#39; is already in use. Pick a unique name&#34;.format(name))

    def _node_from_node_or_str(self, node):
        &#34;&#34;&#34;If node is a string, then returns the node with that name,
        if node is a node, then returns that node

        Raises:
            ValueError if a string is passed with an non-existing node
        &#34;&#34;&#34;

        if isinstance(node, Node):
            return node
        if isinstance(node, str):
            return self[node]
        raise ValueError(&#39;Node should be a Node or a string, not a {}&#39;.format(type(node)))

    def _node_from_node(self, node, reqtype):
        &#34;&#34;&#34;Gets a node from the specified type

        Returns None if node is None
        Returns node if node is already a reqtype type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        if node is None:
            return None

        # node is a string then get the node with this name
        if type(node) == str:
            node = self[self._name_prefix + node]

        reqtype = make_iterable(reqtype)

        for r in reqtype:
            if isinstance(node, r):
                return node

        if issubclass(type(node), Node):
            raise Exception(
                &#34;Element with name {} can not be used , it should be a {} or derived type but is a {}.&#34;.format(
                    node.name, reqtype, type(node)))

        raise Exception(&#39;This is not an acceptable input argument {}&#39;.format(node))

    def _parent_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an axis type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        return self._node_from_node(node, Axis)

    def _poi_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Poi)

    def _poi_or_sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, [Poi, Sheave])

    def _geometry_changed(self):
        &#34;&#34;&#34;Notify the scene that the geometry has changed and that the global transforms are invalid&#34;&#34;&#34;
        self._vfc.geometry_changed()

    # ======== resources =========

    def get_resource_path(self, name):
        &#34;&#34;&#34;Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
        that is found.
        If name is a full path to an existing file, then that is returned.

        See Also:
            resource_paths


        Returns:
            Full path to resource

        Raises:
            FileExistsError if resource is not found

        &#34;&#34;&#34;

        if isfile(name):
            return name

        for res in self.resources_paths:
            p = Path(res)

            full = p / name
            if isfile(full):
                return full

        # prepare feedback for error
        ext = str(name).split(&#39;.&#39;)[-1]  # everything after the last .

        print(&#34;The following resources with extension {} are available with &#34;.format(ext))
        available = self.get_resource_list(ext)
        for a in available:
            print(a)

        raise FileExistsError(&#39;Resource &#34;{}&#34; not found in resource paths&#39;.format(name))

    def get_resource_list(self, extension):
        &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

        r = []

        for dir in self.resources_paths:
            try:
                files = listdir(dir)
                for file in files:
                    if file.endswith(extension):
                        if file not in r:
                            r.append(file)
            except FileNotFoundError:
                pass

        return r



    # ======== element functions =========

    def node_by_name(self, node_name):
        for N in self._nodes:
            if N.name == node_name:
                return N

        self.print_node_tree()
        raise ValueError(&#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name))

    def __getitem__(self, node_name):
        &#34;&#34;&#34;Returns a node with name&#34;&#34;&#34;
        return self.node_by_name(node_name)

    def nodes_of_type(self, node_class):
        &#34;&#34;&#34;Returns all nodes of the specified type

        Examples:
            pois = scene.nodes_of_type(DAVE.Poi)
        &#34;&#34;&#34;
        r = list()
        for n in self._nodes:
            if isinstance(n, node_class):
                r.append(n)
        return r

    def sort_nodes_by_dependency(self):
        &#34;&#34;&#34;Sorts the nodes such that a node only depends on nodes earlier in the list.&#34;&#34;&#34;

        self._vfc.state_update()  # use the function from the core.
        new_list = []
        for name in self._vfc.names:  # and then build a new list using the names
            if vfc.VF_NAME_SPLIT in name:
                continue
            new_list.append(self[name])

        # and add the nodes without a vfc-core connection
        for node in self._nodes:
            if not node in new_list:
                new_list.append(node)

        self._nodes = new_list

    def name_available(self, name):
        &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        return not (name in names)

    def available_name_like(self, like):
        &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
        if self.name_available(like):
            return like
        counter = 1
        while True:
            name = like + &#39;_&#39; + str(counter)
            if self.name_available(name):
                return name
            counter += 1

    def nodes_depending_on(self, node):
        &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
        This function should be used to determine dependencies of Core-connected elements.

        For making node-trees please use nodes_with_parent instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_with_parent
        &#34;&#34;&#34;

        if isinstance(node, Node):
            node = node.name

        # check the node type
        _node = self[node]
        if not isinstance(_node, CoreConnectedNode):
            return []
        else:
            names =  self._vfc.elements_depending_on(node)

        r = []
        for name in names:
            try:
                r.append(self[name].name)
            except:
                pass

        # check visuals as well (which are not core-connected)
        for v in self.nodes_of_type(Visual):
            if v.parent is _node:
                r.append(v.name)

        return r

    def nodes_with_parent(self, node):
        &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
        For checking physical connections use nodes_depending_on instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_depending_on
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        r = []

        for n in self._nodes:

            try:
                parent = n.parent
            except AttributeError:
                continue

            if parent == node:
                r.append(n.name)

        return r



    def delete(self, node):
        &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

        See Also:
            dissolve
        &#34;&#34;&#34;

        depending_nodes = self.nodes_depending_on(node)

        if isinstance(node, str):
            node = self[node]

        self._print(&#39;Deleting {} [{}]&#39;.format(node.name, str(type(node)).split(&#39;.&#39;)[-1][:-2]))

        # remove the vtk node
        self._print(&#39;removing vfc node&#39;)
        node._delete_vfc()
        self._nodes.remove(node)

        # then delete the dependencies

        for d in depending_nodes:
            if not self.name_available(d):  # element is still here
                self.delete(d)


    def dissolve(self, node):
        &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

        1. Look for nodes that have this node as parent
        2. Attach those nodes to the parent of this node.
        3. Delete this node.

        There are many situations in which this will fail because an it is impossible to dissolve
        the element. For example a poi can only be dissolved when nothing is attached to it.

        For now this function only works on AXIS

        &#34;&#34;&#34;

        if isinstance(node, str):
            node=  self[node]

        if not type(node) == Axis:
            raise TypeError(&#39;Only nodes of type Axis can be dissolved at this moment&#39;)

        for d in self.nodes_depending_on(node):
            self[d].change_parent_to(node.parent)

        self.delete(node)



    # ========= The most important function ========

    def solve_statics(self, silent=False):
        &#34;&#34;&#34;Solves statics

        Args:
            silent: Do not print if successfully solved

        Returns:
            bool: True if successful, False otherwise.

        &#34;&#34;&#34;
        succes = self._vfc.state_solve_statics()

        if self.verify_equilibrium():
            if not silent:
                self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
            return True

        d = np.array(self._vfc.get_dofs())
        if np.any(np.abs(d)&gt;2000):
            print(&#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;)
            return False

        return False

    def verify_equilibrium(self, tol = 1e-2):
        &#34;&#34;&#34;Checks if the current state is an equilibrium

        Returns:
            bool: True if successful, False if not an equilibrium.

        &#34;&#34;&#34;
        return (self._vfc.Emaxabs &lt; tol)



    # ====== goal seek ========

    def goal_seek(self, set_node, set_property, target, change_node, change_property, bracket=None, tol=1e-3):
        &#34;&#34;&#34;goal_seek

        Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
        some property of some node to a specified value. Just like excel.

        Args:
            set_node (Node or str):     node to be evaluated
            set_property (str): property of that node to be evaluated
            target (number):       target value for that property
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            range(optional)  : specify the possible search-interval

        Returns:
            bool: True if successful, False otherwise.

        Examples:
            Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
            &gt;&gt;&gt; s.goal_seek(&#39;Barge&#39;,&#39;rx&#39;,0,&#39;Barge&#39;,&#39;cogy&#39;)

        &#34;&#34;&#34;

        set_node = self._node_from_node_or_str(set_node)
        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = getattr(set_node, set_property)
        self._print(&#39;Attempting to set {}.{} to {} (now {})&#39;.format(set_node.name, set_property, target, test))

        initial = getattr(change_node, change_property)
        self._print(&#39;By changing the value of {}.{} (now {})&#39;.format(change_node.name, change_property, initial))

        def set_and_get(x):
            setattr(change_node, change_property,x)
            self.solve_statics(silent=True)
            result = getattr(set_node, set_property)
            self._print(&#39;setting {} results in {}&#39;.format(x,result))
            return result-target

        from scipy.optimize import root_scalar
        x0 = initial
        x1 = initial+0.0001

        if bracket is not None:
            res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket,xtol = tol)
        else:
            res = root_scalar(set_and_get, x0=x0, x1=x1,xtol = tol)

        self._print(res)

        # evaluate result
        final_value = getattr(set_node, set_property)
        if abs(final_value-target) &gt; 1e-3:
            raise ValueError(&#34;Target not reached. Target was {}, reached value is {}&#34;.format(target, final_value))


        return True




    # ======== create functions =========

    def new_axis(self, name, parent=None, position=None, rotation=None, fixed = True):
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Returns:
            Reference to newly created axis

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)



        # then create
        a = self._vfc.new_axis(name)

        new_node = Axis(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position
        if rotation is not None:
            new_node.rotation = rotation

        if isinstance(fixed, bool):
            if fixed:
                new_node.set_fixed()
            else:
                new_node.set_free()
        else:
            new_node.fixed = fixed


        self._nodes.append(new_node)
        return new_node

    def new_visual(self, name, path, parent=None, offset=None, rotation=None, scale = None):
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the resource
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            scale : optional, scale of the visual (x,y,z).

        Returns:
            Reference to newly created visual

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        self.get_resource_path(path) # raises error when resource is not found


        # then create

        new_node = Visual(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        if b is not None:
            new_node.parent = b
        if offset is not None:
            new_node.offset = offset
        if rotation is not None:
            new_node.rotation = rotation
        if scale is not None:
            new_node.scale = scale

        self._nodes.append(new_node)
        return new_node


    def new_poi(self, name, parent=None, position=None):
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)


        Returns:
            Reference to newly created poi

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)

        # then create
        a = self._vfc.new_poi(name)

        new_node = Poi(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position

        self._nodes.append(new_node)
        return new_node

    def new_rigidbody(self, name, mass=0, cog=(0, 0, 0),
                      parent=None, position=None, rotation=None, fixed = True ):
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            mass: optional, [0] mass in mT
            cog: optional, (0,0,0) cog-position in (m,m,m)
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Examples:
            scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

        Returns:
            Reference to newly created RigidBody

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)


        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a
        p.position = cog

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p
        g.force = (0, 0, -vfc.G * mass)

        r = RigidBody(self, a, p, g)

        # and set properties
        if b is not None:
            r.parent = b
        if position is not None:
            r.position = position
        if rotation is not None:
            r.rotation = rotation

        if isinstance(fixed, bool):
            if fixed:
                r.set_fixed()
            else:
                r.set_free()
        else:
            r.fixed = fixed

        self._nodes.append(r)
        return r

    def new_cable(self, name, poiA, poiB, length=-1, EA=0, diameter=0, sheaves=None):
        &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            poiA : A Poi element to connect the first end of the cable to
            poiB : A Poi element to connect the other end of the cable to
            length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
            EA [0] : stiffness of the cable in kN/m; default

            sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from poiA to poiB

        Examples:

            scene.new_cable(&#39;cable_name&#39; poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;)  # minimal use

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=poi_start, poiB = poi_end, sheaves=[sheave1, sheave2])

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

        Notes:
            The default options for length and EA can be used to measure distances between points

        Returns:
            Reference to newly created Cable

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        assert1f(length, &#39;length&#39;)
        assert1f(EA, &#39;EA&#39;)

        poiA = self._poi_from_node(poiA)
        poiB = self._poi_from_node(poiB)

        pois = [poiA]
        if sheaves is not None:

            if isinstance(sheaves, Poi): # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, Sheave): # single sheave as poi or string
                sheaves = [sheaves]


            if isinstance(sheaves, str):
                sheaves = [sheaves]


            for s in sheaves:
                # s may be a poi or a sheave
                pois.append(self._poi_or_sheave_from_node(s))


        pois.append(poiB)

        # default options
        if length == -1:
            length = np.linalg.norm(np.array(poiA.global_position) - np.array(poiB.global_position))

            if length&lt;1e-9:
                raise Exception(&#39;Length not provided and endpoints are at the same global position. Can not determine a suitable default length (&gt;0)&#39;)



        # more checks
        if length&lt;1e-9:
            raise Exception(&#39;Length should be more than 0&#39;)

        if EA&lt;0:
            raise Exception(&#39;EA should be more than 0&#39;)

        assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

        if diameter&lt;0:
            raise Exception(&#34;Diameter should be &gt;= 0&#34;)

        # then create
        a = self._vfc.new_cable(name)
        new_node = Cable(self, a)
        new_node.length = length
        new_node.EA = EA
        new_node.diameter = diameter

        for poi in pois:
            new_node.add_connection(poi)

        # and add to the scene
        self._nodes.append(new_node)
        return new_node

    def new_force(self, name, parent=None, force=None, moment=None):
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        if force is not None:
            assert3f(force, &#34;Force &#34;)

        if moment is not None:
            assert3f(moment, &#34;Moment &#34;)


        # then create
        a = self._vfc.new_force(name)

        new_node = Force(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if force is not None:
            new_node.force = force
        if moment is not None:
            new_node.moment = moment

        self._nodes.append(new_node)
        return new_node

    def new_sheave(self, name, parent, axis, radius=0):
        &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            axis: direction of the axis of rotation (x,y,z)
            radius: optional, radius of the sheave


        Returns:
            Reference to newly created sheave

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert3f(axis, &#34;Axis of rotation &#34;)

        assert1f(radius, &#34;Radius of sheave&#34;)

        # then create
        a = self._vfc.new_sheave(name)

        new_node = Sheave(self, a)

        # and set properties
        new_node.parent = b
        new_node.axis = axis
        new_node.radius = radius

        self._nodes.append(new_node)
        return new_node

    def new_hydspring(self, name, parent, cob,
                      BMT, BML, COFX, COFY, kHeave, waterline, displacement_kN):
        &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            cob: position of the CoB (x,y,z) in the parent axis system
            BMT: Vertical distance between CoB and meta-center for roll
            BML: Vertical distance between CoB and meta-center for pitch
            COFX: X-location of center of flotation (center of waterplane) relative to CoB
            COFY: Y-location of center of flotation (center of waterplane) relative to CoB
            kHeave : heave stiffness (typically Awl * rho * g)
            waterline : Z-position (elevation) of the waterline relative to CoB
            displacement_kN : displacement (typically volume * rho * g)


        Returns:
            Reference to newly created hydrostatic spring

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)
        assert3f(cob, &#34;CoB &#34;)
        assert1f(BMT, &#34;BMT &#34;)
        assert1f(BML, &#34;BML &#34;)
        assert1f(COFX, &#34;COFX &#34;)
        assert1f(COFY, &#34;COFY &#34;)
        assert1f(kHeave, &#34;kHeave &#34;)
        assert1f(waterline, &#34;waterline &#34;)
        assert1f(displacement_kN, &#34;displacement_kN &#34;)

        # then create
        a = self._vfc.new_hydspring(name)
        new_node = HydSpring(self, a)

        new_node.cob = cob
        new_node.parent = b
        new_node.BMT = BMT
        new_node.BML = BML
        new_node.COFX = COFX
        new_node.COFY = COFY
        new_node.kHeave = kHeave
        new_node.waterline = waterline
        new_node.displacement_kN = displacement_kN

        self._nodes.append(new_node)

        return new_node

    def new_linear_connector_6d(self, name, slave, master, stiffness = None):
        &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]
            stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

        See :py:class:`LC6d` for details

        Returns:
            Reference to newly created connector

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        if stiffness is not None:
            assert6f(stiffness, &#34;Stiffness &#34;)
        else:
            stiffness = (0,0,0,0,0,0)

        # then create
        a = self._vfc.new_linearconnector6d(name)

        new_node = LC6d(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.stiffness = stiffness

        self._nodes.append(new_node)
        return new_node

    def new_connector2d(self, name, master, slave, k_linear=0, k_angular=0):
        &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]

            k_linear : linear stiffness in kN/m
            k_angular : angular stiffness in kN*m / rad

        Returns:
            Reference to newly created connector2d

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        assert1f(k_linear, &#34;Linear stiffness&#34;)
        assert1f(k_angular, &#34;Angular stiffness&#34;)

        # then create
        a = self._vfc.new_connector2d(name)

        new_node = Connector2d(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.k_linear = k_linear
        new_node.k_angular = k_angular

        self._nodes.append(new_node)
        return new_node

    def new_linear_beam(self, name, master, slave, EIy=0, EIz=0, GIp=0, EA=0, L=None):
        &#34;&#34;&#34;Creates a new *linear beam* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            slave: Slaved axis system [Axis]
            master: Master axis system [Axis]

            All stiffness terms default to 0
            The length defaults to the distance between master and slave


        See :py:class:`LinearBeam` for details

        Returns:
            Reference to newly created beam

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        m = self._parent_from_node(master)
        s = self._parent_from_node(slave)

        if L is None:
            L = np.linalg.norm(np.array(m.global_position)- np.array(s.global_position))
        else:
            if L &lt;= 0:
                raise ValueError(&#39;L should be &gt; 0 as stiffness is defined per length.&#39;)


        # then create
        a = self._vfc.new_linearbeam(name)

        new_node = LinearBeam(self, a)

        # and set properties
        new_node.master = m
        new_node.slave = s
        new_node.EIy = EIy
        new_node.EIz = EIz
        new_node.GIp = GIp
        new_node.EA = EA
        new_node.L = L

        self._nodes.append(new_node)
        return new_node


    def new_buoyancy(self, name, parent=None):
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            trimesh: optional, TriMesh object


        Returns:
            Reference to newly created buoyancy

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        # then create
        a = self._vfc.new_buoyancy(name)
        new_node = Buoyancy(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        self._nodes.append(new_node)
        return new_node

    def print_python_code(self):
        &#34;&#34;&#34;Prints the python code that generates the current scene

        See also: give_python_code
        &#34;&#34;&#34;
        for line in self.give_python_code().split(&#39;\n&#39;):
            print(line)

    def give_python_code(self):
        &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

        import datetime
        import getpass

        self.sort_nodes_by_dependency()

        code = &#34;# auto generated pyhton code&#34;
        try:
            code += &#34;\n# By {}&#34;.format(getpass.getuser())
        except:
            code += &#34;\n# By an unknown&#34;

        code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#39;.&#39;)[0])

        code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
        code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
        code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
        code += &#34;\ndef solved(number):\n    return number\n&#34;

        for n in self._nodes:
            code += &#39;\n&#39; + n.give_python_code()

        return code

    def save_scene(self, filename):
        &#34;&#34;&#34;Saves the scene to a file

        This saves the scene in its current state to a file.
        Opening the saved file will reproduce exactly this scene.

        This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
        This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
        So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
        the results of that update will not be reflected in the saved model.

        If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

        Args:
            filename : filename or file-path to save the file. Default extension is .dave_asset

        Returns:
            the full path to the saved file

        &#34;&#34;&#34;

        code = self.give_python_code()

        filename = Path(filename)

        # add .dave_asset extension
        if filename.suffix != &#39;.dave_asset&#39;:
            filename = Path(str(filename) + &#39;.dave_asset&#39;)

        # add path if not provided
        if not filename.is_absolute():
            try:
                filename = Path(self.resources_paths[-1]) / filename
            except:
                pass # save in current folder

        # make sure directory exists
        directory = filename.parent
        if not directory.exists():
            directory.mkdir()


        f = open(filename,&#39;w+&#39;)
        f.write(code)
        f.close()

        self._print(&#39;Saved as {}&#39;.format(filename))

        return filename

    def print_node_tree(self):

        self.sort_nodes_by_dependency()

        to_be_printed = []
        for n in self._nodes:
            to_be_printed.append(n.name)

        # to_be_printed.reverse()

        def print_deps(name, spaces):

            node = self[name]
            deps = self.nodes_with_parent(node)
            print(spaces + name + &#39; [&#39; + str(type(node)).split(&#39;.&#39;)[-1][:-2] + &#39;]&#39;)

            if deps is not None:
                for dep in deps:
                    if spaces == &#34;&#34;:
                        spaces_plus = &#39; |-&gt; &#39;
                    else:
                        spaces_plus = &#39; |   &#39; + spaces
                    print_deps(dep, spaces_plus)

            to_be_printed.remove(name)

        while to_be_printed:
            name = to_be_printed[0]
            print_deps(name, &#39;&#39;)

    def load_scene(self, filename = None):
        &#34;&#34;&#34;Loads the contents of filename into the current scene.

        This function is typically used on an empty scene.

        Filename is appended with .dave_asset if needed.
        File is searched for in the resource-paths.

        See also: import scene&#34;&#34;&#34;

        if filename is None:
            raise Exception(&#39;Please provide a file-name&#39;)

        filename = Path(filename)

        if filename.suffix != &#39;.dave_asset&#39;:
            filename = Path(str(filename) + &#39;.dave_asset&#39;)

        filename = self.get_resource_path(filename)

        print(&#39;Loading {}&#39;.format(filename))

        f = open(file=filename, mode = &#39;r&#39;)
        s = self
        code = &#39;&#39;

        for line in f:
            code += line + &#39;\n&#39;

        exec(code, {}, {&#39;s&#39;: s})


    def import_scene(self, other, prefix = &#34;&#34;, containerize = True):
        &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

        To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

        Returns:
            Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
        &#34;&#34;&#34;

        if isinstance(other, Path):
            other = str(other)

        if isinstance(other, str):
            other = Scene(other)

        if not isinstance(other, Scene):
            raise TypeError(&#39;Other should be a Scene but is a &#39; + str(type(other)))

        old_prefix = self._name_prefix
        imported_element_names = []

        for n in other._nodes:
            imported_element_names.append(prefix + n.name)


        # check for double names

        for new_node_name in imported_element_names:
            if not self.name_available(new_node_name):
                raise NameError(&#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(new_node_name))


        self._name_prefix = prefix

        code = other.give_python_code()

        s = self
        exec(code)

        self._name_prefix = old_prefix # restore

        # Move all imported elements without a parent into a newly created axis system
        if containerize:

            container_name = s.available_name_like(&#39;import_container&#39;)

            c = self.new_axis(prefix + container_name)

            for name in imported_element_names:

                node = self[name]
                if not isinstance(node, NodeWithParent):
                    continue

                if node.parent is None:
                    node.change_parent_to(c)

            return c

        return None</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Scene._name_prefix"><code class="name">var <span class="ident">_name_prefix</span></code></dt>
<dd>
<section class="desc"><p>An optional prefix to be applied to node names. Used when importing scenes.</p></section>
</dd>
<dt id="DAVE.scene.Scene._nodes"><code class="name">var <span class="ident">_nodes</span></code></dt>
<dd>
<section class="desc"><p>Contains a list of all nodes in the scene</p></section>
</dd>
<dt id="DAVE.scene.Scene._vfc"><code class="name">var <span class="ident">_vfc</span></code></dt>
<dd>
<section class="desc"><p>_vfc : DAVE Core, where the actual magic happens</p></section>
</dd>
<dt id="DAVE.scene.Scene.resources_paths"><code class="name">var <span class="ident">resources_paths</span></code></dt>
<dd>
<section class="desc"><p>A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.</p></section>
</dd>
<dt id="DAVE.scene.Scene.static_tolerance"><code class="name">var <span class="ident">static_tolerance</span></code></dt>
<dd>
<section class="desc"><p>Desired tolerance when solving statics</p></section>
</dd>
<dt id="DAVE.scene.Scene.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<section class="desc"><p>Report actions using print()</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Scene.available_name_like"><code class="name flex">
<span>def <span class="ident">available_name_like</span></span>(<span>self, like)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an available name like the one given, for example Axis23</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_name_like(self, like):
    &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
    if self.name_available(like):
        return like
    counter = 1
    while True:
        name = like + &#39;_&#39; + str(counter)
        if self.name_available(name):
            return name
        counter += 1</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes all nodes</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

    self._nodes = []
    del self._vfc
    self._vfc = pyo3d.Scene()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes the given node from the scene as well as all nodes depending on it.</p>
<p>See Also:
dissolve</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, node):
    &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

    See Also:
        dissolve
    &#34;&#34;&#34;

    depending_nodes = self.nodes_depending_on(node)

    if isinstance(node, str):
        node = self[node]

    self._print(&#39;Deleting {} [{}]&#39;.format(node.name, str(type(node)).split(&#39;.&#39;)[-1][:-2]))

    # remove the vtk node
    self._print(&#39;removing vfc node&#39;)
    node._delete_vfc()
    self._nodes.remove(node)

    # then delete the dependencies

    for d in depending_nodes:
        if not self.name_available(d):  # element is still here
            self.delete(d)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dissolve"><code class="name flex">
<span>def <span class="ident">dissolve</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to delete the given node without affecting the rest of the model.</p>
<ol>
<li>Look for nodes that have this node as parent</li>
<li>Attach those nodes to the parent of this node.</li>
<li>Delete this node.</li>
</ol>
<p>There are many situations in which this will fail because an it is impossible to dissolve
the element. For example a poi can only be dissolved when nothing is attached to it.</p>
<p>For now this function only works on AXIS</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissolve(self, node):
    &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

    1. Look for nodes that have this node as parent
    2. Attach those nodes to the parent of this node.
    3. Delete this node.

    There are many situations in which this will fail because an it is impossible to dissolve
    the element. For example a poi can only be dissolved when nothing is attached to it.

    For now this function only works on AXIS

    &#34;&#34;&#34;

    if isinstance(node, str):
        node=  self[node]

    if not type(node) == Axis:
        raise TypeError(&#39;Only nodes of type Axis can be dissolved at this moment&#39;)

    for d in self.nodes_depending_on(node):
        self[d].change_parent_to(node.parent)

    self.delete(node)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.get_resource_list"><code class="name flex">
<span>def <span class="ident">get_resource_list</span></span>(<span>self, extension)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of all file-paths (strings) given extension in any of the resource-paths</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_list(self, extension):
    &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

    r = []

    for dir in self.resources_paths:
        try:
            files = listdir(dir)
            for file in files:
                if file.endswith(extension):
                    if file not in r:
                        r.append(file)
        except FileNotFoundError:
            pass

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.get_resource_path"><code class="name flex">
<span>def <span class="ident">get_resource_path</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Looks for a file with "name" in the specified resource-paths and returns the full path to the the first one
that is found.
If name is a full path to an existing file, then that is returned.</p>
<p>See Also:
resource_paths</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Full</code> <code>path</code> <code>to</code> <code>resource</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code> <code>if</code> <code>resource</code> <code>is</code> <code>not</code> <code>found</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_path(self, name):
    &#34;&#34;&#34;Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
    that is found.
    If name is a full path to an existing file, then that is returned.

    See Also:
        resource_paths


    Returns:
        Full path to resource

    Raises:
        FileExistsError if resource is not found

    &#34;&#34;&#34;

    if isfile(name):
        return name

    for res in self.resources_paths:
        p = Path(res)

        full = p / name
        if isfile(full):
            return full

    # prepare feedback for error
    ext = str(name).split(&#39;.&#39;)[-1]  # everything after the last .

    print(&#34;The following resources with extension {} are available with &#34;.format(ext))
    available = self.get_resource_list(ext)
    for a in available:
        print(a)

    raise FileExistsError(&#39;Resource &#34;{}&#34; not found in resource paths&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.give_python_code"><code class="name flex">
<span>def <span class="ident">give_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates the python code that rebuilds the scene and elements in its current state.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_python_code(self):
    &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

    import datetime
    import getpass

    self.sort_nodes_by_dependency()

    code = &#34;# auto generated pyhton code&#34;
    try:
        code += &#34;\n# By {}&#34;.format(getpass.getuser())
    except:
        code += &#34;\n# By an unknown&#34;

    code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#39;.&#39;)[0])

    code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
    code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
    code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
    code += &#34;\ndef solved(number):\n    return number\n&#34;

    for n in self._nodes:
        code += &#39;\n&#39; + n.give_python_code()

    return code</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.goal_seek"><code class="name flex">
<span>def <span class="ident">goal_seek</span></span>(<span>self, set_node, set_property, target, change_node, change_property, bracket=None, tol=0.001)</span>
</code></dt>
<dd>
<section class="desc"><p>goal_seek</p>
<p>Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
some property of some node to a specified value. Just like excel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>set_node</code></strong> :&ensp;<a title="DAVE.scene.Node" href="#DAVE.scene.Node"><code>Node</code></a> or <code>str</code></dt>
<dd>
<p>node to be evaluated</p>
</dd>
<dt><strong><code>set_property</code></strong> :&ensp;<code>str</code></dt>
<dd>property of that node to be evaluated</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>number</code></dt>
<dd>
<p>target value for that property</p>
</dd>
<dt>change_node(Node or str):
node to be adjusted</dt>
<dt><strong><code>change_property</code></strong> :&ensp;<code>str</code></dt>
<dd>property of that node to be adjusted</dd>
</dl>
<p>range(optional)
: specify the possible search-interval</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if successful, False otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Change the y-position of the cog of a rigid body ('Barge')
in order to obtain zero roll (rx)</p>
<pre><code>&gt;&gt;&gt; s.goal_seek('Barge','rx',0,'Barge','cogy')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goal_seek(self, set_node, set_property, target, change_node, change_property, bracket=None, tol=1e-3):
    &#34;&#34;&#34;goal_seek

    Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
    some property of some node to a specified value. Just like excel.

    Args:
        set_node (Node or str):     node to be evaluated
        set_property (str): property of that node to be evaluated
        target (number):       target value for that property
        change_node(Node or str):  node to be adjusted
        change_property (str): property of that node to be adjusted
        range(optional)  : specify the possible search-interval

    Returns:
        bool: True if successful, False otherwise.

    Examples:
        Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
        &gt;&gt;&gt; s.goal_seek(&#39;Barge&#39;,&#39;rx&#39;,0,&#39;Barge&#39;,&#39;cogy&#39;)

    &#34;&#34;&#34;

    set_node = self._node_from_node_or_str(set_node)
    change_node = self._node_from_node_or_str(change_node)

    # check that the attributes exist and are single numbers
    test = getattr(set_node, set_property)
    self._print(&#39;Attempting to set {}.{} to {} (now {})&#39;.format(set_node.name, set_property, target, test))

    initial = getattr(change_node, change_property)
    self._print(&#39;By changing the value of {}.{} (now {})&#39;.format(change_node.name, change_property, initial))

    def set_and_get(x):
        setattr(change_node, change_property,x)
        self.solve_statics(silent=True)
        result = getattr(set_node, set_property)
        self._print(&#39;setting {} results in {}&#39;.format(x,result))
        return result-target

    from scipy.optimize import root_scalar
    x0 = initial
    x1 = initial+0.0001

    if bracket is not None:
        res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket,xtol = tol)
    else:
        res = root_scalar(set_and_get, x0=x0, x1=x1,xtol = tol)

    self._print(res)

    # evaluate result
    final_value = getattr(set_node, set_property)
    if abs(final_value-target) &gt; 1e-3:
        raise ValueError(&#34;Target not reached. Target was {}, reached value is {}&#34;.format(target, final_value))


    return True</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.import_scene"><code class="name flex">
<span>def <span class="ident">import_scene</span></span>(<span>self, other, prefix='', containerize=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy-paste all nodes of scene "other" into current scene.</p>
<p>To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.</p>
<h2 id="returns">Returns</h2>
<p>Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_scene(self, other, prefix = &#34;&#34;, containerize = True):
    &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

    To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

    Returns:
        Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
    &#34;&#34;&#34;

    if isinstance(other, Path):
        other = str(other)

    if isinstance(other, str):
        other = Scene(other)

    if not isinstance(other, Scene):
        raise TypeError(&#39;Other should be a Scene but is a &#39; + str(type(other)))

    old_prefix = self._name_prefix
    imported_element_names = []

    for n in other._nodes:
        imported_element_names.append(prefix + n.name)


    # check for double names

    for new_node_name in imported_element_names:
        if not self.name_available(new_node_name):
            raise NameError(&#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(new_node_name))


    self._name_prefix = prefix

    code = other.give_python_code()

    s = self
    exec(code)

    self._name_prefix = old_prefix # restore

    # Move all imported elements without a parent into a newly created axis system
    if containerize:

        container_name = s.available_name_like(&#39;import_container&#39;)

        c = self.new_axis(prefix + container_name)

        for name in imported_element_names:

            node = self[name]
            if not isinstance(node, NodeWithParent):
                continue

            if node.parent is None:
                node.change_parent_to(c)

        return c

    return None</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.load_scene"><code class="name flex">
<span>def <span class="ident">load_scene</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads the contents of filename into the current scene.</p>
<p>This function is typically used on an empty scene.</p>
<p>Filename is appended with .dave_asset if needed.
File is searched for in the resource-paths.</p>
<p>See also: import scene</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_scene(self, filename = None):
    &#34;&#34;&#34;Loads the contents of filename into the current scene.

    This function is typically used on an empty scene.

    Filename is appended with .dave_asset if needed.
    File is searched for in the resource-paths.

    See also: import scene&#34;&#34;&#34;

    if filename is None:
        raise Exception(&#39;Please provide a file-name&#39;)

    filename = Path(filename)

    if filename.suffix != &#39;.dave_asset&#39;:
        filename = Path(str(filename) + &#39;.dave_asset&#39;)

    filename = self.get_resource_path(filename)

    print(&#39;Loading {}&#39;.format(filename))

    f = open(file=filename, mode = &#39;r&#39;)
    s = self
    code = &#39;&#39;

    for line in f:
        code += line + &#39;\n&#39;

    exec(code, {}, {&#39;s&#39;: s})</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.name_available"><code class="name flex">
<span>def <span class="ident">name_available</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if the name is still available</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name_available(self, name):
    &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
    names = [n.name for n in self._nodes]
    names.extend(self._vfc.names)
    return not (name in names)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_axis"><code class="name flex">
<span>def <span class="ident">new_axis</span></span>(<span>self, name, parent=None, position=None, rotation=None, fixed=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>axis</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
</dl>
<p>fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>axis</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_axis(self, name, parent=None, position=None, rotation=None, fixed = True):
    &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

    Returns:
        Reference to newly created axis

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    if not isinstance(fixed, bool):
        if len(fixed) != 6:
            raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)



    # then create
    a = self._vfc.new_axis(name)

    new_node = Axis(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if position is not None:
        new_node.position = position
    if rotation is not None:
        new_node.rotation = rotation

    if isinstance(fixed, bool):
        if fixed:
            new_node.set_fixed()
        else:
            new_node.set_free()
    else:
        new_node.fixed = fixed


    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_buoyancy"><code class="name flex">
<span>def <span class="ident">new_buoyancy</span></span>(<span>self, name, parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>poi</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>trimesh</code></strong></dt>
<dd>optional, TriMesh object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>buoyancy</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_buoyancy(self, name, parent=None):
    &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node
        trimesh: optional, TriMesh object


    Returns:
        Reference to newly created buoyancy

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    # then create
    a = self._vfc.new_buoyancy(name)
    new_node = Buoyancy(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_cable"><code class="name flex">
<span>def <span class="ident">new_cable</span></span>(<span>self, name, poiA, poiB, length=-1, EA=0, diameter=0, sheaves=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>cable</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>poiA</code></strong> :&ensp;<code>A</code> <a title="DAVE.scene.Poi" href="#DAVE.scene.Poi"><code>Poi</code></a> <code>element</code> <code>to</code> <code>connect</code> <code>the</code> <code>first</code> <code>end</code> of <code>the</code> <code>cable</code> <code>to</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>poiB</code></strong> :&ensp;<code>A</code> <a title="DAVE.scene.Poi" href="#DAVE.scene.Poi"><code>Poi</code></a> <code>element</code> <code>to</code> <code>connect</code> <code>the</code> <code>other</code> <code>end</code> of <code>the</code> <code>cable</code> <code>to</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
EA [0] : stiffness of the cable in kN/m; default</p>
<dl>
<dt><strong><code>sheaves</code></strong> :&ensp;[optional] <code>A</code> <code>list</code> of <code>pois</code>, <code>these</code> <code>are</code> <code>sheaves</code> <code>that</code> <code>the</code> <code>cable</code> <code>runs</code> <code>over.</code> <code>Defined</code> <code>from</code> <code>poiA</code> <code>to</code> <code>poiB</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>scene.new_cable('cable_name' poiA='poi_start', poiB = 'poi_end')
# minimal use</p>
<p>scene.new_cable('cable_name', length=50, EA=1000, poiA=poi_start, poiB = poi_end, sheaves=[sheave1, sheave2])</p>
<p>scene.new_cable('cable_name', length=50, EA=1000, poiA='poi_start', poiB = 'poi_end', sheaves=['single_sheave']) # also a single sheave needs to be provided as a list</p>
<h2 id="notes">Notes</h2>
<p>The default options for length and EA can be used to measure distances between points</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <a title="DAVE.scene.Cable" href="#DAVE.scene.Cable"><code>Cable</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_cable(self, name, poiA, poiB, length=-1, EA=0, diameter=0, sheaves=None):
    &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        poiA : A Poi element to connect the first end of the cable to
        poiB : A Poi element to connect the other end of the cable to
        length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
        EA [0] : stiffness of the cable in kN/m; default

        sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from poiA to poiB

    Examples:

        scene.new_cable(&#39;cable_name&#39; poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;)  # minimal use

        scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=poi_start, poiB = poi_end, sheaves=[sheave1, sheave2])

        scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, poiA=&#39;poi_start&#39;, poiB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

    Notes:
        The default options for length and EA can be used to measure distances between points

    Returns:
        Reference to newly created Cable

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    assert1f(length, &#39;length&#39;)
    assert1f(EA, &#39;EA&#39;)

    poiA = self._poi_from_node(poiA)
    poiB = self._poi_from_node(poiB)

    pois = [poiA]
    if sheaves is not None:

        if isinstance(sheaves, Poi): # single sheave as poi or string
            sheaves = [sheaves]

        if isinstance(sheaves, Sheave): # single sheave as poi or string
            sheaves = [sheaves]


        if isinstance(sheaves, str):
            sheaves = [sheaves]


        for s in sheaves:
            # s may be a poi or a sheave
            pois.append(self._poi_or_sheave_from_node(s))


    pois.append(poiB)

    # default options
    if length == -1:
        length = np.linalg.norm(np.array(poiA.global_position) - np.array(poiB.global_position))

        if length&lt;1e-9:
            raise Exception(&#39;Length not provided and endpoints are at the same global position. Can not determine a suitable default length (&gt;0)&#39;)



    # more checks
    if length&lt;1e-9:
        raise Exception(&#39;Length should be more than 0&#39;)

    if EA&lt;0:
        raise Exception(&#39;EA should be more than 0&#39;)

    assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

    if diameter&lt;0:
        raise Exception(&#34;Diameter should be &gt;= 0&#34;)

    # then create
    a = self._vfc.new_cable(name)
    new_node = Cable(self, a)
    new_node.length = length
    new_node.EA = EA
    new_node.diameter = diameter

    for poi in pois:
        new_node.add_connection(poi)

    # and add to the scene
    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_connector2d"><code class="name flex">
<span>def <span class="ident">new_connector2d</span></span>(<span>self, name, master, slave, k_linear=0, k_angular=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>new_connector2d</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>slave</code></strong></dt>
<dd>Slaved axis system [Axis]</dd>
<dt><strong><code>master</code></strong></dt>
<dd>Master axis system [Axis]</dd>
<dt><strong><code>k_linear</code></strong> :&ensp;<code>linear</code> <code>stiffness</code> <code>in</code> <code>kN</code>/<code>m</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>k_angular</code></strong> :&ensp;<code>angular</code> <code>stiffness</code> <code>in</code> <code>kN</code>*<code>m</code> / <code>rad</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>connector2d</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_connector2d(self, name, master, slave, k_linear=0, k_angular=0):
    &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        slave: Slaved axis system [Axis]
        master: Master axis system [Axis]

        k_linear : linear stiffness in kN/m
        k_angular : angular stiffness in kN*m / rad

    Returns:
        Reference to newly created connector2d

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    m = self._parent_from_node(master)
    s = self._parent_from_node(slave)

    assert1f(k_linear, &#34;Linear stiffness&#34;)
    assert1f(k_angular, &#34;Angular stiffness&#34;)

    # then create
    a = self._vfc.new_connector2d(name)

    new_node = Connector2d(self, a)

    # and set properties
    new_node.master = m
    new_node.slave = s
    new_node.k_linear = k_linear
    new_node.k_angular = k_angular

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_force"><code class="name flex">
<span>def <span class="ident">new_force</span></span>(<span>self, name, parent=None, force=None, moment=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>force</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Poi]</dd>
<dt><strong><code>force</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
<dt><strong><code>moment</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>force</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_force(self, name, parent=None, force=None, moment=None):
    &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Poi]
        force: optional, global force on the node (x,y,z)
        moment: optional, global force on the node (x,y,z)


    Returns:
        Reference to newly created force

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._poi_from_node(parent)

    if force is not None:
        assert3f(force, &#34;Force &#34;)

    if moment is not None:
        assert3f(moment, &#34;Moment &#34;)


    # then create
    a = self._vfc.new_force(name)

    new_node = Force(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if force is not None:
        new_node.force = force
    if moment is not None:
        new_node.moment = moment

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_hydspring"><code class="name flex">
<span>def <span class="ident">new_hydspring</span></span>(<span>self, name, parent, cob, BMT, BML, COFX, COFY, kHeave, waterline, displacement_kN)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>hydspring</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Axis]</dd>
<dt><strong><code>cob</code></strong></dt>
<dd>position of the CoB (x,y,z) in the parent axis system</dd>
<dt><strong><code>BMT</code></strong></dt>
<dd>Vertical distance between CoB and meta-center for roll</dd>
<dt><strong><code>BML</code></strong></dt>
<dd>Vertical distance between CoB and meta-center for pitch</dd>
<dt><strong><code>COFX</code></strong></dt>
<dd>X-location of center of flotation (center of waterplane) relative to CoB</dd>
<dt><strong><code>COFY</code></strong></dt>
<dd>Y-location of center of flotation (center of waterplane) relative to CoB</dd>
<dt><strong><code>kHeave</code></strong> :&ensp;<code>heave</code> <code>stiffness</code> (<code>typically</code> <code>Awl</code> * <code>rho</code> * <code>g</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>waterline</code></strong> :&ensp;<code>Z</code>-<code>position</code> (<code>elevation</code>) of <code>the</code> <code>waterline</code> <code>relative</code> <code>to</code> <code>CoB</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>displacement_kN</code></strong> :&ensp;<code>displacement</code> (<code>typically</code> <code>volume</code> * <code>rho</code> * <code>g</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>hydrostatic</code> <code>spring</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_hydspring(self, name, parent, cob,
                  BMT, BML, COFX, COFY, kHeave, waterline, displacement_kN):
    &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Axis]
        cob: position of the CoB (x,y,z) in the parent axis system
        BMT: Vertical distance between CoB and meta-center for roll
        BML: Vertical distance between CoB and meta-center for pitch
        COFX: X-location of center of flotation (center of waterplane) relative to CoB
        COFY: Y-location of center of flotation (center of waterplane) relative to CoB
        kHeave : heave stiffness (typically Awl * rho * g)
        waterline : Z-position (elevation) of the waterline relative to CoB
        displacement_kN : displacement (typically volume * rho * g)


    Returns:
        Reference to newly created hydrostatic spring

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._parent_from_node(parent)
    assert3f(cob, &#34;CoB &#34;)
    assert1f(BMT, &#34;BMT &#34;)
    assert1f(BML, &#34;BML &#34;)
    assert1f(COFX, &#34;COFX &#34;)
    assert1f(COFY, &#34;COFY &#34;)
    assert1f(kHeave, &#34;kHeave &#34;)
    assert1f(waterline, &#34;waterline &#34;)
    assert1f(displacement_kN, &#34;displacement_kN &#34;)

    # then create
    a = self._vfc.new_hydspring(name)
    new_node = HydSpring(self, a)

    new_node.cob = cob
    new_node.parent = b
    new_node.BMT = BMT
    new_node.BML = BML
    new_node.COFX = COFX
    new_node.COFY = COFY
    new_node.kHeave = kHeave
    new_node.waterline = waterline
    new_node.displacement_kN = displacement_kN

    self._nodes.append(new_node)

    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_linear_beam"><code class="name flex">
<span>def <span class="ident">new_linear_beam</span></span>(<span>self, name, master, slave, EIy=0, EIz=0, GIp=0, EA=0, L=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>linear beam</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>slave</code></strong></dt>
<dd>Slaved axis system [Axis]</dd>
<dt><strong><code>master</code></strong></dt>
<dd>Master axis system [Axis]</dd>
</dl>
<p>All stiffness terms default to 0
The length defaults to the distance between master and slave
See :py:class:<a title="DAVE.scene.LinearBeam" href="#DAVE.scene.LinearBeam"><code>LinearBeam</code></a> for details</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>beam</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_linear_beam(self, name, master, slave, EIy=0, EIz=0, GIp=0, EA=0, L=None):
    &#34;&#34;&#34;Creates a new *linear beam* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        slave: Slaved axis system [Axis]
        master: Master axis system [Axis]

        All stiffness terms default to 0
        The length defaults to the distance between master and slave


    See :py:class:`LinearBeam` for details

    Returns:
        Reference to newly created beam

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    m = self._parent_from_node(master)
    s = self._parent_from_node(slave)

    if L is None:
        L = np.linalg.norm(np.array(m.global_position)- np.array(s.global_position))
    else:
        if L &lt;= 0:
            raise ValueError(&#39;L should be &gt; 0 as stiffness is defined per length.&#39;)


    # then create
    a = self._vfc.new_linearbeam(name)

    new_node = LinearBeam(self, a)

    # and set properties
    new_node.master = m
    new_node.slave = s
    new_node.EIy = EIy
    new_node.EIz = EIz
    new_node.GIp = GIp
    new_node.EA = EA
    new_node.L = L

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_linear_connector_6d"><code class="name flex">
<span>def <span class="ident">new_linear_connector_6d</span></span>(<span>self, name, slave, master, stiffness=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>linear connector 6d</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>slave</code></strong></dt>
<dd>Slaved axis system [Axis]</dd>
<dt><strong><code>master</code></strong></dt>
<dd>Master axis system [Axis]</dd>
<dt><strong><code>stiffness</code></strong></dt>
<dd>optional, connection stiffness (x,y,z, rx,ry,rz)</dd>
</dl>
<p>See :py:class:<a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d"><code>LC6d</code></a> for details</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>connector</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_linear_connector_6d(self, name, slave, master, stiffness = None):
    &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        slave: Slaved axis system [Axis]
        master: Master axis system [Axis]
        stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

    See :py:class:`LC6d` for details

    Returns:
        Reference to newly created connector

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    m = self._parent_from_node(master)
    s = self._parent_from_node(slave)

    if stiffness is not None:
        assert6f(stiffness, &#34;Stiffness &#34;)
    else:
        stiffness = (0,0,0,0,0,0)

    # then create
    a = self._vfc.new_linearconnector6d(name)

    new_node = LC6d(self, a)

    # and set properties
    new_node.master = m
    new_node.slave = s
    new_node.stiffness = stiffness

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_poi"><code class="name flex">
<span>def <span class="ident">new_poi</span></span>(<span>self, name, parent=None, position=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>poi</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>poi</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_poi(self, name, parent=None, position=None):
    &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)


    Returns:
        Reference to newly created poi

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)

    # then create
    a = self._vfc.new_poi(name)

    new_node = Poi(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if position is not None:
        new_node.position = position

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_rigidbody"><code class="name flex">
<span>def <span class="ident">new_rigidbody</span></span>(<span>self, name, mass=0, cog=(0, 0, 0), parent=None, position=None, rotation=None, fixed=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>rigidbody</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>mass</code></strong></dt>
<dd>optional, [0] mass in mT</dd>
<dt><strong><code>cog</code></strong></dt>
<dd>optional, (0,0,0) cog-position in (m,m,m)</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
</dl>
<p>fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.</p>
<h2 id="examples">Examples</h2>
<p>scene.new_rigidbody("heavy_thing", mass = 10000, cog = (1.45, 0, -0.7))</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody"><code>RigidBody</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_rigidbody(self, name, mass=0, cog=(0, 0, 0),
                  parent=None, position=None, rotation=None, fixed = True ):
    &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        mass: optional, [0] mass in mT
        cog: optional, (0,0,0) cog-position in (m,m,m)
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

    Examples:
        scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

    Returns:
        Reference to newly created RigidBody

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # check input
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    if not isinstance(fixed, bool):
        if len(fixed) != 6:
            raise Exception(&#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;)


    # make elements

    a = self._vfc.new_axis(name)

    p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
    p.parent = a
    p.position = cog

    g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
    g.parent = p
    g.force = (0, 0, -vfc.G * mass)

    r = RigidBody(self, a, p, g)

    # and set properties
    if b is not None:
        r.parent = b
    if position is not None:
        r.position = position
    if rotation is not None:
        r.rotation = rotation

    if isinstance(fixed, bool):
        if fixed:
            r.set_fixed()
        else:
            r.set_free()
    else:
        r.fixed = fixed

    self._nodes.append(r)
    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_sheave"><code class="name flex">
<span>def <span class="ident">new_sheave</span></span>(<span>self, name, parent, axis, radius=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>sheave</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Poi]</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>direction of the axis of rotation (x,y,z)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>optional, radius of the sheave</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>sheave</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_sheave(self, name, parent, axis, radius=0):
    &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Poi]
        axis: direction of the axis of rotation (x,y,z)
        radius: optional, radius of the sheave


    Returns:
        Reference to newly created sheave

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._poi_from_node(parent)

    assert3f(axis, &#34;Axis of rotation &#34;)

    assert1f(radius, &#34;Radius of sheave&#34;)

    # then create
    a = self._vfc.new_sheave(name)

    new_node = Sheave(self, a)

    # and set properties
    new_node.parent = b
    new_node.axis = axis
    new_node.radius = radius

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_visual"><code class="name flex">
<span>def <span class="ident">new_visual</span></span>(<span>self, name, path, parent=None, offset=None, rotation=None, scale=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <em>axis</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the resource</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
</dl>
<p>scale : optional, scale of the visual (x,y,z).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference</code> <code>to</code> <code>newly</code> <code>created</code> <code>visual</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_visual(self, name, path, parent=None, offset=None, rotation=None, scale = None):
    &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        path: Path to the resource
        parent: optional, name of the parent of the node
        offset: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        scale : optional, scale of the visual (x,y,z).

    Returns:
        Reference to newly created visual

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if offset is not None:
        assert3f(offset, &#34;Offset &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    self.get_resource_path(path) # raises error when resource is not found


    # then create

    new_node = Visual(self)

    new_node.name = name
    new_node.path = path
    new_node.parent = parent

    # and set properties
    if b is not None:
        new_node.parent = b
    if offset is not None:
        new_node.offset = offset
    if rotation is not None:
        new_node.rotation = rotation
    if scale is not None:
        new_node.scale = scale

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.node_by_name"><code class="name flex">
<span>def <span class="ident">node_by_name</span></span>(<span>self, node_name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_by_name(self, node_name):
    for N in self._nodes:
        if N.name == node_name:
            return N

    self.print_node_tree()
    raise ValueError(&#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_depending_on"><code class="name flex">
<span>def <span class="ident">nodes_depending_on</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
This function should be used to determine dependencies of Core-connected elements.</p>
<p>For making node-trees please use nodes_with_parent instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<a title="DAVE.scene.Node" href="#DAVE.scene.Node"><code>Node</code></a> or <code>node</code>-<code>name</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>names</code></dt>
<dd>&nbsp;</dd>
<dt><code>See</code> <code>Also</code>: <code>nodes_with_parent</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_depending_on(self, node):
    &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
    This function should be used to determine dependencies of Core-connected elements.

    For making node-trees please use nodes_with_parent instead.

    Args:
        node : Node or node-name

    Returns:
        list of names

    See Also: nodes_with_parent
    &#34;&#34;&#34;

    if isinstance(node, Node):
        node = node.name

    # check the node type
    _node = self[node]
    if not isinstance(_node, CoreConnectedNode):
        return []
    else:
        names =  self._vfc.elements_depending_on(node)

    r = []
    for name in names:
        try:
            r.append(self[name].name)
        except:
            pass

    # check visuals as well (which are not core-connected)
    for v in self.nodes_of_type(Visual):
        if v.parent is _node:
            r.append(v.name)

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_of_type"><code class="name flex">
<span>def <span class="ident">nodes_of_type</span></span>(<span>self, node_class)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all nodes of the specified type</p>
<h2 id="examples">Examples</h2>
<p>pois = scene.nodes_of_type(DAVE.Poi)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_of_type(self, node_class):
    &#34;&#34;&#34;Returns all nodes of the specified type

    Examples:
        pois = scene.nodes_of_type(DAVE.Poi)
    &#34;&#34;&#34;
    r = list()
    for n in self._nodes:
        if isinstance(n, node_class):
            r.append(n)
    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_with_parent"><code class="name flex">
<span>def <span class="ident">nodes_with_parent</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of nodes that have given node as a parent. Good for making trees.
For checking physical connections use nodes_depending_on instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<a title="DAVE.scene.Node" href="#DAVE.scene.Node"><code>Node</code></a> or <code>node</code>-<code>name</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>names</code></dt>
<dd>&nbsp;</dd>
<dt><code>See</code> <code>Also</code>: <code>nodes_depending_on</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_with_parent(self, node):
    &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
    For checking physical connections use nodes_depending_on instead.

    Args:
        node : Node or node-name

    Returns:
        list of names

    See Also: nodes_depending_on
    &#34;&#34;&#34;

    if isinstance(node, str):
        node = self[node]

    r = []

    for n in self._nodes:

        try:
            parent = n.parent
        except AttributeError:
            continue

        if parent == node:
            r.append(n.name)

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.print_node_tree"><code class="name flex">
<span>def <span class="ident">print_node_tree</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_node_tree(self):

    self.sort_nodes_by_dependency()

    to_be_printed = []
    for n in self._nodes:
        to_be_printed.append(n.name)

    # to_be_printed.reverse()

    def print_deps(name, spaces):

        node = self[name]
        deps = self.nodes_with_parent(node)
        print(spaces + name + &#39; [&#39; + str(type(node)).split(&#39;.&#39;)[-1][:-2] + &#39;]&#39;)

        if deps is not None:
            for dep in deps:
                if spaces == &#34;&#34;:
                    spaces_plus = &#39; |-&gt; &#39;
                else:
                    spaces_plus = &#39; |   &#39; + spaces
                print_deps(dep, spaces_plus)

        to_be_printed.remove(name)

    while to_be_printed:
        name = to_be_printed[0]
        print_deps(name, &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.print_python_code"><code class="name flex">
<span>def <span class="ident">print_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints the python code that generates the current scene</p>
<p>See also: give_python_code</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_python_code(self):
    &#34;&#34;&#34;Prints the python code that generates the current scene

    See also: give_python_code
    &#34;&#34;&#34;
    for line in self.give_python_code().split(&#39;\n&#39;):
        print(line)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.save_scene"><code class="name flex">
<span>def <span class="ident">save_scene</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves the scene to a file</p>
<p>This saves the scene in its current state to a file.
Opening the saved file will reproduce exactly this scene.</p>
<p>This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
the results of that update will not be reflected in the saved model.</p>
<p>If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>filename</code> or <code>file</code>-<code>path</code> <code>to</code> <code>save</code> <code>the</code> <code>file.</code> <code>Default</code> <code>extension</code> <code>is</code> <code>.dave_asset</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>full</code> <code>path</code> <code>to</code> <code>the</code> <code>saved</code> <code>file</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_scene(self, filename):
    &#34;&#34;&#34;Saves the scene to a file

    This saves the scene in its current state to a file.
    Opening the saved file will reproduce exactly this scene.

    This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
    This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
    So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
    the results of that update will not be reflected in the saved model.

    If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

    Args:
        filename : filename or file-path to save the file. Default extension is .dave_asset

    Returns:
        the full path to the saved file

    &#34;&#34;&#34;

    code = self.give_python_code()

    filename = Path(filename)

    # add .dave_asset extension
    if filename.suffix != &#39;.dave_asset&#39;:
        filename = Path(str(filename) + &#39;.dave_asset&#39;)

    # add path if not provided
    if not filename.is_absolute():
        try:
            filename = Path(self.resources_paths[-1]) / filename
        except:
            pass # save in current folder

    # make sure directory exists
    directory = filename.parent
    if not directory.exists():
        directory.mkdir()


    f = open(filename,&#39;w+&#39;)
    f.write(code)
    f.close()

    self._print(&#39;Saved as {}&#39;.format(filename))

    return filename</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.solve_statics"><code class="name flex">
<span>def <span class="ident">solve_statics</span></span>(<span>self, silent=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Solves statics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>silent</code></strong></dt>
<dd>Do not print if successfully solved</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if successful, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_statics(self, silent=False):
    &#34;&#34;&#34;Solves statics

    Args:
        silent: Do not print if successfully solved

    Returns:
        bool: True if successful, False otherwise.

    &#34;&#34;&#34;
    succes = self._vfc.state_solve_statics()

    if self.verify_equilibrium():
        if not silent:
            self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
        return True

    d = np.array(self._vfc.get_dofs())
    if np.any(np.abs(d)&gt;2000):
        print(&#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;)
        return False

    return False</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.sort_nodes_by_dependency"><code class="name flex">
<span>def <span class="ident">sort_nodes_by_dependency</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sorts the nodes such that a node only depends on nodes earlier in the list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_nodes_by_dependency(self):
    &#34;&#34;&#34;Sorts the nodes such that a node only depends on nodes earlier in the list.&#34;&#34;&#34;

    self._vfc.state_update()  # use the function from the core.
    new_list = []
    for name in self._vfc.names:  # and then build a new list using the names
        if vfc.VF_NAME_SPLIT in name:
            continue
        new_list.append(self[name])

    # and add the nodes without a vfc-core connection
    for node in self._nodes:
        if not node in new_list:
            new_list.append(node)

    self._nodes = new_list</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.verify_equilibrium"><code class="name flex">
<span>def <span class="ident">verify_equilibrium</span></span>(<span>self, tol=0.01)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the current state is an equilibrium</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if successful, False if not an equilibrium.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_equilibrium(self, tol = 1e-2):
    &#34;&#34;&#34;Checks if the current state is an equilibrium

    Returns:
        bool: True if successful, False if not an equilibrium.

    &#34;&#34;&#34;
    return (self._vfc.Emaxabs &lt; tol)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.scene.Sheave"><code class="flex name class">
<span>class <span class="ident">Sheave</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<section class="desc"><p>A Sheave models sheave with axis and diameter.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sheave(NodeWithParent):
    &#34;&#34;&#34;A Sheave models sheave with axis and diameter.


    &#34;&#34;&#34;

    @property
    def axis(self):
        &#34;&#34;&#34;
        Gets or sets direction of the sheave axis
        &#34;&#34;&#34;
        return self._vfNode.axis_direction

    @axis.setter
    def axis(self, val):
        assert3f(val)
        if np.linalg.norm(val) == 0:
            raise ValueError(&#39;Axis can not be 0,0,0&#39;)
        self._vfNode.axis_direction = val

    @property
    def radius(self):
        &#34;&#34;&#34;
        Gets or sets radius of the sheave
        &#34;&#34;&#34;
        return self._vfNode.radius


    @radius.setter
    def radius(self, val):
        assert1f(val)
        self._vfNode.radius = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_sheave(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            axis=({}, {}, {}),&#34;.format(*self.axis)
        code += &#34;\n            radius={} )&#34;.format(self.radius)
        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Sheave.axis"><code class="name">var <span class="ident">axis</span></code></dt>
<dd>
<section class="desc"><p>Gets or sets direction of the sheave axis</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axis(self):
    &#34;&#34;&#34;
    Gets or sets direction of the sheave axis
    &#34;&#34;&#34;
    return self._vfNode.axis_direction</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sheave.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<section class="desc"><p>Gets or sets radius of the sheave</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    &#34;&#34;&#34;
    Gets or sets radius of the sheave
    &#34;&#34;&#34;
    return self._vfNode.radius</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.TriMeshSource"><code class="flex name class">
<span>class <span class="ident">TriMeshSource</span></span>
<span>(</span><span>scene, source)</span>
</code></dt>
<dd>
<section class="desc"><p>TriMesh</p>
<p>A TriMesh node contains triangular mesh which can be used for buoyancy or contact</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriMeshSource(Node):
    &#34;&#34;&#34;
    TriMesh

    A TriMesh node contains triangular mesh which can be used for buoyancy or contact

    &#34;&#34;&#34;

    def __init__(self, scene, source):

        # Note: Visual does not have a corresponding vfCore Node in the scene but does have a vfCore
        self.scene = scene
        self._TriMesh = source
        self._new_mesh = True             # cheat for visuals

        self._path = &#39;&#39;                   # stores the data that was used to load the obj
        self._offset = (0,0,0)
        self._scale = (1,1,1)
        self._rotation = (0,0,0)

    def AddVertex(self, x,y,z):
        self._TriMesh.AddVertex(x,y,z)

    def AddFace(self, i,j,k):
        self._TriMesh.AddFace(i,j,k)

    def get_extends(self):
        &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

        Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

        &#34;&#34;&#34;

        t = self._TriMesh

        if t.nFaces == 0:
            return (0,0,0,0)

        v = t.GetVertex(0)
        xn = v[0]
        xp = v[0]
        yn = v[1]
        yp = v[1]
        zn = v[2]
        zp = v[2]

        for i in range(t.nVertices):
            v = t.GetVertex(i)
            x = v[0]
            y= v[1]
            z = v[2]

            if x&lt;xn:
                xn = x
            if x&gt;xp:
                xp = x
            if y &lt; yn:
                yn = y
            if y &gt; yp:
                yp = y
            if z &lt; zn:
                zn = z
            if z &gt; zp:
                zp = z

        return (xn,xp,yn,yp,zn, zp)





    def make_cube(self):
        &#34;&#34;&#34;Sets the mesh to a cube&#34;&#34;&#34;

        from vtk import vtkCubeSource
        cube = vtkCubeSource()
        self.load_vtk_polydataSource(cube)

    def _fromVTKpolydata(self,polydata, offset = None, rotation = None, scale = None):

        import vtk

        tri = vtk.vtkTriangleFilter()

        tri.SetInputConnection(polydata)


        scaleFilter = vtk.vtkTransformPolyDataFilter()
        rotationFilter = vtk.vtkTransformPolyDataFilter()

        s = vtk.vtkTransform()
        s.Identity()
        r = vtk.vtkTransform()
        r.Identity()

        scaleFilter.SetInputConnection(tri.GetOutputPort())
        rotationFilter.SetInputConnection(scaleFilter.GetOutputPort())

        if scale is not None:
            s.Scale(*scale)

        if rotation is not None:
            q = rotation
            angle = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2) ** (0.5)
            if angle &gt; 0:
                r.RotateWXYZ(angle, q[0] / angle, q[1] / angle, q[2] / angle)

        if offset is None:
            offset = [0,0,0]

        scaleFilter.SetTransform(s)
        rotationFilter.SetTransform(r)
        rotationFilter.Update()

        data = rotationFilter.GetOutput()
        self._TriMesh.Clear()

        for i in range(data.GetNumberOfPoints()):
            point = data.GetPoint(i)
            self._TriMesh.AddVertex(point[0] + offset[0], point[1] + offset[1], point[2] + offset[2])

        for i in range(data.GetNumberOfCells()):
            cell = data.GetCell(i)

            if isinstance(cell,vtk.vtkLine):
                print(&#34;Cell nr {} is a line, not adding to mesh&#34;.format(i))
                continue

            id0 = cell.GetPointId(0)
            id1 = cell.GetPointId(1)
            id2 = cell.GetPointId(2)
            self._TriMesh.AddFace(id0, id1, id2)

        # check if anything was loaded
        if self._TriMesh.nFaces == 0:
            raise Exception(&#39;No faces in poly-data - no geometry added (hint: empty obj file?)&#39;)
        self._new_mesh = True

    def load_vtk_polydataSource(self, polydata):
        &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

        The vtk TriangleFilter is used to triangulate the source

        Examples:
            cube = vtk.vtkCubeSource()
            cube.SetXLength(122)
            cube.SetYLength(38)
            cube.SetZLength(10)
            trimesh.load_vtk_polydataSource(cube)
        &#34;&#34;&#34;

        self._fromVTKpolydata(polydata.GetOutputPort())


    def load_obj(self, filename, offset = None, rotation = None, scale = None):
        &#34;&#34;&#34;Loads an .obj file and and triangulates it.

        Order of modifications:

        1. rotate
        2. scale
        3. offset

        Args:
            filename: (str or path): file to load
            offset: : offset
            rotation:  : rotation
            scale:  scale

        &#34;&#34;&#34;
        if not exists(filename):
            raise ValueError(&#39;File {} does not exit&#39;.format(filename))

        filename = str(filename)

        import vtk
        obj = vtk.vtkOBJReader()
        obj.SetFileName(filename)

        # Add cleaning
        cln = vtk.vtkCleanPolyData()
        cln.SetInputConnection(obj.GetOutputPort())

        self._fromVTKpolydata(cln.GetOutputPort(), offset=offset, rotation=rotation, scale=scale)

        self._path = split(filename)[1]
        self._scale = scale
        self._offset = offset
        self._rotation = rotation

        if self._scale is None:
            self._scale = (1.0, 1.0, 1.0)
        if self._offset is None:
            self._offset = (0.0, 0.0, 0.0)
        if self._rotation is None:
            self._rotation = (0.0, 0.0, 0.0)

    def give_python_code(self):
        code = &#34;# No code generated for TriMeshSource&#34;
        return code

    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.TriMeshSource.AddFace"><code class="name flex">
<span>def <span class="ident">AddFace</span></span>(<span>self, i, j, k)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddFace(self, i,j,k):
    self._TriMesh.AddFace(i,j,k)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.AddVertex"><code class="name flex">
<span>def <span class="ident">AddVertex</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVertex(self, x,y,z):
    self._TriMesh.AddVertex(x,y,z)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    if not (isinstance(new_parent, Axis) or new_parent is None):
        raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

    # get current position and orientation
    if self.parent is not None:
        cur_position = self.parent.to_glob_position(self.offset)
        cur_rotation = self.parent.to_glob_direction(self.rotation)
    else:
        cur_position = self.offset
        cur_rotation = self.rotation

    self.parent = new_parent

    if new_parent is None:
        self.offset = cur_position
        self.rotation = cur_rotation
    else:
        self.offset = new_parent.to_loc_position(cur_position)
        self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.get_extends"><code class="name flex">
<span>def <span class="ident">get_extends</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the extends of the mesh in global coordinates</p>
<p>Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extends(self):
    &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

    Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

    &#34;&#34;&#34;

    t = self._TriMesh

    if t.nFaces == 0:
        return (0,0,0,0)

    v = t.GetVertex(0)
    xn = v[0]
    xp = v[0]
    yn = v[1]
    yp = v[1]
    zn = v[2]
    zp = v[2]

    for i in range(t.nVertices):
        v = t.GetVertex(i)
        x = v[0]
        y= v[1]
        z = v[2]

        if x&lt;xn:
            xn = x
        if x&gt;xp:
            xp = x
        if y &lt; yn:
            yn = y
        if y &gt; yp:
            yp = y
        if z &lt; zn:
            zn = z
        if z &gt; zp:
            zp = z

    return (xn,xp,yn,yp,zn, zp)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.load_obj"><code class="name flex">
<span>def <span class="ident">load_obj</span></span>(<span>self, filename, offset=None, rotation=None, scale=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads an .obj file and and triangulates it.</p>
<p>Order of modifications:</p>
<ol>
<li>rotate</li>
<li>scale</li>
<li>offset</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>(str or path): file to load</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>: offset</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>: rotation</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>scale</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_obj(self, filename, offset = None, rotation = None, scale = None):
    &#34;&#34;&#34;Loads an .obj file and and triangulates it.

    Order of modifications:

    1. rotate
    2. scale
    3. offset

    Args:
        filename: (str or path): file to load
        offset: : offset
        rotation:  : rotation
        scale:  scale

    &#34;&#34;&#34;
    if not exists(filename):
        raise ValueError(&#39;File {} does not exit&#39;.format(filename))

    filename = str(filename)

    import vtk
    obj = vtk.vtkOBJReader()
    obj.SetFileName(filename)

    # Add cleaning
    cln = vtk.vtkCleanPolyData()
    cln.SetInputConnection(obj.GetOutputPort())

    self._fromVTKpolydata(cln.GetOutputPort(), offset=offset, rotation=rotation, scale=scale)

    self._path = split(filename)[1]
    self._scale = scale
    self._offset = offset
    self._rotation = rotation

    if self._scale is None:
        self._scale = (1.0, 1.0, 1.0)
    if self._offset is None:
        self._offset = (0.0, 0.0, 0.0)
    if self._rotation is None:
        self._rotation = (0.0, 0.0, 0.0)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.load_vtk_polydataSource"><code class="name flex">
<span>def <span class="ident">load_vtk_polydataSource</span></span>(<span>self, polydata)</span>
</code></dt>
<dd>
<section class="desc"><p>Fills the triangle data from a vtk polydata such as a cubeSource.</p>
<p>The vtk TriangleFilter is used to triangulate the source</p>
<h2 id="examples">Examples</h2>
<p>cube = vtk.vtkCubeSource()
cube.SetXLength(122)
cube.SetYLength(38)
cube.SetZLength(10)
trimesh.load_vtk_polydataSource(cube)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_vtk_polydataSource(self, polydata):
    &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

    The vtk TriangleFilter is used to triangulate the source

    Examples:
        cube = vtk.vtkCubeSource()
        cube.SetXLength(122)
        cube.SetYLength(38)
        cube.SetZLength(10)
        trimesh.load_vtk_polydataSource(cube)
    &#34;&#34;&#34;

    self._fromVTKpolydata(polydata.GetOutputPort())</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.make_cube"><code class="name flex">
<span>def <span class="ident">make_cube</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the mesh to a cube</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_cube(self):
    &#34;&#34;&#34;Sets the mesh to a cube&#34;&#34;&#34;

    from vtk import vtkCubeSource
    cube = vtkCubeSource()
    self.load_vtk_polydataSource(cube)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Visual"><code class="flex name class">
<span>class <span class="ident">Visual</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<section class="desc"><p>Visual</p>
<p><img alt="" src="./images/visual.png"></p>
<p>A Visual node contains a 3d visual, typically obtained from a .obj file.
A visual node can be placed on an axis-type node.</p>
<p>It is used for visualization. It does not affect the forces, dynamics or statics.</p>
<p>The visual can be given an offset, rotation and scale. These are applied in the following order</p>
<ol>
<li>rotate</li>
<li>scale</li>
<li>offset</li>
</ol>
<p>Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visual(Node):
    &#34;&#34;&#34;
    Visual

    .. image:: ./images/visual.png

    A Visual node contains a 3d visual, typically obtained from a .obj file.
    A visual node can be placed on an axis-type node.

    It is used for visualization. It does not affect the forces, dynamics or statics.

    The visual can be given an offset, rotation and scale. These are applied in the following order

    1. rotate
    2. scale
    3. offset

    Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.

    &#34;&#34;&#34;

    def __init__(self, scene):

        # Note: Visual does not have a corresponding vfCore element
        self.scene = scene

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Offset (x,y,z) of the visual. Offset is applied after scaling&#34;&#34;&#34;
        self.rotation = [0, 0, 0]
        &#34;&#34;&#34;Rotation (rx,ry,rz) of the visual&#34;&#34;&#34;

        self.scale = [1,1,1]
        &#34;&#34;&#34;Scaling of the visual. Scaling is applied before offset.&#34;&#34;&#34;

        self.path = &#39;&#39;
        &#34;&#34;&#34;Filename of the visual&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)


        code += &#34;\ns.new_visual(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}), &#34;.format(*self.offset)
        code += &#34;\n            rotation=({}, {}, {}), &#34;.format(*self.rotation)
        code += &#34;\n            scale=({}, {}, {}) )&#34;.format(*self.scale)

        return code

    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Visual.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"><p>Offset (x,y,z) of the visual. Offset is applied after scaling</p></section>
</dd>
<dt id="DAVE.scene.Visual.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<section class="desc"><p>Parent : Axis-type</p></section>
</dd>
<dt id="DAVE.scene.Visual.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<section class="desc"><p>Filename of the visual</p></section>
</dd>
<dt id="DAVE.scene.Visual.rotation"><code class="name">var <span class="ident">rotation</span></code></dt>
<dd>
<section class="desc"><p>Rotation (rx,ry,rz) of the visual</p></section>
</dd>
<dt id="DAVE.scene.Visual.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<section class="desc"><p>Scaling of the visual. Scaling is applied before offset.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Visual.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    if not (isinstance(new_parent, Axis) or new_parent is None):
        raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)

    # get current position and orientation
    if self.parent is not None:
        cur_position = self.parent.to_glob_position(self.offset)
        cur_rotation = self.parent.to_glob_direction(self.rotation)
    else:
        cur_position = self.offset
        cur_rotation = self.rotation

    self.parent = new_parent

    if new_parent is None:
        self.offset = cur_position
        self.rotation = cur_rotation
    else:
        self.offset = new_parent.to_loc_position(cur_position)
        self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#general">General</a><ul>
<li><a href="#axis-systems">Axis systems</a></li>
<li><a href="#units">Units</a></li>
<li><a href="#3d-rotations">3D rotations</a></li>
<li><a href="#filesystem-and-configuration">Filesystem and configuration</a><ul>
<li><a href="#or">/ or \</a></li>
</ul>
</li>
<li><a href="#file-format">File format</a></li>
</ul>
</li>
<li><a href="#scene-and-nodes">Scene and nodes</a></li>
<li><a href="#nodes">Nodes</a><ul>
<li><a href="#geometry">Geometry</a><ul>
<li><a href="#forces">Forces</a></li>
<li><a href="#degrees-of-freedom">Degrees of freedom</a></li>
</ul>
</li>
<li><a href="#connectors">Connectors</a></li>
<li><a href="#forces_1">Forces</a></li>
<li><a href="#visuals">Visuals</a></li>
<li><a href="#others">Others</a></li>
</ul>
</li>
<li><a href="#scene">Scene</a><ul>
<li><a href="#creating-scenes">Creating scenes</a></li>
<li><a href="#adding-content">Adding content</a></li>
<li><a href="#access-nodes">Access nodes</a></li>
<li><a href="#deleting-nodes">Deleting nodes</a></li>
<li><a href="#saving-or-exporting">Saving or exporting</a></li>
<li><a href="#solving">Solving</a></li>
<li><a href="#optimalizations">Optimalizations</a></li>
<li><a href="#resources">Resources</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DAVE" href="index.html">DAVE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Axis.applied_force" href="#DAVE.scene.Axis.applied_force">applied_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force" href="#DAVE.scene.Axis.connection_force">connection_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_x" href="#DAVE.scene.Axis.connection_force_x">connection_force_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_y" href="#DAVE.scene.Axis.connection_force_y">connection_force_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_z" href="#DAVE.scene.Axis.connection_force_z">connection_force_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_x" href="#DAVE.scene.Axis.connection_moment_x">connection_moment_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_y" href="#DAVE.scene.Axis.connection_moment_y">connection_moment_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_z" href="#DAVE.scene.Axis.connection_moment_z">connection_moment_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.equilibrium_error" href="#DAVE.scene.Axis.equilibrium_error">equilibrium_error</a></code></li>
<li><code><a title="DAVE.scene.Axis.fixed" href="#DAVE.scene.Axis.fixed">fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_position" href="#DAVE.scene.Axis.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_rotation" href="#DAVE.scene.Axis.global_rotation">global_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_transform" href="#DAVE.scene.Axis.global_transform">global_transform</a></code></li>
<li><code><a title="DAVE.scene.Axis.grx" href="#DAVE.scene.Axis.grx">grx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gry" href="#DAVE.scene.Axis.gry">gry</a></code></li>
<li><code><a title="DAVE.scene.Axis.grz" href="#DAVE.scene.Axis.grz">grz</a></code></li>
<li><code><a title="DAVE.scene.Axis.gx" href="#DAVE.scene.Axis.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gy" href="#DAVE.scene.Axis.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Axis.gz" href="#DAVE.scene.Axis.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Axis.parent" href="#DAVE.scene.Axis.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Axis.position" href="#DAVE.scene.Axis.position">position</a></code></li>
<li><code><a title="DAVE.scene.Axis.rotation" href="#DAVE.scene.Axis.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.rx" href="#DAVE.scene.Axis.rx">rx</a></code></li>
<li><code><a title="DAVE.scene.Axis.ry" href="#DAVE.scene.Axis.ry">ry</a></code></li>
<li><code><a title="DAVE.scene.Axis.rz" href="#DAVE.scene.Axis.rz">rz</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_fixed" href="#DAVE.scene.Axis.set_fixed">set_fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_free" href="#DAVE.scene.Axis.set_free">set_free</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_direction" href="#DAVE.scene.Axis.to_glob_direction">to_glob_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_position" href="#DAVE.scene.Axis.to_glob_position">to_glob_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_rotation" href="#DAVE.scene.Axis.to_glob_rotation">to_glob_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_direction" href="#DAVE.scene.Axis.to_loc_direction">to_loc_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_position" href="#DAVE.scene.Axis.to_loc_position">to_loc_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_rotation" href="#DAVE.scene.Axis.to_loc_rotation">to_loc_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.x" href="#DAVE.scene.Axis.x">x</a></code></li>
<li><code><a title="DAVE.scene.Axis.y" href="#DAVE.scene.Axis.y">y</a></code></li>
<li><code><a title="DAVE.scene.Axis.z" href="#DAVE.scene.Axis.z">z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy">Buoyancy</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Buoyancy.cob" href="#DAVE.scene.Buoyancy.cob">cob</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.displacement" href="#DAVE.scene.Buoyancy.displacement">displacement</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.trimesh" href="#DAVE.scene.Buoyancy.trimesh">trimesh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Cable.EA" href="#DAVE.scene.Cable.EA">EA</a></code></li>
<li><code><a title="DAVE.scene.Cable.add_connection" href="#DAVE.scene.Cable.add_connection">add_connection</a></code></li>
<li><code><a title="DAVE.scene.Cable.check_endpoints" href="#DAVE.scene.Cable.check_endpoints">check_endpoints</a></code></li>
<li><code><a title="DAVE.scene.Cable.clear_connections" href="#DAVE.scene.Cable.clear_connections">clear_connections</a></code></li>
<li><code><a title="DAVE.scene.Cable.diameter" href="#DAVE.scene.Cable.diameter">diameter</a></code></li>
<li><code><a title="DAVE.scene.Cable.get_points_for_visual" href="#DAVE.scene.Cable.get_points_for_visual">get_points_for_visual</a></code></li>
<li><code><a title="DAVE.scene.Cable.give_poi_names" href="#DAVE.scene.Cable.give_poi_names">give_poi_names</a></code></li>
<li><code><a title="DAVE.scene.Cable.length" href="#DAVE.scene.Cable.length">length</a></code></li>
<li><code><a title="DAVE.scene.Cable.stretch" href="#DAVE.scene.Cable.stretch">stretch</a></code></li>
<li><code><a title="DAVE.scene.Cable.tension" href="#DAVE.scene.Cable.tension">tension</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d">Connector2d</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Connector2d.angle" href="#DAVE.scene.Connector2d.angle">angle</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.axis" href="#DAVE.scene.Connector2d.axis">axis</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.force" href="#DAVE.scene.Connector2d.force">force</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.k_angular" href="#DAVE.scene.Connector2d.k_angular">k_angular</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.k_linear" href="#DAVE.scene.Connector2d.k_linear">k_linear</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.master" href="#DAVE.scene.Connector2d.master">master</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.moment" href="#DAVE.scene.Connector2d.moment">moment</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.slave" href="#DAVE.scene.Connector2d.slave">slave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></code></h4>
</li>
<li>
<h4><code><a title="DAVE.scene.Force" href="#DAVE.scene.Force">Force</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Force.force" href="#DAVE.scene.Force.force">force</a></code></li>
<li><code><a title="DAVE.scene.Force.moment" href="#DAVE.scene.Force.moment">moment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring">HydSpring</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.HydSpring.BML" href="#DAVE.scene.HydSpring.BML">BML</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.BMT" href="#DAVE.scene.HydSpring.BMT">BMT</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.COFX" href="#DAVE.scene.HydSpring.COFX">COFX</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.COFY" href="#DAVE.scene.HydSpring.COFY">COFY</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.cob" href="#DAVE.scene.HydSpring.cob">cob</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.displacement_kN" href="#DAVE.scene.HydSpring.displacement_kN">displacement_kN</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.kHeave" href="#DAVE.scene.HydSpring.kHeave">kHeave</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.waterline" href="#DAVE.scene.HydSpring.waterline">waterline</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.LC6d.master" href="#DAVE.scene.LC6d.master">master</a></code></li>
<li><code><a title="DAVE.scene.LC6d.slave" href="#DAVE.scene.LC6d.slave">slave</a></code></li>
<li><code><a title="DAVE.scene.LC6d.stiffness" href="#DAVE.scene.LC6d.stiffness">stiffness</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.LinearBeam" href="#DAVE.scene.LinearBeam">LinearBeam</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.LinearBeam.EA" href="#DAVE.scene.LinearBeam.EA">EA</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.EIy" href="#DAVE.scene.LinearBeam.EIy">EIy</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.EIz" href="#DAVE.scene.LinearBeam.EIz">EIz</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.GIp" href="#DAVE.scene.LinearBeam.GIp">GIp</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.L" href="#DAVE.scene.LinearBeam.L">L</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.master" href="#DAVE.scene.LinearBeam.master">master</a></code></li>
<li><code><a title="DAVE.scene.LinearBeam.slave" href="#DAVE.scene.LinearBeam.slave">slave</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Poi" href="#DAVE.scene.Poi">Poi</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Poi.applied_force_and_moment_global" href="#DAVE.scene.Poi.applied_force_and_moment_global">applied_force_and_moment_global</a></code></li>
<li><code><a title="DAVE.scene.Poi.global_position" href="#DAVE.scene.Poi.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Poi.gx" href="#DAVE.scene.Poi.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Poi.gy" href="#DAVE.scene.Poi.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Poi.gz" href="#DAVE.scene.Poi.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Poi.position" href="#DAVE.scene.Poi.position">position</a></code></li>
<li><code><a title="DAVE.scene.Poi.x" href="#DAVE.scene.Poi.x">x</a></code></li>
<li><code><a title="DAVE.scene.Poi.y" href="#DAVE.scene.Poi.y">y</a></code></li>
<li><code><a title="DAVE.scene.Poi.z" href="#DAVE.scene.Poi.z">z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.RigidBody.cog" href="#DAVE.scene.RigidBody.cog">cog</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogx" href="#DAVE.scene.RigidBody.cogx">cogx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogy" href="#DAVE.scene.RigidBody.cogy">cogy</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogz" href="#DAVE.scene.RigidBody.cogz">cogz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.mass" href="#DAVE.scene.RigidBody.mass">mass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Scene" href="#DAVE.scene.Scene">Scene</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Scene._name_prefix" href="#DAVE.scene.Scene._name_prefix">_name_prefix</a></code></li>
<li><code><a title="DAVE.scene.Scene._nodes" href="#DAVE.scene.Scene._nodes">_nodes</a></code></li>
<li><code><a title="DAVE.scene.Scene._vfc" href="#DAVE.scene.Scene._vfc">_vfc</a></code></li>
<li><code><a title="DAVE.scene.Scene.available_name_like" href="#DAVE.scene.Scene.available_name_like">available_name_like</a></code></li>
<li><code><a title="DAVE.scene.Scene.clear" href="#DAVE.scene.Scene.clear">clear</a></code></li>
<li><code><a title="DAVE.scene.Scene.delete" href="#DAVE.scene.Scene.delete">delete</a></code></li>
<li><code><a title="DAVE.scene.Scene.dissolve" href="#DAVE.scene.Scene.dissolve">dissolve</a></code></li>
<li><code><a title="DAVE.scene.Scene.get_resource_list" href="#DAVE.scene.Scene.get_resource_list">get_resource_list</a></code></li>
<li><code><a title="DAVE.scene.Scene.get_resource_path" href="#DAVE.scene.Scene.get_resource_path">get_resource_path</a></code></li>
<li><code><a title="DAVE.scene.Scene.give_python_code" href="#DAVE.scene.Scene.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Scene.goal_seek" href="#DAVE.scene.Scene.goal_seek">goal_seek</a></code></li>
<li><code><a title="DAVE.scene.Scene.import_scene" href="#DAVE.scene.Scene.import_scene">import_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.load_scene" href="#DAVE.scene.Scene.load_scene">load_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.name_available" href="#DAVE.scene.Scene.name_available">name_available</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_axis" href="#DAVE.scene.Scene.new_axis">new_axis</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_buoyancy" href="#DAVE.scene.Scene.new_buoyancy">new_buoyancy</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_cable" href="#DAVE.scene.Scene.new_cable">new_cable</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_connector2d" href="#DAVE.scene.Scene.new_connector2d">new_connector2d</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_force" href="#DAVE.scene.Scene.new_force">new_force</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_hydspring" href="#DAVE.scene.Scene.new_hydspring">new_hydspring</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_linear_beam" href="#DAVE.scene.Scene.new_linear_beam">new_linear_beam</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_linear_connector_6d" href="#DAVE.scene.Scene.new_linear_connector_6d">new_linear_connector_6d</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_poi" href="#DAVE.scene.Scene.new_poi">new_poi</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_rigidbody" href="#DAVE.scene.Scene.new_rigidbody">new_rigidbody</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_sheave" href="#DAVE.scene.Scene.new_sheave">new_sheave</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_visual" href="#DAVE.scene.Scene.new_visual">new_visual</a></code></li>
<li><code><a title="DAVE.scene.Scene.node_by_name" href="#DAVE.scene.Scene.node_by_name">node_by_name</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_depending_on" href="#DAVE.scene.Scene.nodes_depending_on">nodes_depending_on</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_of_type" href="#DAVE.scene.Scene.nodes_of_type">nodes_of_type</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_with_parent" href="#DAVE.scene.Scene.nodes_with_parent">nodes_with_parent</a></code></li>
<li><code><a title="DAVE.scene.Scene.print_node_tree" href="#DAVE.scene.Scene.print_node_tree">print_node_tree</a></code></li>
<li><code><a title="DAVE.scene.Scene.print_python_code" href="#DAVE.scene.Scene.print_python_code">print_python_code</a></code></li>
<li><code><a title="DAVE.scene.Scene.resources_paths" href="#DAVE.scene.Scene.resources_paths">resources_paths</a></code></li>
<li><code><a title="DAVE.scene.Scene.save_scene" href="#DAVE.scene.Scene.save_scene">save_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.solve_statics" href="#DAVE.scene.Scene.solve_statics">solve_statics</a></code></li>
<li><code><a title="DAVE.scene.Scene.sort_nodes_by_dependency" href="#DAVE.scene.Scene.sort_nodes_by_dependency">sort_nodes_by_dependency</a></code></li>
<li><code><a title="DAVE.scene.Scene.static_tolerance" href="#DAVE.scene.Scene.static_tolerance">static_tolerance</a></code></li>
<li><code><a title="DAVE.scene.Scene.verbose" href="#DAVE.scene.Scene.verbose">verbose</a></code></li>
<li><code><a title="DAVE.scene.Scene.verify_equilibrium" href="#DAVE.scene.Scene.verify_equilibrium">verify_equilibrium</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Sheave" href="#DAVE.scene.Sheave">Sheave</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Sheave.axis" href="#DAVE.scene.Sheave.axis">axis</a></code></li>
<li><code><a title="DAVE.scene.Sheave.radius" href="#DAVE.scene.Sheave.radius">radius</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.TriMeshSource.AddFace" href="#DAVE.scene.TriMeshSource.AddFace">AddFace</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.AddVertex" href="#DAVE.scene.TriMeshSource.AddVertex">AddVertex</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.change_parent_to" href="#DAVE.scene.TriMeshSource.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.get_extends" href="#DAVE.scene.TriMeshSource.get_extends">get_extends</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.load_obj" href="#DAVE.scene.TriMeshSource.load_obj">load_obj</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.load_vtk_polydataSource" href="#DAVE.scene.TriMeshSource.load_vtk_polydataSource">load_vtk_polydataSource</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.make_cube" href="#DAVE.scene.TriMeshSource.make_cube">make_cube</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Visual" href="#DAVE.scene.Visual">Visual</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Visual.change_parent_to" href="#DAVE.scene.Visual.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.Visual.offset" href="#DAVE.scene.Visual.offset">offset</a></code></li>
<li><code><a title="DAVE.scene.Visual.parent" href="#DAVE.scene.Visual.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Visual.path" href="#DAVE.scene.Visual.path">path</a></code></li>
<li><code><a title="DAVE.scene.Visual.rotation" href="#DAVE.scene.Visual.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Visual.scale" href="#DAVE.scene.Visual.scale">scale</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>