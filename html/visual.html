<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>DAVE.visual API documentation</title>
<meta name="description" content="This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.visual</code></h1>
</header>
<section id="section-intro">
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/.">http://mozilla.org/MPL/2.0/.</a></p>
<p>Ruben de Bruin - 2019</p>
<p>Some tools</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Ruben de Bruin - 2019


  Some tools

&#34;&#34;&#34;

&#34;&#34;&#34;
visual visualizes a scene using vtkplotter


main class is VisualActor
this class contains a reference to a Node and a list of actors

a visual actor can be hidden by setting visible to False

each of the individual vtk-plotter actors has a &#34;actor_type&#34; property which is a enum ActorType

Note:
at this moment the outlines of the actors are created using a outline filter. This is expensive.
Probably more efficient to implement this using shaders. But only once VTK 9.0+ becomes standard as the shader
code will change.

&#34;&#34;&#34;

import vtkmodules.qt
vtkmodules.qt.PyQtImpl = &#39;PySide2&#39;

import vtkplotter as vp   # ref: https://github.com/marcomusy/vtkplotter
import DAVE.scene as vf
import DAVE.settings as vc
import vtk
import numpy as np
from enum import Enum

def transform_to_mat4x4(transform):
    mat4x4 = vtk.vtkMatrix4x4()
    for i in range(4):
        for j in range(4):
            mat4x4.SetElement(i, j, transform[j * 4 + i])
    return mat4x4

def transform_from_point(x,y,z):
    mat4x4 = vtk.vtkMatrix4x4()
    mat4x4.SetElement(0, 3, x)
    mat4x4.SetElement(1, 3, y)
    mat4x4.SetElement(2, 3, z)
    return mat4x4

def transform_from_direction(axis):
    &#34;&#34;&#34;
    Creates a transform that rotates the X-axis to the given direction
    Args:
        axis: requested direction

    Returns:
        vtk.vtkTransform
    &#34;&#34;&#34;
    theta = np.arccos(axis[2])
    phi = np.arctan2(axis[1], axis[0])
    t = vtk.vtkTransform()
    t.PostMultiply()
    # t.RotateX(90)  # put it along Z
    t.RotateY(np.rad2deg(theta))
    t.RotateZ(np.rad2deg(phi))

    return t


def apply_parent_tranlation_on_transform(parent, t):
    tr = parent.global_transform

    mat4x4 = vtk.vtkMatrix4x4()
    for i in range(4):
        for j in range(4):
            mat4x4.SetElement(i, j, tr[j * 4 + i])

    t.PostMultiply()
    t.Concatenate(mat4x4)

def actor_from_trimesh(trimesh):
    &#34;&#34;&#34;Creates a vtkplotter.Actor from a pyo3d.TriMesh&#34;&#34;&#34;

    if trimesh.nFaces == 0:
        return None

    vertices = []
    for i in range(trimesh.nVertices):
        vertices.append(trimesh.GetVertex(i))

    faces = []
    for i in range(trimesh.nFaces):
        faces.append(trimesh.GetFace(i))

    return vp.actors.Actor([vertices, faces]).alpha(vc.ALPHA_BUOYANCY)

def vp_actor_from_obj(filename):
    # load the data
    filename = str(filename)
    source = vtk.vtkOBJReader()
    source.SetFileName(filename)
    #clean the data
    con = vtk.vtkCleanPolyData()
    con.SetInputConnection(source.GetOutputPort())
    con.Update()
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(con.GetOutputPort())
    mapper.Update()
    # actor = vtk.vtkActor()
    # actor.SetMapper(mapper)
    vpa = vp.actors.Actor(mapper.GetInputAsDataSet())
    vpa.flat()
    return vpa

class ActorType(Enum):
    FORCE = 1
    VISUAL = 2
    GEOMETRY = 3
    GLOBAL = 4
    CABLE = 5
    NOT_GLOBAL = 6
    BALLASTTANK = 7

class VisualOutline:
    parent_vp_actor = None
    outline_actor = None
    outline_transform = None

class VisualActor:

    def __init__(self, actors, node):
        self.actors = actors  # vtkplotter actors
        self.node = node      # Node
        # self.visible = True
        self._original_colors = list()
        self._is_selected = False
        self._is_transparent = False

    def select(self):

        if self._is_selected:
            return

        self._original_colors = list()

        if self.node is not None:
            print(&#39;storing &#39; + str(self.node.name))
        else:
            print(&#39;storing properties&#39;)

        for actor in self.actors:
            self._original_colors.append(actor.color())
            actor.color(vc.COLOR_SELECT)

        self._is_selected = True


    def deselect(self):

        print(&#39;resetting original colors 1&#39;)

        if not self._is_selected:
            return

        print(&#39;resetting original colors 2&#39;)

        self._is_selected = False

        if self._original_colors:

            if self.node is not None:
                print(&#39;setting &#39; + str(self.node.name))
            else:
                print(&#39;setting properties&#39;)


            for actor, color in zip(self.actors, self._original_colors):
                actor.color(color)

        else:
            raise Exception(&#34;Original color not stored for visual belonging to {}&#34;.format(self.node.name))


    def make_transparent(self):

        if self._is_transparent:
            return

        for a in self.actors:
            a.alpha(0.4)

        self._is_transparent = True

    def reset_opacity(self):

        if not self._is_transparent:
            return

        for a in self.actors:
            if a.actor_type == ActorType.GLOBAL:
                a.alpha(0.4)
            else:
                a.alpha(1)

        self._is_transparent = False

    def set_dsa(self, d,s,a):
        for act in self.actors:
            act.lighting(diffuse=vc.VISUAL_DIFFUSE, ambient=vc.VISUAL_AMBIENT, specular=vc.VISUAL_SPECULAR, enabled=True)

    def on(self):
        for a in self.actors:
            a.on()

    def off(self):
        for a in self.actors:
            a.off()

    @property
    def visible(self):
        return self.actors[0].GetVisibility()


class Viewport:

    def __init__(self, scene, jupyter = False):
        self.scene = scene
        self.visuals = list()
        self.outlines = list()
        self.screen = None
        &#34;&#34;&#34;Becomes assigned when a screen is active (or was active...)&#34;&#34;&#34;

        self.global_visual = None
        &#34;&#34;&#34;Visuals for the global environment&#34;&#34;&#34;

        self.mouseLeftEvent = None
        self.mouseRightEvent = None

        self.Jupyter = jupyter

        # Settings
        self.show_geometry = True     # show or hide geometry objects (axis, pois, etc)
        self.show_force = True        # show or hide forces and connectors
        self.show_visual = True       # show or hide visuals
        self.show_global = False      # show or hide the environment (sea)
        self.force_do_normalize = True # Normalize force size to 1.0 for plotting
        self.force_scale = 1.6        # Scale to be applied on (normalized) force magnitude
        self.geometry_scale = 1.0          # poi radius of the pois
        self.outline_width = vc.OUTLINE_WIDTH      # line-width of the outlines (cell-like shading)
        self.cable_line_width = 3.0   # line-width used for cable elements

        self.quick_updates_only = False # Do not perform slow updates ( make animations quicker)

        self._wavefield = None
        &#34;&#34;&#34;WaveField object&#34;&#34;&#34;

    def update_outlines(self):
        if self.screen is None:
            return

        if self.quick_updates_only:
            for outline in self.outlines:
                outline.outline_actor.SetVisibility(False)
            return

        for outline in self.outlines:
            outline.outline_actor.SetVisibility(outline.parent_vp_actor.GetVisibility())

        # list of already existing outlines
        _outlines = [a.parent_vp_actor for a in self.outlines]

        # loop over actors, add outlines if needed
        for vp_actor in self.screen.actors:
            data = vp_actor.GetMapper().GetInputAsDataSet()
            if isinstance(data, vtk.vtkPolyData):
                # this actor can have an outline
                if vp_actor not in _outlines:
                    # create outline and add to self.outlines

                    tr = vtk.vtkTransformPolyDataFilter()

                    tr.SetInputData(data) # can we make a connection using port? (maintain the pipeline : see issue vtkplotter #48)
                                          # remark: Better to implement using shaders, but wait till VTK 9 because this will change the shader code.
                    temp = vtk.vtkTransform()
                    temp.Identity()
                    tr.SetTransform(temp)
                    tr.Update()

                    ol = vtk.vtkPolyDataSilhouette()
                    ol.SetInputConnection(tr.GetOutputPort())
                    ol.SetEnableFeatureAngle(True)
                    ol.SetCamera(self.screen.renderer.GetActiveCamera())
                    ol.SetBorderEdges(True)

                    mapper = vtk.vtkPolyDataMapper()
                    mapper.SetInputConnection(ol.GetOutputPort())

                    actor = vtk.vtkActor()
                    actor.SetMapper(mapper)
                    actor.GetProperty().SetColor(0, 0, 0)
                    actor.GetProperty().SetLineWidth(self.outline_width)

                    self.screen.renderer.AddActor(actor)  # vtk actor

                    # store
                    record = VisualOutline()
                    record.outline_actor = actor
                    record.outline_transform = tr
                    record.parent_vp_actor = vp_actor
                    self.outlines.append(record)

        # Update transforms for outlines
        to_be_deleted = []
        for record in self.outlines:
            # is the parent actor still present?
            if record.parent_vp_actor in self.screen.actors:
                # update transform
                userTransform = record.parent_vp_actor.GetUserTransform()

                if userTransform is not None:
                    matrix = userTransform.GetMatrix()
                else:
                    matrix = vtk.vtkMatrix4x4()

                trans = vtk.vtkTransform()
                trans.Identity()
                trans.Concatenate(matrix)
                trans.Scale(record.parent_vp_actor.GetScale())

                record.outline_transform.SetTransform(trans)

                record.outline_actor.SetVisibility(record.parent_vp_actor.GetVisibility())

            else:
                # mark for deletion
                to_be_deleted.append(record)

        # Remove obsolete outlines

        for record in to_be_deleted:
            # remove actor
            self.screen.renderer.RemoveActor(record.outline_actor)
            self.outlines.remove(record)



    def create_world_actors(self):

        world_actors = []

        plane = vp.Plane(pos=(0,0,0), normal=(0,0,1), sx=1000, sy=1000).c(vc.COLOR_WATER)
        plane.texture(vc.TEXTURE_SEA)
        plane.lighting(ambient=1.0, diffuse=0.0, specular=0.0)
        plane.alpha(0.4)

        world_actors.append(plane)
        world_actors[0].actor_type = ActorType.GLOBAL

        if self.show_global:
            world_actors[0].on()
        else:
            world_actors[0].off()

        world_actors.append(vp.Line((0, 0, 0), (10, 0, 0)).c(&#39;red&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        world_actors.append(vp.Line((0, 0, 0), (0, 10, 0)).c(&#39;green&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        world_actors.append(vp.Line((0, 0, 0), (0, 0, 10)).c(&#39;blue&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        v = VisualActor(world_actors, None)
        self.visuals.append(v)

        self.global_visual = v

    def deselect_all(self):
        for v in self.visuals:
            v.deselect()

    def node_from_vtk_actor(self, actor):
        &#34;&#34;&#34;
        Given a vkt actor, find the corresponding node
        Args:
            actor: vtkActor

        Returns:

        &#34;&#34;&#34;
        for v in self.visuals:
            for a in v.actors:
                if a == actor:
                    return v.node
        return None

    def actor_from_node(self, node):
        &#34;&#34;&#34;Finds the VisualActor belonging to node&#34;&#34;&#34;
        for v in self.visuals:
            if v.node is node:
                return v
        return None

    def add_dynamic_wave_plane(self, waveplane):
        self.remove_dynamic_wave_plane()
        self.screen.renderer.AddActor(waveplane.actor)
        self._wavefield = waveplane

        if self.global_visual.visible:
            self._staticwaveplane = True
            self.global_visual.off()
        else:
            self._staticwaveplane = False

    def remove_dynamic_wave_plane(self):
        if self._wavefield is not None:
            self.screen.renderer.RemoveActor(self._wavefield.actor)
            self._wavefield = None

            if self._staticwaveplane:
                self.global_visual.on()




    def update_dynamic_waveplane(self, t):
        if self._wavefield is not None:
            self._wavefield.update(t)


    def hide_actors_of_type(self, types):
        for V in self.visuals:
            for A in V.actors:
                if A.actor_type in types:
                    A.off()


    def show_actors_of_type(self, types):
        for V in self.visuals:
            for A in V.actors:
                    if A.actor_type in types:
                        A.on()

    def set_alpha(self, alpha, exclude_nodes=None):
        &#34;&#34;&#34;Sets the alpha (transparency) of for ALL actors in all visuals except the GLOBAL actors or visuals belonging to a node in exclude_nodes&#34;&#34;&#34;

        if exclude_nodes is None:
            exclude_nodes = []
        for V in self.visuals:
            for A in V.actors:

                if V.node in exclude_nodes:
                    continue

                if A.actor_type == ActorType.GLOBAL:
                    continue
                A.alpha(alpha)


    def level_camera(self):
        self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer().GetActiveCamera().SetViewUp([0, 0, 1])
        self.refresh_embeded_view()


    def toggle_2D(self):
        camera = self.renderer.GetActiveCamera()
        if camera.GetParallelProjection():
            camera.ParallelProjectionOff()
        else:
            camera.ParallelProjectionOn()


    def _scaled_force_vector(self, vector):

        r = np.array(vector)
        len = np.linalg.norm(r)
        if len == 0:
            return r
        if self.force_do_normalize:
            r *= (1000/len)
        r *= (self.force_scale / 1000)
        return r



    def create_visuals(self, recreate = False):
        &#34;&#34;&#34;Visuals are created in their parent axis system

        Attributes:
            recreate : re-create already exisiting visuals
        &#34;&#34;&#34;

        for N in self.scene._nodes:

            if not recreate:
                try:            # if we already have a visual, then no need to create another one
                    N.visual
                    if N.visual is not None:
                        continue
                except:
                    pass

            actors = []

            if isinstance(N, vf.Buoyancy):

                # 0 : source-mesh
                # 1 : cob
                # 2 : water-plane
                # 3 : sumberged mesh

                # This is the source-mesh. Connect it to the parent
                vis = actor_from_trimesh(N.trimesh._TriMesh)

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    vis = vp.Cube(side=0.00001)
                else:
                    vis.c(vc.COLOR_BUOYANCY_MESH_FILL)

                vis.actor_type = ActorType.FORCE

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    vis.wireframe()

                if vis is not None:
                    actors.append(vis)

                # cob
                c = vp.Sphere(r=0.5, res = vc.RESOLUTION_SPHERE).c(vc.COLOR_WATER)
                c.actor_type = ActorType.FORCE
                actors.append(c)

                # waterplane
                exts = N.trimesh.get_extends()

                cx = 0.5 * (exts[0] + exts[1])
                dx = exts[1] - exts[0]
                cy = 0.5 * (exts[3] + exts[2])
                dy = exts[3] - exts[2]

                p = vp.Plane(pos = (cx,cy,0), normal = (0,0,1), sx = dx*1.1, sy = dy*1.1).c(vc.COLOR_WATER)
                p.actor_type = ActorType.NOT_GLOBAL
                actors.append(p)


            if isinstance(N, vf.Visual):
                file = self.scene.get_resource_path(N.path)
                # visual = vp.vtkio.load(file)
                visual = vp_actor_from_obj(file)
                visual.color(vc.COLOR_VISUAL)
                visual.loaded_obj = file
                visual.actor_type = ActorType.VISUAL
                actors.append(visual)


            if isinstance(N, vf.Axis):
                size = 1
                ar = vp.Arrow((0,0,0),(size,0,0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_X)
                ag = vp.Arrow((0, 0, 0), (0, size, 0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Y)
                ab = vp.Arrow((0, 0, 0), (0, 0, size), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Z)

                ar.actor_type = ActorType.GEOMETRY
                ag.actor_type = ActorType.GEOMETRY
                ab.actor_type = ActorType.GEOMETRY

                actors.append(ar)
                actors.append(ag)
                actors.append(ab)

            if isinstance(N, vf.RigidBody):
                size = 1
                # box = vp.Box(pos=(0,0,0), length=size, width=size, height= size).c(vc.COLOR_COG)

                box = vp_actor_from_obj(self.scene.get_resource_path(&#39;cog.obj&#39;))
                box.color(vc.COLOR_COG)

                box.actor_type = ActorType.FORCE
                actors.append(box)

            if isinstance(N, vf.Poi):
                size = 1
                p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
                p.c(vc.COLOR_POI)
                p.actor_type = ActorType.GEOMETRY
                actors.append(p)

            if isinstance(N, vf.WaveInteraction1):
                size = 2
                p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
                p.c(vc.COLOR_WAVEINTERACTION)
                p.actor_type = ActorType.FORCE
                actors.append(p)

            if isinstance(N, vf.BallastSystem):

                for t in N._tanks:

                    capacity = t.max
                    volume = capacity / (1.025 * 9.81)
                    side = volume**(1/3)
                    scale = 0.5

                    p = vp.Cube(pos=(0,0,0), side=0.5*side*scale)
                    p.c(vc.COLOR_POI)
                    p.actor_type = ActorType.BALLASTTANK
                    actors.append(p)

            if isinstance(N, vf.Force):

                endpoint = self._scaled_force_vector(N.force)
                p = vp.Arrow(startPoint=(0,0,0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.c(vc.COLOR_FORCE)
                p.actor_type = ActorType.FORCE
                p._force = endpoint

                actors.append(p)

                endpoint = self._scaled_force_vector(N.moment)
                p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p._moment = endpoint
                p.c(vc.COLOR_FORCE)
                actors.append(p)

                p = vp.Arrow(startPoint = 0.2 * endpoint, endPoint= 1.2 * endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p.c(vc.COLOR_FORCE)
                actors.append(p)

            if isinstance(N, vf.Sheave):
                axis = np.array(N.axis)
                axis /= np.linalg.norm(axis)
                p = vp.Cylinder(r=1)
                p.c(vc.COLOR_SHEAVE)
                p.actor_type = ActorType.GEOMETRY

                actors.append(p)

            if isinstance(N, vf.Cable):

                if N._vfNode.global_points:
                    a = vp.Line(N._vfNode.global_points, lw=3).c(vc.COLOR_CABLE)
                else:
                    a = vp.Line([(0,0,0),(0,0,0.1),(0,0,0)], lw=3).c(vc.COLOR_CABLE)

                a.actor_type = ActorType.CABLE
                actors.append(a)

            if isinstance(N, vf.LinearBeam):

                points = list()

                for i in range(4):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_BEAM)
                a.actor_type = ActorType.CABLE

                actors.append(a)

            if isinstance(N, vf.Connector2d):

                points = list()

                for i in range(2):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
                a.actor_type = ActorType.CABLE

                actors.append(a)

            if isinstance(N, vf.LC6d):

                points = list()

                for i in range(2):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
                a.actor_type = ActorType.CABLE

                actors.append(a)



            va = VisualActor(actors, N)
            N.visual = va
            self.visuals.append(va)

            self.set_default_dsa()

    def position_visuals(self):
        &#34;&#34;&#34;All visuals are aligned with their node&#34;&#34;&#34;

        to_be_removed = []
        to_be_removed_actors = []

        for V in self.visuals:

            # check if the node still exists
            # if not, then remove the visual

            node = V.node
            if node not in self.scene._nodes:
                if len(V.actors) &gt; 0:  # not all nodes have an actor
                    if V.actors[0].actor_type != ActorType.GLOBAL:  # global visuals do not have a corresponding node
                        to_be_removed.append(V)
                        continue
                else:
                    to_be_removed.append(V)
                    continue  # node does not have an actor


            # create a transform from the Node
            # or the parent of the Node
            # or skip (for example a poi without a parent)

            if V.node is None:
                continue

            if isinstance(V.node, vf.Visual):
                A = V.actors[0]

                # get the local (user set) transform
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.offset)
                t.Scale(V.node.scale)

                # # scale offset
                # scaled_offset = [V.node.offset[i] / V.node.scale[i] for i in range(3)]


                # calculate wxys from node.rotation
                r= V.node.rotation
                angle = (r[0]**2 + r[1]**2 + r[2]**2)**(0.5)
                if angle &gt; 0:
                    t.RotateWXYZ(angle, r[0]/angle, r[1]/angle, r[2]/angle)

                # elm_matrix = t.GetMatrix()

                # Get the parent matrix (if any)
                if V.node.parent is not None:
                    apply_parent_tranlation_on_transform(V.node.parent, t)

                A.setTransform(t.GetMatrix())
                continue

            if isinstance(V.node, vf.Sheave):
                A = V.actors[0]

                # get the local (user set) transform
                t = vtk.vtkTransform()
                t.Identity()

                # scale to flat disk
                t.Scale(V.node.radius, V.node.radius, 0.1)

                # rotate z-axis (length axis is cylinder) is direction of axis
                axis = V.node.axis / np.linalg.norm(V.node.axis)
                z = (0,0,1)
                rot_axis = np.cross(z, axis)
                rot_dot = np.dot(z,axis)
                if rot_dot &gt; 1:
                    rot_dot = 1
                if rot_dot &lt; -1:
                    rot_dot = -1

                angle = np.arccos(rot_dot)

                t.PostMultiply()
                t.RotateWXYZ(np.rad2deg(angle), rot_axis)

                t.Translate(V.node.parent.position)

                # Get the parent matrix (if any)
                if V.node.parent.parent is not None:
                    apply_parent_tranlation_on_transform(V.node.parent.parent, t)

                

                A.setTransform(t.GetMatrix())
                continue

            if isinstance(V.node, vf.Cable):

                # # check the number of points
                A = V.actors[0]

                # points = list()
                # for p in V.node._pois:
                #     points.append(p.global_position)

                points = V.node.get_points_for_visual()
                
                if len(points)==0:  # not yet created
                    continue

                n_points = A.NPoints()
                A.setPoints(points)   # points can be set without allocation

                if n_points != len(points): # equal number of points
                    # different number of points in line
                    # (re-create the poly-line)
                    lines = vtk.vtkCellArray()  # Create the polyline.
                    lines.InsertNextCell(len(points))
                    for i in range(len(points)):
                        # print(&#39;inserting point {} {} {}&#39;.format(*i))
                        lines.InsertCellPoint(i)
                    A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.LinearBeam):

                # Each beam is visualized using FOUR points being
                # 0. Endpoint A
                # 1. local position (0.1*L,0,0) on endpoint A
                # 2. local position (-0.1*L,0,0) on endpoint B
                # 3. Endpoint B

                A = V.actors[0]

                d = 0

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.master.to_glob_position((d*node.L, 0, 0)))
                points.append(node.slave.to_glob_position((-d * node.L, 0, 0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))


                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.Connector2d):
                A = V.actors[0]

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))

                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.LC6d):
                A = V.actors[0]

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))

                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue


            if isinstance(V.node, vf.BallastSystem):
                for i,tnk in enumerate(V.node._tanks):

                    ia = i + 1

                    t = vtk.vtkTransform()
                    t.Identity()
                    local_position = np.array(V.node.position, dtype=float) + np.array(tnk.position, dtype=float)
                    pos = V.node.parent.to_glob_position(local_position)
                    t.Translate(pos)
                    V.actors[ia].setTransform(t)
                    V.actors[ia].SetScale(4)

                    if tnk.is_partial():
                        V.actors[ia].color([1,1,0])
                    if tnk.is_full():
                        V.actors[ia].color([0,0,0.2])
                    if tnk.is_empty():
                        V.actors[ia].color([0.8,0.9,1])


            if isinstance(V.node, vf.Poi):
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.global_position)
                V.actors[0].setTransform(t)
                V.actors[0].SetScale(self.geometry_scale)
                continue

            if isinstance(V.node, vf.WaveInteraction1):
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.parent.to_glob_position(V.node.offset))
                V.actors[0].setTransform(t)
                V.actors[0].SetScale(self.geometry_scale)
                continue


            if isinstance(V.node, vf.Force):

                # check is the arrows are still what they should be
                if not np.all(V.actors[0]._force == self._scaled_force_vector(V.node.force)):

                    self.screen.remove(V.actors[0])

                    endpoint = self._scaled_force_vector(V.node.force)


                    p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p._force = endpoint
                    p.c(vc.COLOR_FORCE)

                    V.actors[0] = p
                    self.screen.add(V.actors[0])

                # check is the arrows are still what they should be
                if not np.all(np.array(V.actors[1]._moment) == self._scaled_force_vector(V.node.moment)):
                    self.screen.remove(V.actors[1])
                    self.screen.remove(V.actors[2])

                    endpoint = self._scaled_force_vector(V.node.moment)
                    p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p._moment = endpoint
                    p.c(vc.COLOR_FORCE)
                    V.actors[1] = p

                    p = vp.Arrow(startPoint=0.2 * endpoint, endPoint=1.2 * endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p.c(vc.COLOR_FORCE)
                    V.actors[2] = p
                    self.screen.add(V.actors[1])
                    self.screen.add(V.actors[2])

                t = V.actors[0].getTransform()
                t.Identity()
                t.Translate(V.node.parent.global_position)
                for a in V.actors:
                    a.setTransform(t)

                continue

            if isinstance(V.node, vf.RigidBody):

                # Some custom code to place and scale the Actor[3] of the body.
                # This actor should be placed at the CoG position and scaled to a solid steel block

                t = vtk.vtkTransform()
                t.Identity()

                scale = V.node.mass / 8050  # density of steel

                if scale &lt; 0.8:
                    scale = 0.8

                t.Translate(V.node.cog)
                mat4x4 = transform_to_mat4x4(V.node.global_transform)

                for A in V.actors:
                    A.setTransform(mat4x4)

                t.PostMultiply()
                t.Concatenate(mat4x4)

                V.actors[3].SetScale(scale)
                V.actors[3].setTransform(t)

                # scale the arrows
                V.actors[0].SetScale(self.geometry_scale)
                V.actors[1].SetScale(self.geometry_scale)
                V.actors[2].SetScale(self.geometry_scale)

                continue

            if isinstance(V.node, vf.Buoyancy):

                # move the full mesh with the parent
                mat4x4 = transform_to_mat4x4(V.node.parent.global_transform)
                current_transform = V.actors[0].getTransform().GetMatrix()

                # if the current transform is identical to the new one,
                # then we do not need to change anything (creating the mesh is slow)

                changed = False
                for i in range(4):
                    for j in range(4):
                        if current_transform.GetElement(i,j) != mat4x4.GetElement(i,j):
                            changed = True

                if not changed:
                    continue

                V.actors[0].setTransform(mat4x4)
                V.actors[0].alpha(vc.ALPHA_BUOYANCY)

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    V.actors[0].c(vc.COLOR_BUOYANCY_MESH_LINES)
                    V.actors[0].wireframe()

                if self.quick_updates_only:
                    for a in V.actors:
                        a.off()
                    continue
                else:
                    for a in V.actors:
                        a.on()

                # move the CoB to the new (global!) position
                cob = V.node.cob
                V.actors[1].setTransform(transform_from_point(*cob))
                if V.node.displacement == 0:
                    V.actors[1].off()
                else:
                    V.actors[1].on()

                # update water-plane
                x1,x2,y1,y2,_,_ = V.node.trimesh.get_extends()
                x1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
                x2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
                y1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
                y2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
                p1 = V.node.parent.to_glob_position((x1,y1,0))
                p2 = V.node.parent.to_glob_position((x2, y1, 0))
                p3 = V.node.parent.to_glob_position((x2, y2, 0))
                p4 = V.node.parent.to_glob_position((x1, y2, 0))

                V.actors[2].setPoint(0,(p1[0],p1[1], 0))
                V.actors[2].setPoint(1,(p2[0],p2[1], 0))
                V.actors[2].setPoint(2,(p4[0],p4[1], 0))
                V.actors[2].setPoint(3,(p3[0],p3[1], 0))

                # create the actual buoyancy mesh as a new actor

                if len(V.actors) &gt; 3:
                    if self.screen is not None:
                        self.screen.remove(V.actors[3])
                        V.actors.remove(V.actors[3])

                mesh = V.node._vfNode.current_mesh

                if mesh.nVertices &gt; 0:  # only add when available

                    vertices = []
                    for i in range(mesh.nVertices):
                        vertices.append(mesh.GetVertex(i))

                    faces = []
                    for i in range(mesh.nFaces):
                        faces.append(mesh.GetFace(i))

                    # vis = vp.actors.Actor([vertices, faces], wire=True).c((0, 0, 1))
                    vis = vp.actors.Actor([vertices, faces]).c(vc.COLOR_BUOYANCY_MESH_LINES)
                    vis.actor_type = ActorType.FORCE
                    vis.wireframe()
                    vis.lw(vc.LINEWIDTH_SUBMERGED_MESH)
                    V.actors.append(vis)
                    if self.screen is not None:
                        self.screen.add(vis)

                continue

            if isinstance(V.node, vf.Axis):
                tr = transform_to_mat4x4(V.node.global_transform)
                for a in V.actors:
                    a.SetScale(self.geometry_scale)
                    a.setTransform(tr)

                continue

            # --- default ---

            try:
                tr = V.node.global_transform
            except AttributeError:
                try:
                    tr = V.node.parent.global_transform
                except AttributeError:
                    continue

            mat4x4 = transform_to_mat4x4(tr)

            for A in V.actors:
                A.setTransform(mat4x4)


        for V in to_be_removed:
            self.visuals.remove(V)
            self.screen.remove(V.actors)



        self.update_outlines()

    def add_new_actors_to_screen(self):
        &#34;&#34;&#34;Updates the screen with added actors&#34;&#34;&#34;

        to_be_added = []

        if self.screen:

            actors = self.screen.getActors()
            for va in self.visuals:
                for a in va.actors:
                    if not (a in actors):
                        to_be_added.append(a)
                        # self.screen.add(a)   # do not add directly to avoid frequent updates
                        #print(&#39;adding actor for {}&#39;.format(va.node.name))
            self.screen.add(to_be_added)

            # check if objs need to be re-loaded
            for va in self.visuals:
                if isinstance(va.node, vf.Visual):

                    try:
                        file = self.scene.get_resource_path(va.node.path)
                    except FileExistsError:
                        continue

                    if file == va.actors[0].loaded_obj:
                        continue

                    self.screen.clear(va.actors[0])

                    # update the obj
                    va.actors[0] = vp_actor_from_obj(file)
                    va.actors[0].loaded_obj = file
                    va.actors[0].color(vc.COLOR_VISUAL)
                    va.actors[0].actor_type = ActorType.VISUAL

                    self.screen.add(va.actors[0])

                if isinstance(va.node, vf.Buoyancy):
                    if va.node.trimesh._new_mesh:

                        new_mesh = actor_from_trimesh(va.node.trimesh._TriMesh)
                        if new_mesh is not None:
                            self.screen.clear(va.actors[0])
                            va.actors[0] = new_mesh
                            va.actors[0].actor_type = ActorType.FORCE
                            self.screen.add(va.actors[0])
                            va.node.trimesh._new_mesh = False


            self.set_default_dsa()



    def shutdown_qt(self):
        &#34;&#34;&#34;Stops the renderer such that the application can close without issues&#34;&#34;&#34;

        if self.vtkWidget:
            ren = self.vtkWidget.GetRenderWindow()
            iren = ren.GetInteractor()
            ren.Finalize()
            iren.TerminateApp()


    def screenshot(self, w=800, h=600,camera_pos=(50,-25,10), lookat = (0,0,0)):
        vp.settings.lightFollowsCamera = True

        _notebook = vp.settings.notebookBackend
        vp.settings.notebookBackend = False
        vp.settings.screeshotScale = 2

        self.create_world_actors()

        camera = dict()
        camera[&#39;viewup&#39;] = [0, 0, 1]
        camera[&#39;pos&#39;] = camera_pos
        camera[&#39;focalPoint&#39;] = lookat



        offscreen = vp.Plotter(axes=0, offscreen=True, size=(h,w))

        for va in self.visuals:
            for a in va.actors:
                if a.GetVisibility():
                    offscreen.add(a)

        offscreen.show(camera=camera)

        for r in offscreen.renderers:
            r.SetBackground(1,1,1)
            r.UseFXAAOn()

        self.update_outlines()

        filename = str(vc.PATH_TEMP_SCREENSHOT)

        vp.screenshot(filename)

        vp.settings.notebookBackend = _notebook

        from IPython.display import Image, display
        display(Image(filename))

        # import matplotlib.pyplot as plt
        # plt.figure(figsize=(w/300,h/300), dpi=300)
        # plt.imshow(plt.imread(filename))
        #
        # plt.axis(False)
        # plt.show()

    def show(self, qtWidget = None):

        vp.settings.lightFollowsCamera = True

        self.create_world_actors()

        camera = dict()
        camera[&#39;viewup&#39;] = [0, 0, 1]
        camera[&#39;pos&#39;] = [10, -10, 5]
        camera[&#39;focalPoint&#39;] = [0, 0, 0]

        if self.Jupyter:
            vp.settings.embedWindow()
            screen = vp.Plotter(axes = 4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

            # screen.add(self.create_world_actors())
            # self.create_world_actors()

            for va in self.visuals:
                for a in va.actors:
                    if a.GetVisibility():
                        screen.add(a)

            self.screen = screen
            return screen.show(camera=camera)

        else:

            if qtWidget is None:
                screen = vp.plotter.Plotter(interactive=True, offscreen=False,
                    axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)
            else:
                screen = vp.plotter.Plotter(qtWidget=qtWidget,
                                            axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

            for va in self.visuals:
                for a in va.actors:
                    screen.add(a)

        screen.show(camera=camera, verbose = False)

        self.screen = screen

        for r in screen.renderers:
            r.ResetCamera()

        self.update_outlines()

        return screen

    def onMouseLeft(self, info):
        if self.mouseLeftEvent is not None:
            self.mouseLeftEvent(info)

    def zoom_all(self):
        for r in self.screen.renderers:
            r.ResetCamera()



    def onMouseRight(self, info):
        if self.mouseRightEvent is not None:
            self.mouseRightEvent(info)

    def make_lighter(self):
        &#34;&#34;&#34;Increase light intensity for embedded mode&#34;&#34;&#34;
        C = self.light.GetIntensity()
        C += 0.05
        self.light.SetIntensity(C)
        print(&#39;Light intensity = {}&#39;.format(C))
        self.refresh_embeded_view()

    def make_darker(self):
        &#34;&#34;&#34;Decrease light intensity for embedded mode&#34;&#34;&#34;
        C = self.light.GetIntensity()
        C -= 0.05
        if C &lt;= 0:
            C = 0
        self.light.SetIntensity(C)
        print(&#39;Light intensity = {}&#39;.format(C))
        self.refresh_embeded_view()

    def show_embedded(self, target_frame):
        &#34;&#34;&#34;target frame : QFrame &#34;&#34;&#34;

        from PySide2.QtWidgets import QVBoxLayout
        from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

        # add a widget to gui
        vl = QVBoxLayout()
        self.target_frame = target_frame
        self.vtkWidget = QVTKRenderWindowInteractor(target_frame)

        vl.addWidget(self.vtkWidget)
        target_frame.setLayout(vl)

        screen = self.show(qtWidget=self.vtkWidget)

        self.renwin = self.vtkWidget.GetRenderWindow()
        self.renderer = screen.renderers[0]

        self.renwin.AddRenderer(self.renderer)

        # for r in screen.renderers:
        #     self.renwin.AddRenderer(r)

        iren = self.renwin.GetInteractor()
        iren.SetInteractorStyle(vtk.vtkInteractorStyleTrackballCamera())

        iren.AddObserver(&#34;LeftButtonPressEvent&#34;, screen._mouseleft)
        iren.AddObserver(&#34;RightButtonPressEvent&#34;, screen._mouseright)
        iren.AddObserver(&#34;MiddleButtonPressEvent&#34;, screen._mousemiddle)

        for r in screen.renderers:
            r.ResetCamera()

        iren.Start()

        screen.mouseLeftClickFunction = self.onMouseLeft
        screen.mouseRightClickFunction = self.onMouseRight

        # Add some lights


        light1 = vtk.vtkLight()

        light1.SetIntensity(0.3)
        light1.SetLightTypeToCameraLight()
        light1.SetPosition(100, 100, 100)

        self.renderer.AddLight(light1)

        self.light = light1


    def refresh_embeded_view(self):
        self.vtkWidget.update()

    def update_visibility(self):
        &#34;&#34;&#34;Updates the visibility settings for all of the actors

        A visual can be hidden completely by setting visible to false
        An actor can be hidden depending on the actor-type using

        self.show_geometry = True
        self.show_force = True
        self.show_visual = True
        self.show_global = False

        &#34;&#34;&#34;

        for v in self.visuals:
            for i,a in enumerate(v.actors):

                try:
                    a.actor_type
                except:
                    raise AttributeError(&#39;Missing actor_type for actor nr {} on node {}&#39;.format(i, v.node.name))

                if a.actor_type == ActorType.FORCE:
                    if self.show_force:
                        a.on()
                    else:
                        a.off()

                elif a.actor_type == ActorType.VISUAL:
                    if self.show_visual:
                        a.on()
                    else:
                        a.off()

                elif a.actor_type == ActorType.GEOMETRY:
                    if self.show_geometry:
                        a.on()

                    else:
                        a.off()

                elif a.actor_type == ActorType.GLOBAL:
                    if self.show_global:
                        a.on()

                        arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                        arenderer.GradientBackgroundOn()
                        arenderer.SetBackground2(vc.COLOR_BG2_ENV)
                        arenderer.SetBackground2(vc.COLOR_BG1_ENV)
                    else:
                        a.off()

                        arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                        arenderer.GradientBackgroundOn()
                        arenderer.SetBackground2(vc.COLOR_BG2)
                        arenderer.SetBackground2(vc.COLOR_BG1)

                elif a.actor_type == ActorType.NOT_GLOBAL:
                    if self.show_global:
                        a.off()
                    else:
                        a.on()



                # Cables are a separate class

                elif a.actor_type == ActorType.CABLE:
                    if self.show_visual or self.show_force:
                        a.on()
                    else:
                        a.off()

        self.update_outlines()


    def set_dsa(self, d,s,a):
        for v in self.visuals:
            v.set_dsa(d,s,a)

    def set_default_dsa(self):
        self.set_dsa(vc.VISUAL_DIFFUSE, vc.VISUAL_SPECULAR, vc.VISUAL_AMBIENT)


class WaveField():

    def __init__(self):
        self.actor = None
        self.pts = None
        self.nt = 0
        self.elevation = None

        self.texture = vtk.vtkTexture()
        input = vtk.vtkJPEGReader()
        input.SetFileName(vc.TEXTURE_SEA)
        self.texture.SetInputConnection(input.GetOutputPort())
        self.ttp = vtk.vtkTextureMapToPlane()


    def update(self, t):
        t = np.mod(t, self.period)
        i = int(self.nt * t/self.period)

        count = 0
        for ix,xx in enumerate(self.x):
            for iy, yy in enumerate(self.y):
                self.pts.SetPoint(count, xx,yy,self.elevation[iy,ix,i])
                count += 1
        self.pts.Modified()

    def create_waveplane(self, wave_direction, wave_amplitude, wave_length, wave_period, nt, nx, ny, dx,dy):

        x = np.linspace(-dx, dx, nx)
        y = np.linspace(-dy, dy, ny)
        xv, yv = np.meshgrid(x, y)

        u = np.array((np.cos(np.deg2rad(wave_direction)), np.sin(np.deg2rad(wave_direction))))

        dist_phasor = np.exp(1j * (xv*u[0] + yv*u[1]) * (2*np.pi/ wave_length))

        t = np.linspace(0,wave_period, nt)
        time_phasor = np.exp(-1j * (2 * np.pi * t / wave_period))

        elevation = np.zeros((*xv.shape, nt))

        for i in range(nt):
            elevation[:,:,i] = wave_amplitude * np.real(time_phasor[i] * dist_phasor)


        # the vtk stuff

        # make grid
        pts = vtk.vtkPoints()
        for ix,xx in enumerate(x):
            for iy, yy in enumerate(y):
                pts.InsertNextPoint(yy,xx,elevation[iy,ix,1])

        grid = vtk.vtkStructuredGrid()
        grid.SetDimensions(ny,nx,1)
        grid.SetPoints(pts)

        # make mapper
        filter = vtk.vtkStructuredGridGeometryFilter()
        filter.SetInputData(grid)

        # texture stuff
        self.ttp.SetInputConnection(filter.GetOutputPort())

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(self.ttp.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)
        actor.SetTexture(self.texture)

        actor.GetProperty().SetAmbient(1.0)
        actor.GetProperty().SetDiffuse(0.0)
        actor.GetProperty().SetSpecular(0.0)

        self.pts = pts
        self.actor = actor
        self.elevation = elevation
        self.nt = nt
        self.period = wave_period
        self.x = x
        self.y = y


if __name__ == &#34;__main__&#34;:

    v = WaveField()
    v.create_waveplane(90,1,10,6, 50, 100,2,100,100)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DAVE.visual.actor_from_trimesh"><code class="name flex">
<span>def <span class="ident">actor_from_trimesh</span></span>(<span>trimesh)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a vtkplotter.Actor from a pyo3d.TriMesh</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actor_from_trimesh(trimesh):
    &#34;&#34;&#34;Creates a vtkplotter.Actor from a pyo3d.TriMesh&#34;&#34;&#34;

    if trimesh.nFaces == 0:
        return None

    vertices = []
    for i in range(trimesh.nVertices):
        vertices.append(trimesh.GetVertex(i))

    faces = []
    for i in range(trimesh.nFaces):
        faces.append(trimesh.GetFace(i))

    return vp.actors.Actor([vertices, faces]).alpha(vc.ALPHA_BUOYANCY)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.apply_parent_tranlation_on_transform"><code class="name flex">
<span>def <span class="ident">apply_parent_tranlation_on_transform</span></span>(<span>parent, t)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_parent_tranlation_on_transform(parent, t):
    tr = parent.global_transform

    mat4x4 = vtk.vtkMatrix4x4()
    for i in range(4):
        for j in range(4):
            mat4x4.SetElement(i, j, tr[j * 4 + i])

    t.PostMultiply()
    t.Concatenate(mat4x4)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.transform_from_direction"><code class="name flex">
<span>def <span class="ident">transform_from_direction</span></span>(<span>axis)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a transform that rotates the X-axis to the given direction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong></dt>
<dd>requested direction</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>vtk.vtkTransform</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_from_direction(axis):
    &#34;&#34;&#34;
    Creates a transform that rotates the X-axis to the given direction
    Args:
        axis: requested direction

    Returns:
        vtk.vtkTransform
    &#34;&#34;&#34;
    theta = np.arccos(axis[2])
    phi = np.arctan2(axis[1], axis[0])
    t = vtk.vtkTransform()
    t.PostMultiply()
    # t.RotateX(90)  # put it along Z
    t.RotateY(np.rad2deg(theta))
    t.RotateZ(np.rad2deg(phi))

    return t</code></pre>
</details>
</dd>
<dt id="DAVE.visual.transform_from_point"><code class="name flex">
<span>def <span class="ident">transform_from_point</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_from_point(x,y,z):
    mat4x4 = vtk.vtkMatrix4x4()
    mat4x4.SetElement(0, 3, x)
    mat4x4.SetElement(1, 3, y)
    mat4x4.SetElement(2, 3, z)
    return mat4x4</code></pre>
</details>
</dd>
<dt id="DAVE.visual.transform_to_mat4x4"><code class="name flex">
<span>def <span class="ident">transform_to_mat4x4</span></span>(<span>transform)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_to_mat4x4(transform):
    mat4x4 = vtk.vtkMatrix4x4()
    for i in range(4):
        for j in range(4):
            mat4x4.SetElement(i, j, transform[j * 4 + i])
    return mat4x4</code></pre>
</details>
</dd>
<dt id="DAVE.visual.vp_actor_from_obj"><code class="name flex">
<span>def <span class="ident">vp_actor_from_obj</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vp_actor_from_obj(filename):
    # load the data
    filename = str(filename)
    source = vtk.vtkOBJReader()
    source.SetFileName(filename)
    #clean the data
    con = vtk.vtkCleanPolyData()
    con.SetInputConnection(source.GetOutputPort())
    con.Update()
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(con.GetOutputPort())
    mapper.Update()
    # actor = vtk.vtkActor()
    # actor.SetMapper(mapper)
    vpa = vp.actors.Actor(mapper.GetInputAsDataSet())
    vpa.flat()
    return vpa</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="DAVE.visual.ActorType"><code class="flex name class">
<span>class <span class="ident">ActorType</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActorType(Enum):
    FORCE = 1
    VISUAL = 2
    GEOMETRY = 3
    GLOBAL = 4
    CABLE = 5
    NOT_GLOBAL = 6
    BALLASTTANK = 7</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="DAVE.visual.ActorType.BALLASTTANK"><code class="name">var <span class="ident">BALLASTTANK</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.CABLE"><code class="name">var <span class="ident">CABLE</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.FORCE"><code class="name">var <span class="ident">FORCE</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.GEOMETRY"><code class="name">var <span class="ident">GEOMETRY</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.GLOBAL"><code class="name">var <span class="ident">GLOBAL</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.NOT_GLOBAL"><code class="name">var <span class="ident">NOT_GLOBAL</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
<dt id="DAVE.visual.ActorType.VISUAL"><code class="name">var <span class="ident">VISUAL</span></code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
</dd>
</dl>
</dd>
<dt id="DAVE.visual.Viewport"><code class="flex name class">
<span>class <span class="ident">Viewport</span></span>
<span>(</span><span>scene, jupyter=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Viewport:

    def __init__(self, scene, jupyter = False):
        self.scene = scene
        self.visuals = list()
        self.outlines = list()
        self.screen = None
        &#34;&#34;&#34;Becomes assigned when a screen is active (or was active...)&#34;&#34;&#34;

        self.global_visual = None
        &#34;&#34;&#34;Visuals for the global environment&#34;&#34;&#34;

        self.mouseLeftEvent = None
        self.mouseRightEvent = None

        self.Jupyter = jupyter

        # Settings
        self.show_geometry = True     # show or hide geometry objects (axis, pois, etc)
        self.show_force = True        # show or hide forces and connectors
        self.show_visual = True       # show or hide visuals
        self.show_global = False      # show or hide the environment (sea)
        self.force_do_normalize = True # Normalize force size to 1.0 for plotting
        self.force_scale = 1.6        # Scale to be applied on (normalized) force magnitude
        self.geometry_scale = 1.0          # poi radius of the pois
        self.outline_width = vc.OUTLINE_WIDTH      # line-width of the outlines (cell-like shading)
        self.cable_line_width = 3.0   # line-width used for cable elements

        self.quick_updates_only = False # Do not perform slow updates ( make animations quicker)

        self._wavefield = None
        &#34;&#34;&#34;WaveField object&#34;&#34;&#34;

    def update_outlines(self):
        if self.screen is None:
            return

        if self.quick_updates_only:
            for outline in self.outlines:
                outline.outline_actor.SetVisibility(False)
            return

        for outline in self.outlines:
            outline.outline_actor.SetVisibility(outline.parent_vp_actor.GetVisibility())

        # list of already existing outlines
        _outlines = [a.parent_vp_actor for a in self.outlines]

        # loop over actors, add outlines if needed
        for vp_actor in self.screen.actors:
            data = vp_actor.GetMapper().GetInputAsDataSet()
            if isinstance(data, vtk.vtkPolyData):
                # this actor can have an outline
                if vp_actor not in _outlines:
                    # create outline and add to self.outlines

                    tr = vtk.vtkTransformPolyDataFilter()

                    tr.SetInputData(data) # can we make a connection using port? (maintain the pipeline : see issue vtkplotter #48)
                                          # remark: Better to implement using shaders, but wait till VTK 9 because this will change the shader code.
                    temp = vtk.vtkTransform()
                    temp.Identity()
                    tr.SetTransform(temp)
                    tr.Update()

                    ol = vtk.vtkPolyDataSilhouette()
                    ol.SetInputConnection(tr.GetOutputPort())
                    ol.SetEnableFeatureAngle(True)
                    ol.SetCamera(self.screen.renderer.GetActiveCamera())
                    ol.SetBorderEdges(True)

                    mapper = vtk.vtkPolyDataMapper()
                    mapper.SetInputConnection(ol.GetOutputPort())

                    actor = vtk.vtkActor()
                    actor.SetMapper(mapper)
                    actor.GetProperty().SetColor(0, 0, 0)
                    actor.GetProperty().SetLineWidth(self.outline_width)

                    self.screen.renderer.AddActor(actor)  # vtk actor

                    # store
                    record = VisualOutline()
                    record.outline_actor = actor
                    record.outline_transform = tr
                    record.parent_vp_actor = vp_actor
                    self.outlines.append(record)

        # Update transforms for outlines
        to_be_deleted = []
        for record in self.outlines:
            # is the parent actor still present?
            if record.parent_vp_actor in self.screen.actors:
                # update transform
                userTransform = record.parent_vp_actor.GetUserTransform()

                if userTransform is not None:
                    matrix = userTransform.GetMatrix()
                else:
                    matrix = vtk.vtkMatrix4x4()

                trans = vtk.vtkTransform()
                trans.Identity()
                trans.Concatenate(matrix)
                trans.Scale(record.parent_vp_actor.GetScale())

                record.outline_transform.SetTransform(trans)

                record.outline_actor.SetVisibility(record.parent_vp_actor.GetVisibility())

            else:
                # mark for deletion
                to_be_deleted.append(record)

        # Remove obsolete outlines

        for record in to_be_deleted:
            # remove actor
            self.screen.renderer.RemoveActor(record.outline_actor)
            self.outlines.remove(record)



    def create_world_actors(self):

        world_actors = []

        plane = vp.Plane(pos=(0,0,0), normal=(0,0,1), sx=1000, sy=1000).c(vc.COLOR_WATER)
        plane.texture(vc.TEXTURE_SEA)
        plane.lighting(ambient=1.0, diffuse=0.0, specular=0.0)
        plane.alpha(0.4)

        world_actors.append(plane)
        world_actors[0].actor_type = ActorType.GLOBAL

        if self.show_global:
            world_actors[0].on()
        else:
            world_actors[0].off()

        world_actors.append(vp.Line((0, 0, 0), (10, 0, 0)).c(&#39;red&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        world_actors.append(vp.Line((0, 0, 0), (0, 10, 0)).c(&#39;green&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        world_actors.append(vp.Line((0, 0, 0), (0, 0, 10)).c(&#39;blue&#39;))
        world_actors[-1].actor_type = ActorType.GEOMETRY

        v = VisualActor(world_actors, None)
        self.visuals.append(v)

        self.global_visual = v

    def deselect_all(self):
        for v in self.visuals:
            v.deselect()

    def node_from_vtk_actor(self, actor):
        &#34;&#34;&#34;
        Given a vkt actor, find the corresponding node
        Args:
            actor: vtkActor

        Returns:

        &#34;&#34;&#34;
        for v in self.visuals:
            for a in v.actors:
                if a == actor:
                    return v.node
        return None

    def actor_from_node(self, node):
        &#34;&#34;&#34;Finds the VisualActor belonging to node&#34;&#34;&#34;
        for v in self.visuals:
            if v.node is node:
                return v
        return None

    def add_dynamic_wave_plane(self, waveplane):
        self.remove_dynamic_wave_plane()
        self.screen.renderer.AddActor(waveplane.actor)
        self._wavefield = waveplane

        if self.global_visual.visible:
            self._staticwaveplane = True
            self.global_visual.off()
        else:
            self._staticwaveplane = False

    def remove_dynamic_wave_plane(self):
        if self._wavefield is not None:
            self.screen.renderer.RemoveActor(self._wavefield.actor)
            self._wavefield = None

            if self._staticwaveplane:
                self.global_visual.on()




    def update_dynamic_waveplane(self, t):
        if self._wavefield is not None:
            self._wavefield.update(t)


    def hide_actors_of_type(self, types):
        for V in self.visuals:
            for A in V.actors:
                if A.actor_type in types:
                    A.off()


    def show_actors_of_type(self, types):
        for V in self.visuals:
            for A in V.actors:
                    if A.actor_type in types:
                        A.on()

    def set_alpha(self, alpha, exclude_nodes=None):
        &#34;&#34;&#34;Sets the alpha (transparency) of for ALL actors in all visuals except the GLOBAL actors or visuals belonging to a node in exclude_nodes&#34;&#34;&#34;

        if exclude_nodes is None:
            exclude_nodes = []
        for V in self.visuals:
            for A in V.actors:

                if V.node in exclude_nodes:
                    continue

                if A.actor_type == ActorType.GLOBAL:
                    continue
                A.alpha(alpha)


    def level_camera(self):
        self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer().GetActiveCamera().SetViewUp([0, 0, 1])
        self.refresh_embeded_view()


    def toggle_2D(self):
        camera = self.renderer.GetActiveCamera()
        if camera.GetParallelProjection():
            camera.ParallelProjectionOff()
        else:
            camera.ParallelProjectionOn()


    def _scaled_force_vector(self, vector):

        r = np.array(vector)
        len = np.linalg.norm(r)
        if len == 0:
            return r
        if self.force_do_normalize:
            r *= (1000/len)
        r *= (self.force_scale / 1000)
        return r



    def create_visuals(self, recreate = False):
        &#34;&#34;&#34;Visuals are created in their parent axis system

        Attributes:
            recreate : re-create already exisiting visuals
        &#34;&#34;&#34;

        for N in self.scene._nodes:

            if not recreate:
                try:            # if we already have a visual, then no need to create another one
                    N.visual
                    if N.visual is not None:
                        continue
                except:
                    pass

            actors = []

            if isinstance(N, vf.Buoyancy):

                # 0 : source-mesh
                # 1 : cob
                # 2 : water-plane
                # 3 : sumberged mesh

                # This is the source-mesh. Connect it to the parent
                vis = actor_from_trimesh(N.trimesh._TriMesh)

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    vis = vp.Cube(side=0.00001)
                else:
                    vis.c(vc.COLOR_BUOYANCY_MESH_FILL)

                vis.actor_type = ActorType.FORCE

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    vis.wireframe()

                if vis is not None:
                    actors.append(vis)

                # cob
                c = vp.Sphere(r=0.5, res = vc.RESOLUTION_SPHERE).c(vc.COLOR_WATER)
                c.actor_type = ActorType.FORCE
                actors.append(c)

                # waterplane
                exts = N.trimesh.get_extends()

                cx = 0.5 * (exts[0] + exts[1])
                dx = exts[1] - exts[0]
                cy = 0.5 * (exts[3] + exts[2])
                dy = exts[3] - exts[2]

                p = vp.Plane(pos = (cx,cy,0), normal = (0,0,1), sx = dx*1.1, sy = dy*1.1).c(vc.COLOR_WATER)
                p.actor_type = ActorType.NOT_GLOBAL
                actors.append(p)


            if isinstance(N, vf.Visual):
                file = self.scene.get_resource_path(N.path)
                # visual = vp.vtkio.load(file)
                visual = vp_actor_from_obj(file)
                visual.color(vc.COLOR_VISUAL)
                visual.loaded_obj = file
                visual.actor_type = ActorType.VISUAL
                actors.append(visual)


            if isinstance(N, vf.Axis):
                size = 1
                ar = vp.Arrow((0,0,0),(size,0,0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_X)
                ag = vp.Arrow((0, 0, 0), (0, size, 0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Y)
                ab = vp.Arrow((0, 0, 0), (0, 0, size), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Z)

                ar.actor_type = ActorType.GEOMETRY
                ag.actor_type = ActorType.GEOMETRY
                ab.actor_type = ActorType.GEOMETRY

                actors.append(ar)
                actors.append(ag)
                actors.append(ab)

            if isinstance(N, vf.RigidBody):
                size = 1
                # box = vp.Box(pos=(0,0,0), length=size, width=size, height= size).c(vc.COLOR_COG)

                box = vp_actor_from_obj(self.scene.get_resource_path(&#39;cog.obj&#39;))
                box.color(vc.COLOR_COG)

                box.actor_type = ActorType.FORCE
                actors.append(box)

            if isinstance(N, vf.Poi):
                size = 1
                p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
                p.c(vc.COLOR_POI)
                p.actor_type = ActorType.GEOMETRY
                actors.append(p)

            if isinstance(N, vf.WaveInteraction1):
                size = 2
                p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
                p.c(vc.COLOR_WAVEINTERACTION)
                p.actor_type = ActorType.FORCE
                actors.append(p)

            if isinstance(N, vf.BallastSystem):

                for t in N._tanks:

                    capacity = t.max
                    volume = capacity / (1.025 * 9.81)
                    side = volume**(1/3)
                    scale = 0.5

                    p = vp.Cube(pos=(0,0,0), side=0.5*side*scale)
                    p.c(vc.COLOR_POI)
                    p.actor_type = ActorType.BALLASTTANK
                    actors.append(p)

            if isinstance(N, vf.Force):

                endpoint = self._scaled_force_vector(N.force)
                p = vp.Arrow(startPoint=(0,0,0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.c(vc.COLOR_FORCE)
                p.actor_type = ActorType.FORCE
                p._force = endpoint

                actors.append(p)

                endpoint = self._scaled_force_vector(N.moment)
                p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p._moment = endpoint
                p.c(vc.COLOR_FORCE)
                actors.append(p)

                p = vp.Arrow(startPoint = 0.2 * endpoint, endPoint= 1.2 * endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p.c(vc.COLOR_FORCE)
                actors.append(p)

            if isinstance(N, vf.Sheave):
                axis = np.array(N.axis)
                axis /= np.linalg.norm(axis)
                p = vp.Cylinder(r=1)
                p.c(vc.COLOR_SHEAVE)
                p.actor_type = ActorType.GEOMETRY

                actors.append(p)

            if isinstance(N, vf.Cable):

                if N._vfNode.global_points:
                    a = vp.Line(N._vfNode.global_points, lw=3).c(vc.COLOR_CABLE)
                else:
                    a = vp.Line([(0,0,0),(0,0,0.1),(0,0,0)], lw=3).c(vc.COLOR_CABLE)

                a.actor_type = ActorType.CABLE
                actors.append(a)

            if isinstance(N, vf.LinearBeam):

                points = list()

                for i in range(4):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_BEAM)
                a.actor_type = ActorType.CABLE

                actors.append(a)

            if isinstance(N, vf.Connector2d):

                points = list()

                for i in range(2):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
                a.actor_type = ActorType.CABLE

                actors.append(a)

            if isinstance(N, vf.LC6d):

                points = list()

                for i in range(2):
                    points.append((0,0,0))

                a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
                a.actor_type = ActorType.CABLE

                actors.append(a)



            va = VisualActor(actors, N)
            N.visual = va
            self.visuals.append(va)

            self.set_default_dsa()

    def position_visuals(self):
        &#34;&#34;&#34;All visuals are aligned with their node&#34;&#34;&#34;

        to_be_removed = []
        to_be_removed_actors = []

        for V in self.visuals:

            # check if the node still exists
            # if not, then remove the visual

            node = V.node
            if node not in self.scene._nodes:
                if len(V.actors) &gt; 0:  # not all nodes have an actor
                    if V.actors[0].actor_type != ActorType.GLOBAL:  # global visuals do not have a corresponding node
                        to_be_removed.append(V)
                        continue
                else:
                    to_be_removed.append(V)
                    continue  # node does not have an actor


            # create a transform from the Node
            # or the parent of the Node
            # or skip (for example a poi without a parent)

            if V.node is None:
                continue

            if isinstance(V.node, vf.Visual):
                A = V.actors[0]

                # get the local (user set) transform
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.offset)
                t.Scale(V.node.scale)

                # # scale offset
                # scaled_offset = [V.node.offset[i] / V.node.scale[i] for i in range(3)]


                # calculate wxys from node.rotation
                r= V.node.rotation
                angle = (r[0]**2 + r[1]**2 + r[2]**2)**(0.5)
                if angle &gt; 0:
                    t.RotateWXYZ(angle, r[0]/angle, r[1]/angle, r[2]/angle)

                # elm_matrix = t.GetMatrix()

                # Get the parent matrix (if any)
                if V.node.parent is not None:
                    apply_parent_tranlation_on_transform(V.node.parent, t)

                A.setTransform(t.GetMatrix())
                continue

            if isinstance(V.node, vf.Sheave):
                A = V.actors[0]

                # get the local (user set) transform
                t = vtk.vtkTransform()
                t.Identity()

                # scale to flat disk
                t.Scale(V.node.radius, V.node.radius, 0.1)

                # rotate z-axis (length axis is cylinder) is direction of axis
                axis = V.node.axis / np.linalg.norm(V.node.axis)
                z = (0,0,1)
                rot_axis = np.cross(z, axis)
                rot_dot = np.dot(z,axis)
                if rot_dot &gt; 1:
                    rot_dot = 1
                if rot_dot &lt; -1:
                    rot_dot = -1

                angle = np.arccos(rot_dot)

                t.PostMultiply()
                t.RotateWXYZ(np.rad2deg(angle), rot_axis)

                t.Translate(V.node.parent.position)

                # Get the parent matrix (if any)
                if V.node.parent.parent is not None:
                    apply_parent_tranlation_on_transform(V.node.parent.parent, t)

                

                A.setTransform(t.GetMatrix())
                continue

            if isinstance(V.node, vf.Cable):

                # # check the number of points
                A = V.actors[0]

                # points = list()
                # for p in V.node._pois:
                #     points.append(p.global_position)

                points = V.node.get_points_for_visual()
                
                if len(points)==0:  # not yet created
                    continue

                n_points = A.NPoints()
                A.setPoints(points)   # points can be set without allocation

                if n_points != len(points): # equal number of points
                    # different number of points in line
                    # (re-create the poly-line)
                    lines = vtk.vtkCellArray()  # Create the polyline.
                    lines.InsertNextCell(len(points))
                    for i in range(len(points)):
                        # print(&#39;inserting point {} {} {}&#39;.format(*i))
                        lines.InsertCellPoint(i)
                    A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.LinearBeam):

                # Each beam is visualized using FOUR points being
                # 0. Endpoint A
                # 1. local position (0.1*L,0,0) on endpoint A
                # 2. local position (-0.1*L,0,0) on endpoint B
                # 3. Endpoint B

                A = V.actors[0]

                d = 0

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.master.to_glob_position((d*node.L, 0, 0)))
                points.append(node.slave.to_glob_position((-d * node.L, 0, 0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))


                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.Connector2d):
                A = V.actors[0]

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))

                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue

            if isinstance(V.node, vf.LC6d):
                A = V.actors[0]

                points = list()
                points.append(node.master.to_glob_position((0,0,0)))
                points.append(node.slave.to_glob_position((0, 0, 0)))

                A.setPoints(points)

                # work-around
                # (re-create the poly-line)
                # if n_points != len(points):

                n_points = A.NPoints()

                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(n_points)
                for i in range(len(points)):
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

                continue


            if isinstance(V.node, vf.BallastSystem):
                for i,tnk in enumerate(V.node._tanks):

                    ia = i + 1

                    t = vtk.vtkTransform()
                    t.Identity()
                    local_position = np.array(V.node.position, dtype=float) + np.array(tnk.position, dtype=float)
                    pos = V.node.parent.to_glob_position(local_position)
                    t.Translate(pos)
                    V.actors[ia].setTransform(t)
                    V.actors[ia].SetScale(4)

                    if tnk.is_partial():
                        V.actors[ia].color([1,1,0])
                    if tnk.is_full():
                        V.actors[ia].color([0,0,0.2])
                    if tnk.is_empty():
                        V.actors[ia].color([0.8,0.9,1])


            if isinstance(V.node, vf.Poi):
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.global_position)
                V.actors[0].setTransform(t)
                V.actors[0].SetScale(self.geometry_scale)
                continue

            if isinstance(V.node, vf.WaveInteraction1):
                t = vtk.vtkTransform()
                t.Identity()
                t.Translate(V.node.parent.to_glob_position(V.node.offset))
                V.actors[0].setTransform(t)
                V.actors[0].SetScale(self.geometry_scale)
                continue


            if isinstance(V.node, vf.Force):

                # check is the arrows are still what they should be
                if not np.all(V.actors[0]._force == self._scaled_force_vector(V.node.force)):

                    self.screen.remove(V.actors[0])

                    endpoint = self._scaled_force_vector(V.node.force)


                    p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p._force = endpoint
                    p.c(vc.COLOR_FORCE)

                    V.actors[0] = p
                    self.screen.add(V.actors[0])

                # check is the arrows are still what they should be
                if not np.all(np.array(V.actors[1]._moment) == self._scaled_force_vector(V.node.moment)):
                    self.screen.remove(V.actors[1])
                    self.screen.remove(V.actors[2])

                    endpoint = self._scaled_force_vector(V.node.moment)
                    p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p._moment = endpoint
                    p.c(vc.COLOR_FORCE)
                    V.actors[1] = p

                    p = vp.Arrow(startPoint=0.2 * endpoint, endPoint=1.2 * endpoint, res=vc.RESOLUTION_ARROW)
                    p.actor_type = ActorType.FORCE
                    p.c(vc.COLOR_FORCE)
                    V.actors[2] = p
                    self.screen.add(V.actors[1])
                    self.screen.add(V.actors[2])

                t = V.actors[0].getTransform()
                t.Identity()
                t.Translate(V.node.parent.global_position)
                for a in V.actors:
                    a.setTransform(t)

                continue

            if isinstance(V.node, vf.RigidBody):

                # Some custom code to place and scale the Actor[3] of the body.
                # This actor should be placed at the CoG position and scaled to a solid steel block

                t = vtk.vtkTransform()
                t.Identity()

                scale = V.node.mass / 8050  # density of steel

                if scale &lt; 0.8:
                    scale = 0.8

                t.Translate(V.node.cog)
                mat4x4 = transform_to_mat4x4(V.node.global_transform)

                for A in V.actors:
                    A.setTransform(mat4x4)

                t.PostMultiply()
                t.Concatenate(mat4x4)

                V.actors[3].SetScale(scale)
                V.actors[3].setTransform(t)

                # scale the arrows
                V.actors[0].SetScale(self.geometry_scale)
                V.actors[1].SetScale(self.geometry_scale)
                V.actors[2].SetScale(self.geometry_scale)

                continue

            if isinstance(V.node, vf.Buoyancy):

                # move the full mesh with the parent
                mat4x4 = transform_to_mat4x4(V.node.parent.global_transform)
                current_transform = V.actors[0].getTransform().GetMatrix()

                # if the current transform is identical to the new one,
                # then we do not need to change anything (creating the mesh is slow)

                changed = False
                for i in range(4):
                    for j in range(4):
                        if current_transform.GetElement(i,j) != mat4x4.GetElement(i,j):
                            changed = True

                if not changed:
                    continue

                V.actors[0].setTransform(mat4x4)
                V.actors[0].alpha(vc.ALPHA_BUOYANCY)

                if vc.COLOR_BUOYANCY_MESH_FILL is None:
                    V.actors[0].c(vc.COLOR_BUOYANCY_MESH_LINES)
                    V.actors[0].wireframe()

                if self.quick_updates_only:
                    for a in V.actors:
                        a.off()
                    continue
                else:
                    for a in V.actors:
                        a.on()

                # move the CoB to the new (global!) position
                cob = V.node.cob
                V.actors[1].setTransform(transform_from_point(*cob))
                if V.node.displacement == 0:
                    V.actors[1].off()
                else:
                    V.actors[1].on()

                # update water-plane
                x1,x2,y1,y2,_,_ = V.node.trimesh.get_extends()
                x1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
                x2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
                y1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
                y2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
                p1 = V.node.parent.to_glob_position((x1,y1,0))
                p2 = V.node.parent.to_glob_position((x2, y1, 0))
                p3 = V.node.parent.to_glob_position((x2, y2, 0))
                p4 = V.node.parent.to_glob_position((x1, y2, 0))

                V.actors[2].setPoint(0,(p1[0],p1[1], 0))
                V.actors[2].setPoint(1,(p2[0],p2[1], 0))
                V.actors[2].setPoint(2,(p4[0],p4[1], 0))
                V.actors[2].setPoint(3,(p3[0],p3[1], 0))

                # create the actual buoyancy mesh as a new actor

                if len(V.actors) &gt; 3:
                    if self.screen is not None:
                        self.screen.remove(V.actors[3])
                        V.actors.remove(V.actors[3])

                mesh = V.node._vfNode.current_mesh

                if mesh.nVertices &gt; 0:  # only add when available

                    vertices = []
                    for i in range(mesh.nVertices):
                        vertices.append(mesh.GetVertex(i))

                    faces = []
                    for i in range(mesh.nFaces):
                        faces.append(mesh.GetFace(i))

                    # vis = vp.actors.Actor([vertices, faces], wire=True).c((0, 0, 1))
                    vis = vp.actors.Actor([vertices, faces]).c(vc.COLOR_BUOYANCY_MESH_LINES)
                    vis.actor_type = ActorType.FORCE
                    vis.wireframe()
                    vis.lw(vc.LINEWIDTH_SUBMERGED_MESH)
                    V.actors.append(vis)
                    if self.screen is not None:
                        self.screen.add(vis)

                continue

            if isinstance(V.node, vf.Axis):
                tr = transform_to_mat4x4(V.node.global_transform)
                for a in V.actors:
                    a.SetScale(self.geometry_scale)
                    a.setTransform(tr)

                continue

            # --- default ---

            try:
                tr = V.node.global_transform
            except AttributeError:
                try:
                    tr = V.node.parent.global_transform
                except AttributeError:
                    continue

            mat4x4 = transform_to_mat4x4(tr)

            for A in V.actors:
                A.setTransform(mat4x4)


        for V in to_be_removed:
            self.visuals.remove(V)
            self.screen.remove(V.actors)



        self.update_outlines()

    def add_new_actors_to_screen(self):
        &#34;&#34;&#34;Updates the screen with added actors&#34;&#34;&#34;

        to_be_added = []

        if self.screen:

            actors = self.screen.getActors()
            for va in self.visuals:
                for a in va.actors:
                    if not (a in actors):
                        to_be_added.append(a)
                        # self.screen.add(a)   # do not add directly to avoid frequent updates
                        #print(&#39;adding actor for {}&#39;.format(va.node.name))
            self.screen.add(to_be_added)

            # check if objs need to be re-loaded
            for va in self.visuals:
                if isinstance(va.node, vf.Visual):

                    try:
                        file = self.scene.get_resource_path(va.node.path)
                    except FileExistsError:
                        continue

                    if file == va.actors[0].loaded_obj:
                        continue

                    self.screen.clear(va.actors[0])

                    # update the obj
                    va.actors[0] = vp_actor_from_obj(file)
                    va.actors[0].loaded_obj = file
                    va.actors[0].color(vc.COLOR_VISUAL)
                    va.actors[0].actor_type = ActorType.VISUAL

                    self.screen.add(va.actors[0])

                if isinstance(va.node, vf.Buoyancy):
                    if va.node.trimesh._new_mesh:

                        new_mesh = actor_from_trimesh(va.node.trimesh._TriMesh)
                        if new_mesh is not None:
                            self.screen.clear(va.actors[0])
                            va.actors[0] = new_mesh
                            va.actors[0].actor_type = ActorType.FORCE
                            self.screen.add(va.actors[0])
                            va.node.trimesh._new_mesh = False


            self.set_default_dsa()



    def shutdown_qt(self):
        &#34;&#34;&#34;Stops the renderer such that the application can close without issues&#34;&#34;&#34;

        if self.vtkWidget:
            ren = self.vtkWidget.GetRenderWindow()
            iren = ren.GetInteractor()
            ren.Finalize()
            iren.TerminateApp()


    def screenshot(self, w=800, h=600,camera_pos=(50,-25,10), lookat = (0,0,0)):
        vp.settings.lightFollowsCamera = True

        _notebook = vp.settings.notebookBackend
        vp.settings.notebookBackend = False
        vp.settings.screeshotScale = 2

        self.create_world_actors()

        camera = dict()
        camera[&#39;viewup&#39;] = [0, 0, 1]
        camera[&#39;pos&#39;] = camera_pos
        camera[&#39;focalPoint&#39;] = lookat



        offscreen = vp.Plotter(axes=0, offscreen=True, size=(h,w))

        for va in self.visuals:
            for a in va.actors:
                if a.GetVisibility():
                    offscreen.add(a)

        offscreen.show(camera=camera)

        for r in offscreen.renderers:
            r.SetBackground(1,1,1)
            r.UseFXAAOn()

        self.update_outlines()

        filename = str(vc.PATH_TEMP_SCREENSHOT)

        vp.screenshot(filename)

        vp.settings.notebookBackend = _notebook

        from IPython.display import Image, display
        display(Image(filename))

        # import matplotlib.pyplot as plt
        # plt.figure(figsize=(w/300,h/300), dpi=300)
        # plt.imshow(plt.imread(filename))
        #
        # plt.axis(False)
        # plt.show()

    def show(self, qtWidget = None):

        vp.settings.lightFollowsCamera = True

        self.create_world_actors()

        camera = dict()
        camera[&#39;viewup&#39;] = [0, 0, 1]
        camera[&#39;pos&#39;] = [10, -10, 5]
        camera[&#39;focalPoint&#39;] = [0, 0, 0]

        if self.Jupyter:
            vp.settings.embedWindow()
            screen = vp.Plotter(axes = 4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

            # screen.add(self.create_world_actors())
            # self.create_world_actors()

            for va in self.visuals:
                for a in va.actors:
                    if a.GetVisibility():
                        screen.add(a)

            self.screen = screen
            return screen.show(camera=camera)

        else:

            if qtWidget is None:
                screen = vp.plotter.Plotter(interactive=True, offscreen=False,
                    axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)
            else:
                screen = vp.plotter.Plotter(qtWidget=qtWidget,
                                            axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

            for va in self.visuals:
                for a in va.actors:
                    screen.add(a)

        screen.show(camera=camera, verbose = False)

        self.screen = screen

        for r in screen.renderers:
            r.ResetCamera()

        self.update_outlines()

        return screen

    def onMouseLeft(self, info):
        if self.mouseLeftEvent is not None:
            self.mouseLeftEvent(info)

    def zoom_all(self):
        for r in self.screen.renderers:
            r.ResetCamera()



    def onMouseRight(self, info):
        if self.mouseRightEvent is not None:
            self.mouseRightEvent(info)

    def make_lighter(self):
        &#34;&#34;&#34;Increase light intensity for embedded mode&#34;&#34;&#34;
        C = self.light.GetIntensity()
        C += 0.05
        self.light.SetIntensity(C)
        print(&#39;Light intensity = {}&#39;.format(C))
        self.refresh_embeded_view()

    def make_darker(self):
        &#34;&#34;&#34;Decrease light intensity for embedded mode&#34;&#34;&#34;
        C = self.light.GetIntensity()
        C -= 0.05
        if C &lt;= 0:
            C = 0
        self.light.SetIntensity(C)
        print(&#39;Light intensity = {}&#39;.format(C))
        self.refresh_embeded_view()

    def show_embedded(self, target_frame):
        &#34;&#34;&#34;target frame : QFrame &#34;&#34;&#34;

        from PySide2.QtWidgets import QVBoxLayout
        from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

        # add a widget to gui
        vl = QVBoxLayout()
        self.target_frame = target_frame
        self.vtkWidget = QVTKRenderWindowInteractor(target_frame)

        vl.addWidget(self.vtkWidget)
        target_frame.setLayout(vl)

        screen = self.show(qtWidget=self.vtkWidget)

        self.renwin = self.vtkWidget.GetRenderWindow()
        self.renderer = screen.renderers[0]

        self.renwin.AddRenderer(self.renderer)

        # for r in screen.renderers:
        #     self.renwin.AddRenderer(r)

        iren = self.renwin.GetInteractor()
        iren.SetInteractorStyle(vtk.vtkInteractorStyleTrackballCamera())

        iren.AddObserver(&#34;LeftButtonPressEvent&#34;, screen._mouseleft)
        iren.AddObserver(&#34;RightButtonPressEvent&#34;, screen._mouseright)
        iren.AddObserver(&#34;MiddleButtonPressEvent&#34;, screen._mousemiddle)

        for r in screen.renderers:
            r.ResetCamera()

        iren.Start()

        screen.mouseLeftClickFunction = self.onMouseLeft
        screen.mouseRightClickFunction = self.onMouseRight

        # Add some lights


        light1 = vtk.vtkLight()

        light1.SetIntensity(0.3)
        light1.SetLightTypeToCameraLight()
        light1.SetPosition(100, 100, 100)

        self.renderer.AddLight(light1)

        self.light = light1


    def refresh_embeded_view(self):
        self.vtkWidget.update()

    def update_visibility(self):
        &#34;&#34;&#34;Updates the visibility settings for all of the actors

        A visual can be hidden completely by setting visible to false
        An actor can be hidden depending on the actor-type using

        self.show_geometry = True
        self.show_force = True
        self.show_visual = True
        self.show_global = False

        &#34;&#34;&#34;

        for v in self.visuals:
            for i,a in enumerate(v.actors):

                try:
                    a.actor_type
                except:
                    raise AttributeError(&#39;Missing actor_type for actor nr {} on node {}&#39;.format(i, v.node.name))

                if a.actor_type == ActorType.FORCE:
                    if self.show_force:
                        a.on()
                    else:
                        a.off()

                elif a.actor_type == ActorType.VISUAL:
                    if self.show_visual:
                        a.on()
                    else:
                        a.off()

                elif a.actor_type == ActorType.GEOMETRY:
                    if self.show_geometry:
                        a.on()

                    else:
                        a.off()

                elif a.actor_type == ActorType.GLOBAL:
                    if self.show_global:
                        a.on()

                        arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                        arenderer.GradientBackgroundOn()
                        arenderer.SetBackground2(vc.COLOR_BG2_ENV)
                        arenderer.SetBackground2(vc.COLOR_BG1_ENV)
                    else:
                        a.off()

                        arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                        arenderer.GradientBackgroundOn()
                        arenderer.SetBackground2(vc.COLOR_BG2)
                        arenderer.SetBackground2(vc.COLOR_BG1)

                elif a.actor_type == ActorType.NOT_GLOBAL:
                    if self.show_global:
                        a.off()
                    else:
                        a.on()



                # Cables are a separate class

                elif a.actor_type == ActorType.CABLE:
                    if self.show_visual or self.show_force:
                        a.on()
                    else:
                        a.off()

        self.update_outlines()


    def set_dsa(self, d,s,a):
        for v in self.visuals:
            v.set_dsa(d,s,a)

    def set_default_dsa(self):
        self.set_dsa(vc.VISUAL_DIFFUSE, vc.VISUAL_SPECULAR, vc.VISUAL_AMBIENT)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.visual.Viewport._wavefield"><code class="name">var <span class="ident">_wavefield</span></code></dt>
<dd>
<section class="desc"><p>WaveField object</p></section>
</dd>
<dt id="DAVE.visual.Viewport.global_visual"><code class="name">var <span class="ident">global_visual</span></code></dt>
<dd>
<section class="desc"><p>Visuals for the global environment</p></section>
</dd>
<dt id="DAVE.visual.Viewport.screen"><code class="name">var <span class="ident">screen</span></code></dt>
<dd>
<section class="desc"><p>Becomes assigned when a screen is active (or was active&hellip;)</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.visual.Viewport.actor_from_node"><code class="name flex">
<span>def <span class="ident">actor_from_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Finds the VisualActor belonging to node</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actor_from_node(self, node):
    &#34;&#34;&#34;Finds the VisualActor belonging to node&#34;&#34;&#34;
    for v in self.visuals:
        if v.node is node:
            return v
    return None</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.add_dynamic_wave_plane"><code class="name flex">
<span>def <span class="ident">add_dynamic_wave_plane</span></span>(<span>self, waveplane)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dynamic_wave_plane(self, waveplane):
    self.remove_dynamic_wave_plane()
    self.screen.renderer.AddActor(waveplane.actor)
    self._wavefield = waveplane

    if self.global_visual.visible:
        self._staticwaveplane = True
        self.global_visual.off()
    else:
        self._staticwaveplane = False</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.add_new_actors_to_screen"><code class="name flex">
<span>def <span class="ident">add_new_actors_to_screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Updates the screen with added actors</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_new_actors_to_screen(self):
    &#34;&#34;&#34;Updates the screen with added actors&#34;&#34;&#34;

    to_be_added = []

    if self.screen:

        actors = self.screen.getActors()
        for va in self.visuals:
            for a in va.actors:
                if not (a in actors):
                    to_be_added.append(a)
                    # self.screen.add(a)   # do not add directly to avoid frequent updates
                    #print(&#39;adding actor for {}&#39;.format(va.node.name))
        self.screen.add(to_be_added)

        # check if objs need to be re-loaded
        for va in self.visuals:
            if isinstance(va.node, vf.Visual):

                try:
                    file = self.scene.get_resource_path(va.node.path)
                except FileExistsError:
                    continue

                if file == va.actors[0].loaded_obj:
                    continue

                self.screen.clear(va.actors[0])

                # update the obj
                va.actors[0] = vp_actor_from_obj(file)
                va.actors[0].loaded_obj = file
                va.actors[0].color(vc.COLOR_VISUAL)
                va.actors[0].actor_type = ActorType.VISUAL

                self.screen.add(va.actors[0])

            if isinstance(va.node, vf.Buoyancy):
                if va.node.trimesh._new_mesh:

                    new_mesh = actor_from_trimesh(va.node.trimesh._TriMesh)
                    if new_mesh is not None:
                        self.screen.clear(va.actors[0])
                        va.actors[0] = new_mesh
                        va.actors[0].actor_type = ActorType.FORCE
                        self.screen.add(va.actors[0])
                        va.node.trimesh._new_mesh = False


        self.set_default_dsa()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.create_visuals"><code class="name flex">
<span>def <span class="ident">create_visuals</span></span>(<span>self, recreate=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Visuals are created in their parent axis system</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>recreate</code></strong> :&ensp;<code>re</code>-<code>create</code> <code>already</code> <code>exisiting</code> <code>visuals</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_visuals(self, recreate = False):
    &#34;&#34;&#34;Visuals are created in their parent axis system

    Attributes:
        recreate : re-create already exisiting visuals
    &#34;&#34;&#34;

    for N in self.scene._nodes:

        if not recreate:
            try:            # if we already have a visual, then no need to create another one
                N.visual
                if N.visual is not None:
                    continue
            except:
                pass

        actors = []

        if isinstance(N, vf.Buoyancy):

            # 0 : source-mesh
            # 1 : cob
            # 2 : water-plane
            # 3 : sumberged mesh

            # This is the source-mesh. Connect it to the parent
            vis = actor_from_trimesh(N.trimesh._TriMesh)

            if vc.COLOR_BUOYANCY_MESH_FILL is None:
                vis = vp.Cube(side=0.00001)
            else:
                vis.c(vc.COLOR_BUOYANCY_MESH_FILL)

            vis.actor_type = ActorType.FORCE

            if vc.COLOR_BUOYANCY_MESH_FILL is None:
                vis.wireframe()

            if vis is not None:
                actors.append(vis)

            # cob
            c = vp.Sphere(r=0.5, res = vc.RESOLUTION_SPHERE).c(vc.COLOR_WATER)
            c.actor_type = ActorType.FORCE
            actors.append(c)

            # waterplane
            exts = N.trimesh.get_extends()

            cx = 0.5 * (exts[0] + exts[1])
            dx = exts[1] - exts[0]
            cy = 0.5 * (exts[3] + exts[2])
            dy = exts[3] - exts[2]

            p = vp.Plane(pos = (cx,cy,0), normal = (0,0,1), sx = dx*1.1, sy = dy*1.1).c(vc.COLOR_WATER)
            p.actor_type = ActorType.NOT_GLOBAL
            actors.append(p)


        if isinstance(N, vf.Visual):
            file = self.scene.get_resource_path(N.path)
            # visual = vp.vtkio.load(file)
            visual = vp_actor_from_obj(file)
            visual.color(vc.COLOR_VISUAL)
            visual.loaded_obj = file
            visual.actor_type = ActorType.VISUAL
            actors.append(visual)


        if isinstance(N, vf.Axis):
            size = 1
            ar = vp.Arrow((0,0,0),(size,0,0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_X)
            ag = vp.Arrow((0, 0, 0), (0, size, 0), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Y)
            ab = vp.Arrow((0, 0, 0), (0, 0, size), res=vc.RESOLUTION_ARROW).c(vc.COLOR_Z)

            ar.actor_type = ActorType.GEOMETRY
            ag.actor_type = ActorType.GEOMETRY
            ab.actor_type = ActorType.GEOMETRY

            actors.append(ar)
            actors.append(ag)
            actors.append(ab)

        if isinstance(N, vf.RigidBody):
            size = 1
            # box = vp.Box(pos=(0,0,0), length=size, width=size, height= size).c(vc.COLOR_COG)

            box = vp_actor_from_obj(self.scene.get_resource_path(&#39;cog.obj&#39;))
            box.color(vc.COLOR_COG)

            box.actor_type = ActorType.FORCE
            actors.append(box)

        if isinstance(N, vf.Poi):
            size = 1
            p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
            p.c(vc.COLOR_POI)
            p.actor_type = ActorType.GEOMETRY
            actors.append(p)

        if isinstance(N, vf.WaveInteraction1):
            size = 2
            p = vp.Sphere(pos=(0,0,0), r=size/2, res = vc.RESOLUTION_SPHERE)
            p.c(vc.COLOR_WAVEINTERACTION)
            p.actor_type = ActorType.FORCE
            actors.append(p)

        if isinstance(N, vf.BallastSystem):

            for t in N._tanks:

                capacity = t.max
                volume = capacity / (1.025 * 9.81)
                side = volume**(1/3)
                scale = 0.5

                p = vp.Cube(pos=(0,0,0), side=0.5*side*scale)
                p.c(vc.COLOR_POI)
                p.actor_type = ActorType.BALLASTTANK
                actors.append(p)

        if isinstance(N, vf.Force):

            endpoint = self._scaled_force_vector(N.force)
            p = vp.Arrow(startPoint=(0,0,0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
            p.c(vc.COLOR_FORCE)
            p.actor_type = ActorType.FORCE
            p._force = endpoint

            actors.append(p)

            endpoint = self._scaled_force_vector(N.moment)
            p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
            p.actor_type = ActorType.FORCE
            p._moment = endpoint
            p.c(vc.COLOR_FORCE)
            actors.append(p)

            p = vp.Arrow(startPoint = 0.2 * endpoint, endPoint= 1.2 * endpoint, res=vc.RESOLUTION_ARROW)
            p.actor_type = ActorType.FORCE
            p.c(vc.COLOR_FORCE)
            actors.append(p)

        if isinstance(N, vf.Sheave):
            axis = np.array(N.axis)
            axis /= np.linalg.norm(axis)
            p = vp.Cylinder(r=1)
            p.c(vc.COLOR_SHEAVE)
            p.actor_type = ActorType.GEOMETRY

            actors.append(p)

        if isinstance(N, vf.Cable):

            if N._vfNode.global_points:
                a = vp.Line(N._vfNode.global_points, lw=3).c(vc.COLOR_CABLE)
            else:
                a = vp.Line([(0,0,0),(0,0,0.1),(0,0,0)], lw=3).c(vc.COLOR_CABLE)

            a.actor_type = ActorType.CABLE
            actors.append(a)

        if isinstance(N, vf.LinearBeam):

            points = list()

            for i in range(4):
                points.append((0,0,0))

            a = vp.Line(points, lw=5).c(vc.COLOR_BEAM)
            a.actor_type = ActorType.CABLE

            actors.append(a)

        if isinstance(N, vf.Connector2d):

            points = list()

            for i in range(2):
                points.append((0,0,0))

            a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
            a.actor_type = ActorType.CABLE

            actors.append(a)

        if isinstance(N, vf.LC6d):

            points = list()

            for i in range(2):
                points.append((0,0,0))

            a = vp.Line(points, lw=5).c(vc.COLOR_FORCE)
            a.actor_type = ActorType.CABLE

            actors.append(a)



        va = VisualActor(actors, N)
        N.visual = va
        self.visuals.append(va)

        self.set_default_dsa()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.create_world_actors"><code class="name flex">
<span>def <span class="ident">create_world_actors</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_world_actors(self):

    world_actors = []

    plane = vp.Plane(pos=(0,0,0), normal=(0,0,1), sx=1000, sy=1000).c(vc.COLOR_WATER)
    plane.texture(vc.TEXTURE_SEA)
    plane.lighting(ambient=1.0, diffuse=0.0, specular=0.0)
    plane.alpha(0.4)

    world_actors.append(plane)
    world_actors[0].actor_type = ActorType.GLOBAL

    if self.show_global:
        world_actors[0].on()
    else:
        world_actors[0].off()

    world_actors.append(vp.Line((0, 0, 0), (10, 0, 0)).c(&#39;red&#39;))
    world_actors[-1].actor_type = ActorType.GEOMETRY

    world_actors.append(vp.Line((0, 0, 0), (0, 10, 0)).c(&#39;green&#39;))
    world_actors[-1].actor_type = ActorType.GEOMETRY

    world_actors.append(vp.Line((0, 0, 0), (0, 0, 10)).c(&#39;blue&#39;))
    world_actors[-1].actor_type = ActorType.GEOMETRY

    v = VisualActor(world_actors, None)
    self.visuals.append(v)

    self.global_visual = v</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.deselect_all"><code class="name flex">
<span>def <span class="ident">deselect_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deselect_all(self):
    for v in self.visuals:
        v.deselect()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.hide_actors_of_type"><code class="name flex">
<span>def <span class="ident">hide_actors_of_type</span></span>(<span>self, types)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_actors_of_type(self, types):
    for V in self.visuals:
        for A in V.actors:
            if A.actor_type in types:
                A.off()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.level_camera"><code class="name flex">
<span>def <span class="ident">level_camera</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def level_camera(self):
    self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer().GetActiveCamera().SetViewUp([0, 0, 1])
    self.refresh_embeded_view()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.make_darker"><code class="name flex">
<span>def <span class="ident">make_darker</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Decrease light intensity for embedded mode</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_darker(self):
    &#34;&#34;&#34;Decrease light intensity for embedded mode&#34;&#34;&#34;
    C = self.light.GetIntensity()
    C -= 0.05
    if C &lt;= 0:
        C = 0
    self.light.SetIntensity(C)
    print(&#39;Light intensity = {}&#39;.format(C))
    self.refresh_embeded_view()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.make_lighter"><code class="name flex">
<span>def <span class="ident">make_lighter</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Increase light intensity for embedded mode</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_lighter(self):
    &#34;&#34;&#34;Increase light intensity for embedded mode&#34;&#34;&#34;
    C = self.light.GetIntensity()
    C += 0.05
    self.light.SetIntensity(C)
    print(&#39;Light intensity = {}&#39;.format(C))
    self.refresh_embeded_view()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.node_from_vtk_actor"><code class="name flex">
<span>def <span class="ident">node_from_vtk_actor</span></span>(<span>self, actor)</span>
</code></dt>
<dd>
<section class="desc"><p>Given a vkt actor, find the corresponding node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>actor</code></strong></dt>
<dd>vtkActor</dd>
</dl>
<p>Returns:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_from_vtk_actor(self, actor):
    &#34;&#34;&#34;
    Given a vkt actor, find the corresponding node
    Args:
        actor: vtkActor

    Returns:

    &#34;&#34;&#34;
    for v in self.visuals:
        for a in v.actors:
            if a == actor:
                return v.node
    return None</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.onMouseLeft"><code class="name flex">
<span>def <span class="ident">onMouseLeft</span></span>(<span>self, info)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMouseLeft(self, info):
    if self.mouseLeftEvent is not None:
        self.mouseLeftEvent(info)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.onMouseRight"><code class="name flex">
<span>def <span class="ident">onMouseRight</span></span>(<span>self, info)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onMouseRight(self, info):
    if self.mouseRightEvent is not None:
        self.mouseRightEvent(info)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.position_visuals"><code class="name flex">
<span>def <span class="ident">position_visuals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>All visuals are aligned with their node</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_visuals(self):
    &#34;&#34;&#34;All visuals are aligned with their node&#34;&#34;&#34;

    to_be_removed = []
    to_be_removed_actors = []

    for V in self.visuals:

        # check if the node still exists
        # if not, then remove the visual

        node = V.node
        if node not in self.scene._nodes:
            if len(V.actors) &gt; 0:  # not all nodes have an actor
                if V.actors[0].actor_type != ActorType.GLOBAL:  # global visuals do not have a corresponding node
                    to_be_removed.append(V)
                    continue
            else:
                to_be_removed.append(V)
                continue  # node does not have an actor


        # create a transform from the Node
        # or the parent of the Node
        # or skip (for example a poi without a parent)

        if V.node is None:
            continue

        if isinstance(V.node, vf.Visual):
            A = V.actors[0]

            # get the local (user set) transform
            t = vtk.vtkTransform()
            t.Identity()
            t.Translate(V.node.offset)
            t.Scale(V.node.scale)

            # # scale offset
            # scaled_offset = [V.node.offset[i] / V.node.scale[i] for i in range(3)]


            # calculate wxys from node.rotation
            r= V.node.rotation
            angle = (r[0]**2 + r[1]**2 + r[2]**2)**(0.5)
            if angle &gt; 0:
                t.RotateWXYZ(angle, r[0]/angle, r[1]/angle, r[2]/angle)

            # elm_matrix = t.GetMatrix()

            # Get the parent matrix (if any)
            if V.node.parent is not None:
                apply_parent_tranlation_on_transform(V.node.parent, t)

            A.setTransform(t.GetMatrix())
            continue

        if isinstance(V.node, vf.Sheave):
            A = V.actors[0]

            # get the local (user set) transform
            t = vtk.vtkTransform()
            t.Identity()

            # scale to flat disk
            t.Scale(V.node.radius, V.node.radius, 0.1)

            # rotate z-axis (length axis is cylinder) is direction of axis
            axis = V.node.axis / np.linalg.norm(V.node.axis)
            z = (0,0,1)
            rot_axis = np.cross(z, axis)
            rot_dot = np.dot(z,axis)
            if rot_dot &gt; 1:
                rot_dot = 1
            if rot_dot &lt; -1:
                rot_dot = -1

            angle = np.arccos(rot_dot)

            t.PostMultiply()
            t.RotateWXYZ(np.rad2deg(angle), rot_axis)

            t.Translate(V.node.parent.position)

            # Get the parent matrix (if any)
            if V.node.parent.parent is not None:
                apply_parent_tranlation_on_transform(V.node.parent.parent, t)

            

            A.setTransform(t.GetMatrix())
            continue

        if isinstance(V.node, vf.Cable):

            # # check the number of points
            A = V.actors[0]

            # points = list()
            # for p in V.node._pois:
            #     points.append(p.global_position)

            points = V.node.get_points_for_visual()
            
            if len(points)==0:  # not yet created
                continue

            n_points = A.NPoints()
            A.setPoints(points)   # points can be set without allocation

            if n_points != len(points): # equal number of points
                # different number of points in line
                # (re-create the poly-line)
                lines = vtk.vtkCellArray()  # Create the polyline.
                lines.InsertNextCell(len(points))
                for i in range(len(points)):
                    # print(&#39;inserting point {} {} {}&#39;.format(*i))
                    lines.InsertCellPoint(i)
                A.poly.SetLines(lines)

            continue

        if isinstance(V.node, vf.LinearBeam):

            # Each beam is visualized using FOUR points being
            # 0. Endpoint A
            # 1. local position (0.1*L,0,0) on endpoint A
            # 2. local position (-0.1*L,0,0) on endpoint B
            # 3. Endpoint B

            A = V.actors[0]

            d = 0

            points = list()
            points.append(node.master.to_glob_position((0,0,0)))
            points.append(node.master.to_glob_position((d*node.L, 0, 0)))
            points.append(node.slave.to_glob_position((-d * node.L, 0, 0)))
            points.append(node.slave.to_glob_position((0, 0, 0)))


            A.setPoints(points)

            # work-around
            # (re-create the poly-line)
            # if n_points != len(points):

            n_points = A.NPoints()

            lines = vtk.vtkCellArray()  # Create the polyline.
            lines.InsertNextCell(n_points)
            for i in range(len(points)):
                lines.InsertCellPoint(i)
            A.poly.SetLines(lines)

            continue

        if isinstance(V.node, vf.Connector2d):
            A = V.actors[0]

            points = list()
            points.append(node.master.to_glob_position((0,0,0)))
            points.append(node.slave.to_glob_position((0, 0, 0)))

            A.setPoints(points)

            # work-around
            # (re-create the poly-line)
            # if n_points != len(points):

            n_points = A.NPoints()

            lines = vtk.vtkCellArray()  # Create the polyline.
            lines.InsertNextCell(n_points)
            for i in range(len(points)):
                lines.InsertCellPoint(i)
            A.poly.SetLines(lines)

            continue

        if isinstance(V.node, vf.LC6d):
            A = V.actors[0]

            points = list()
            points.append(node.master.to_glob_position((0,0,0)))
            points.append(node.slave.to_glob_position((0, 0, 0)))

            A.setPoints(points)

            # work-around
            # (re-create the poly-line)
            # if n_points != len(points):

            n_points = A.NPoints()

            lines = vtk.vtkCellArray()  # Create the polyline.
            lines.InsertNextCell(n_points)
            for i in range(len(points)):
                lines.InsertCellPoint(i)
            A.poly.SetLines(lines)

            continue


        if isinstance(V.node, vf.BallastSystem):
            for i,tnk in enumerate(V.node._tanks):

                ia = i + 1

                t = vtk.vtkTransform()
                t.Identity()
                local_position = np.array(V.node.position, dtype=float) + np.array(tnk.position, dtype=float)
                pos = V.node.parent.to_glob_position(local_position)
                t.Translate(pos)
                V.actors[ia].setTransform(t)
                V.actors[ia].SetScale(4)

                if tnk.is_partial():
                    V.actors[ia].color([1,1,0])
                if tnk.is_full():
                    V.actors[ia].color([0,0,0.2])
                if tnk.is_empty():
                    V.actors[ia].color([0.8,0.9,1])


        if isinstance(V.node, vf.Poi):
            t = vtk.vtkTransform()
            t.Identity()
            t.Translate(V.node.global_position)
            V.actors[0].setTransform(t)
            V.actors[0].SetScale(self.geometry_scale)
            continue

        if isinstance(V.node, vf.WaveInteraction1):
            t = vtk.vtkTransform()
            t.Identity()
            t.Translate(V.node.parent.to_glob_position(V.node.offset))
            V.actors[0].setTransform(t)
            V.actors[0].SetScale(self.geometry_scale)
            continue


        if isinstance(V.node, vf.Force):

            # check is the arrows are still what they should be
            if not np.all(V.actors[0]._force == self._scaled_force_vector(V.node.force)):

                self.screen.remove(V.actors[0])

                endpoint = self._scaled_force_vector(V.node.force)


                p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p._force = endpoint
                p.c(vc.COLOR_FORCE)

                V.actors[0] = p
                self.screen.add(V.actors[0])

            # check is the arrows are still what they should be
            if not np.all(np.array(V.actors[1]._moment) == self._scaled_force_vector(V.node.moment)):
                self.screen.remove(V.actors[1])
                self.screen.remove(V.actors[2])

                endpoint = self._scaled_force_vector(V.node.moment)
                p = vp.Arrow(startPoint=(0, 0, 0), endPoint=endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p._moment = endpoint
                p.c(vc.COLOR_FORCE)
                V.actors[1] = p

                p = vp.Arrow(startPoint=0.2 * endpoint, endPoint=1.2 * endpoint, res=vc.RESOLUTION_ARROW)
                p.actor_type = ActorType.FORCE
                p.c(vc.COLOR_FORCE)
                V.actors[2] = p
                self.screen.add(V.actors[1])
                self.screen.add(V.actors[2])

            t = V.actors[0].getTransform()
            t.Identity()
            t.Translate(V.node.parent.global_position)
            for a in V.actors:
                a.setTransform(t)

            continue

        if isinstance(V.node, vf.RigidBody):

            # Some custom code to place and scale the Actor[3] of the body.
            # This actor should be placed at the CoG position and scaled to a solid steel block

            t = vtk.vtkTransform()
            t.Identity()

            scale = V.node.mass / 8050  # density of steel

            if scale &lt; 0.8:
                scale = 0.8

            t.Translate(V.node.cog)
            mat4x4 = transform_to_mat4x4(V.node.global_transform)

            for A in V.actors:
                A.setTransform(mat4x4)

            t.PostMultiply()
            t.Concatenate(mat4x4)

            V.actors[3].SetScale(scale)
            V.actors[3].setTransform(t)

            # scale the arrows
            V.actors[0].SetScale(self.geometry_scale)
            V.actors[1].SetScale(self.geometry_scale)
            V.actors[2].SetScale(self.geometry_scale)

            continue

        if isinstance(V.node, vf.Buoyancy):

            # move the full mesh with the parent
            mat4x4 = transform_to_mat4x4(V.node.parent.global_transform)
            current_transform = V.actors[0].getTransform().GetMatrix()

            # if the current transform is identical to the new one,
            # then we do not need to change anything (creating the mesh is slow)

            changed = False
            for i in range(4):
                for j in range(4):
                    if current_transform.GetElement(i,j) != mat4x4.GetElement(i,j):
                        changed = True

            if not changed:
                continue

            V.actors[0].setTransform(mat4x4)
            V.actors[0].alpha(vc.ALPHA_BUOYANCY)

            if vc.COLOR_BUOYANCY_MESH_FILL is None:
                V.actors[0].c(vc.COLOR_BUOYANCY_MESH_LINES)
                V.actors[0].wireframe()

            if self.quick_updates_only:
                for a in V.actors:
                    a.off()
                continue
            else:
                for a in V.actors:
                    a.on()

            # move the CoB to the new (global!) position
            cob = V.node.cob
            V.actors[1].setTransform(transform_from_point(*cob))
            if V.node.displacement == 0:
                V.actors[1].off()
            else:
                V.actors[1].on()

            # update water-plane
            x1,x2,y1,y2,_,_ = V.node.trimesh.get_extends()
            x1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
            x2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
            y1 -= vc.VISUAL_BUOYANCY_PLANE_EXTEND
            y2 += vc.VISUAL_BUOYANCY_PLANE_EXTEND
            p1 = V.node.parent.to_glob_position((x1,y1,0))
            p2 = V.node.parent.to_glob_position((x2, y1, 0))
            p3 = V.node.parent.to_glob_position((x2, y2, 0))
            p4 = V.node.parent.to_glob_position((x1, y2, 0))

            V.actors[2].setPoint(0,(p1[0],p1[1], 0))
            V.actors[2].setPoint(1,(p2[0],p2[1], 0))
            V.actors[2].setPoint(2,(p4[0],p4[1], 0))
            V.actors[2].setPoint(3,(p3[0],p3[1], 0))

            # create the actual buoyancy mesh as a new actor

            if len(V.actors) &gt; 3:
                if self.screen is not None:
                    self.screen.remove(V.actors[3])
                    V.actors.remove(V.actors[3])

            mesh = V.node._vfNode.current_mesh

            if mesh.nVertices &gt; 0:  # only add when available

                vertices = []
                for i in range(mesh.nVertices):
                    vertices.append(mesh.GetVertex(i))

                faces = []
                for i in range(mesh.nFaces):
                    faces.append(mesh.GetFace(i))

                # vis = vp.actors.Actor([vertices, faces], wire=True).c((0, 0, 1))
                vis = vp.actors.Actor([vertices, faces]).c(vc.COLOR_BUOYANCY_MESH_LINES)
                vis.actor_type = ActorType.FORCE
                vis.wireframe()
                vis.lw(vc.LINEWIDTH_SUBMERGED_MESH)
                V.actors.append(vis)
                if self.screen is not None:
                    self.screen.add(vis)

            continue

        if isinstance(V.node, vf.Axis):
            tr = transform_to_mat4x4(V.node.global_transform)
            for a in V.actors:
                a.SetScale(self.geometry_scale)
                a.setTransform(tr)

            continue

        # --- default ---

        try:
            tr = V.node.global_transform
        except AttributeError:
            try:
                tr = V.node.parent.global_transform
            except AttributeError:
                continue

        mat4x4 = transform_to_mat4x4(tr)

        for A in V.actors:
            A.setTransform(mat4x4)


    for V in to_be_removed:
        self.visuals.remove(V)
        self.screen.remove(V.actors)



    self.update_outlines()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.refresh_embeded_view"><code class="name flex">
<span>def <span class="ident">refresh_embeded_view</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_embeded_view(self):
    self.vtkWidget.update()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.remove_dynamic_wave_plane"><code class="name flex">
<span>def <span class="ident">remove_dynamic_wave_plane</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_dynamic_wave_plane(self):
    if self._wavefield is not None:
        self.screen.renderer.RemoveActor(self._wavefield.actor)
        self._wavefield = None

        if self._staticwaveplane:
            self.global_visual.on()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.screenshot"><code class="name flex">
<span>def <span class="ident">screenshot</span></span>(<span>self, w=800, h=600, camera_pos=(50, -25, 10), lookat=(0, 0, 0))</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screenshot(self, w=800, h=600,camera_pos=(50,-25,10), lookat = (0,0,0)):
    vp.settings.lightFollowsCamera = True

    _notebook = vp.settings.notebookBackend
    vp.settings.notebookBackend = False
    vp.settings.screeshotScale = 2

    self.create_world_actors()

    camera = dict()
    camera[&#39;viewup&#39;] = [0, 0, 1]
    camera[&#39;pos&#39;] = camera_pos
    camera[&#39;focalPoint&#39;] = lookat



    offscreen = vp.Plotter(axes=0, offscreen=True, size=(h,w))

    for va in self.visuals:
        for a in va.actors:
            if a.GetVisibility():
                offscreen.add(a)

    offscreen.show(camera=camera)

    for r in offscreen.renderers:
        r.SetBackground(1,1,1)
        r.UseFXAAOn()

    self.update_outlines()

    filename = str(vc.PATH_TEMP_SCREENSHOT)

    vp.screenshot(filename)

    vp.settings.notebookBackend = _notebook

    from IPython.display import Image, display
    display(Image(filename))</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.set_alpha"><code class="name flex">
<span>def <span class="ident">set_alpha</span></span>(<span>self, alpha, exclude_nodes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the alpha (transparency) of for ALL actors in all visuals except the GLOBAL actors or visuals belonging to a node in exclude_nodes</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_alpha(self, alpha, exclude_nodes=None):
    &#34;&#34;&#34;Sets the alpha (transparency) of for ALL actors in all visuals except the GLOBAL actors or visuals belonging to a node in exclude_nodes&#34;&#34;&#34;

    if exclude_nodes is None:
        exclude_nodes = []
    for V in self.visuals:
        for A in V.actors:

            if V.node in exclude_nodes:
                continue

            if A.actor_type == ActorType.GLOBAL:
                continue
            A.alpha(alpha)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.set_default_dsa"><code class="name flex">
<span>def <span class="ident">set_default_dsa</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_dsa(self):
    self.set_dsa(vc.VISUAL_DIFFUSE, vc.VISUAL_SPECULAR, vc.VISUAL_AMBIENT)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.set_dsa"><code class="name flex">
<span>def <span class="ident">set_dsa</span></span>(<span>self, d, s, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dsa(self, d,s,a):
    for v in self.visuals:
        v.set_dsa(d,s,a)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, qtWidget=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, qtWidget = None):

    vp.settings.lightFollowsCamera = True

    self.create_world_actors()

    camera = dict()
    camera[&#39;viewup&#39;] = [0, 0, 1]
    camera[&#39;pos&#39;] = [10, -10, 5]
    camera[&#39;focalPoint&#39;] = [0, 0, 0]

    if self.Jupyter:
        vp.settings.embedWindow()
        screen = vp.Plotter(axes = 4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

        # screen.add(self.create_world_actors())
        # self.create_world_actors()

        for va in self.visuals:
            for a in va.actors:
                if a.GetVisibility():
                    screen.add(a)

        self.screen = screen
        return screen.show(camera=camera)

    else:

        if qtWidget is None:
            screen = vp.plotter.Plotter(interactive=True, offscreen=False,
                axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)
        else:
            screen = vp.plotter.Plotter(qtWidget=qtWidget,
                                        axes=4, bg=vc.COLOR_BG1, bg2=vc.COLOR_BG2)

        for va in self.visuals:
            for a in va.actors:
                screen.add(a)

    screen.show(camera=camera, verbose = False)

    self.screen = screen

    for r in screen.renderers:
        r.ResetCamera()

    self.update_outlines()

    return screen</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.show_actors_of_type"><code class="name flex">
<span>def <span class="ident">show_actors_of_type</span></span>(<span>self, types)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_actors_of_type(self, types):
    for V in self.visuals:
        for A in V.actors:
                if A.actor_type in types:
                    A.on()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.show_embedded"><code class="name flex">
<span>def <span class="ident">show_embedded</span></span>(<span>self, target_frame)</span>
</code></dt>
<dd>
<section class="desc"><p>target frame : QFrame</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_embedded(self, target_frame):
    &#34;&#34;&#34;target frame : QFrame &#34;&#34;&#34;

    from PySide2.QtWidgets import QVBoxLayout
    from vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

    # add a widget to gui
    vl = QVBoxLayout()
    self.target_frame = target_frame
    self.vtkWidget = QVTKRenderWindowInteractor(target_frame)

    vl.addWidget(self.vtkWidget)
    target_frame.setLayout(vl)

    screen = self.show(qtWidget=self.vtkWidget)

    self.renwin = self.vtkWidget.GetRenderWindow()
    self.renderer = screen.renderers[0]

    self.renwin.AddRenderer(self.renderer)

    # for r in screen.renderers:
    #     self.renwin.AddRenderer(r)

    iren = self.renwin.GetInteractor()
    iren.SetInteractorStyle(vtk.vtkInteractorStyleTrackballCamera())

    iren.AddObserver(&#34;LeftButtonPressEvent&#34;, screen._mouseleft)
    iren.AddObserver(&#34;RightButtonPressEvent&#34;, screen._mouseright)
    iren.AddObserver(&#34;MiddleButtonPressEvent&#34;, screen._mousemiddle)

    for r in screen.renderers:
        r.ResetCamera()

    iren.Start()

    screen.mouseLeftClickFunction = self.onMouseLeft
    screen.mouseRightClickFunction = self.onMouseRight

    # Add some lights


    light1 = vtk.vtkLight()

    light1.SetIntensity(0.3)
    light1.SetLightTypeToCameraLight()
    light1.SetPosition(100, 100, 100)

    self.renderer.AddLight(light1)

    self.light = light1</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.shutdown_qt"><code class="name flex">
<span>def <span class="ident">shutdown_qt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Stops the renderer such that the application can close without issues</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown_qt(self):
    &#34;&#34;&#34;Stops the renderer such that the application can close without issues&#34;&#34;&#34;

    if self.vtkWidget:
        ren = self.vtkWidget.GetRenderWindow()
        iren = ren.GetInteractor()
        ren.Finalize()
        iren.TerminateApp()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.toggle_2D"><code class="name flex">
<span>def <span class="ident">toggle_2D</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_2D(self):
    camera = self.renderer.GetActiveCamera()
    if camera.GetParallelProjection():
        camera.ParallelProjectionOff()
    else:
        camera.ParallelProjectionOn()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.update_dynamic_waveplane"><code class="name flex">
<span>def <span class="ident">update_dynamic_waveplane</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_dynamic_waveplane(self, t):
    if self._wavefield is not None:
        self._wavefield.update(t)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.update_outlines"><code class="name flex">
<span>def <span class="ident">update_outlines</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_outlines(self):
    if self.screen is None:
        return

    if self.quick_updates_only:
        for outline in self.outlines:
            outline.outline_actor.SetVisibility(False)
        return

    for outline in self.outlines:
        outline.outline_actor.SetVisibility(outline.parent_vp_actor.GetVisibility())

    # list of already existing outlines
    _outlines = [a.parent_vp_actor for a in self.outlines]

    # loop over actors, add outlines if needed
    for vp_actor in self.screen.actors:
        data = vp_actor.GetMapper().GetInputAsDataSet()
        if isinstance(data, vtk.vtkPolyData):
            # this actor can have an outline
            if vp_actor not in _outlines:
                # create outline and add to self.outlines

                tr = vtk.vtkTransformPolyDataFilter()

                tr.SetInputData(data) # can we make a connection using port? (maintain the pipeline : see issue vtkplotter #48)
                                      # remark: Better to implement using shaders, but wait till VTK 9 because this will change the shader code.
                temp = vtk.vtkTransform()
                temp.Identity()
                tr.SetTransform(temp)
                tr.Update()

                ol = vtk.vtkPolyDataSilhouette()
                ol.SetInputConnection(tr.GetOutputPort())
                ol.SetEnableFeatureAngle(True)
                ol.SetCamera(self.screen.renderer.GetActiveCamera())
                ol.SetBorderEdges(True)

                mapper = vtk.vtkPolyDataMapper()
                mapper.SetInputConnection(ol.GetOutputPort())

                actor = vtk.vtkActor()
                actor.SetMapper(mapper)
                actor.GetProperty().SetColor(0, 0, 0)
                actor.GetProperty().SetLineWidth(self.outline_width)

                self.screen.renderer.AddActor(actor)  # vtk actor

                # store
                record = VisualOutline()
                record.outline_actor = actor
                record.outline_transform = tr
                record.parent_vp_actor = vp_actor
                self.outlines.append(record)

    # Update transforms for outlines
    to_be_deleted = []
    for record in self.outlines:
        # is the parent actor still present?
        if record.parent_vp_actor in self.screen.actors:
            # update transform
            userTransform = record.parent_vp_actor.GetUserTransform()

            if userTransform is not None:
                matrix = userTransform.GetMatrix()
            else:
                matrix = vtk.vtkMatrix4x4()

            trans = vtk.vtkTransform()
            trans.Identity()
            trans.Concatenate(matrix)
            trans.Scale(record.parent_vp_actor.GetScale())

            record.outline_transform.SetTransform(trans)

            record.outline_actor.SetVisibility(record.parent_vp_actor.GetVisibility())

        else:
            # mark for deletion
            to_be_deleted.append(record)

    # Remove obsolete outlines

    for record in to_be_deleted:
        # remove actor
        self.screen.renderer.RemoveActor(record.outline_actor)
        self.outlines.remove(record)</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.update_visibility"><code class="name flex">
<span>def <span class="ident">update_visibility</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Updates the visibility settings for all of the actors</p>
<p>A visual can be hidden completely by setting visible to false
An actor can be hidden depending on the actor-type using</p>
<p>self.show_geometry = True
self.show_force = True
self.show_visual = True
self.show_global = False</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_visibility(self):
    &#34;&#34;&#34;Updates the visibility settings for all of the actors

    A visual can be hidden completely by setting visible to false
    An actor can be hidden depending on the actor-type using

    self.show_geometry = True
    self.show_force = True
    self.show_visual = True
    self.show_global = False

    &#34;&#34;&#34;

    for v in self.visuals:
        for i,a in enumerate(v.actors):

            try:
                a.actor_type
            except:
                raise AttributeError(&#39;Missing actor_type for actor nr {} on node {}&#39;.format(i, v.node.name))

            if a.actor_type == ActorType.FORCE:
                if self.show_force:
                    a.on()
                else:
                    a.off()

            elif a.actor_type == ActorType.VISUAL:
                if self.show_visual:
                    a.on()
                else:
                    a.off()

            elif a.actor_type == ActorType.GEOMETRY:
                if self.show_geometry:
                    a.on()

                else:
                    a.off()

            elif a.actor_type == ActorType.GLOBAL:
                if self.show_global:
                    a.on()

                    arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                    arenderer.GradientBackgroundOn()
                    arenderer.SetBackground2(vc.COLOR_BG2_ENV)
                    arenderer.SetBackground2(vc.COLOR_BG1_ENV)
                else:
                    a.off()

                    arenderer = self.vtkWidget.GetRenderWindow().GetRenderers().GetFirstRenderer()
                    arenderer.GradientBackgroundOn()
                    arenderer.SetBackground2(vc.COLOR_BG2)
                    arenderer.SetBackground2(vc.COLOR_BG1)

            elif a.actor_type == ActorType.NOT_GLOBAL:
                if self.show_global:
                    a.off()
                else:
                    a.on()



            # Cables are a separate class

            elif a.actor_type == ActorType.CABLE:
                if self.show_visual or self.show_force:
                    a.on()
                else:
                    a.off()

    self.update_outlines()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.Viewport.zoom_all"><code class="name flex">
<span>def <span class="ident">zoom_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zoom_all(self):
    for r in self.screen.renderers:
        r.ResetCamera()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.visual.VisualActor"><code class="flex name class">
<span>class <span class="ident">VisualActor</span></span>
<span>(</span><span>actors, node)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisualActor:

    def __init__(self, actors, node):
        self.actors = actors  # vtkplotter actors
        self.node = node      # Node
        # self.visible = True
        self._original_colors = list()
        self._is_selected = False
        self._is_transparent = False

    def select(self):

        if self._is_selected:
            return

        self._original_colors = list()

        if self.node is not None:
            print(&#39;storing &#39; + str(self.node.name))
        else:
            print(&#39;storing properties&#39;)

        for actor in self.actors:
            self._original_colors.append(actor.color())
            actor.color(vc.COLOR_SELECT)

        self._is_selected = True


    def deselect(self):

        print(&#39;resetting original colors 1&#39;)

        if not self._is_selected:
            return

        print(&#39;resetting original colors 2&#39;)

        self._is_selected = False

        if self._original_colors:

            if self.node is not None:
                print(&#39;setting &#39; + str(self.node.name))
            else:
                print(&#39;setting properties&#39;)


            for actor, color in zip(self.actors, self._original_colors):
                actor.color(color)

        else:
            raise Exception(&#34;Original color not stored for visual belonging to {}&#34;.format(self.node.name))


    def make_transparent(self):

        if self._is_transparent:
            return

        for a in self.actors:
            a.alpha(0.4)

        self._is_transparent = True

    def reset_opacity(self):

        if not self._is_transparent:
            return

        for a in self.actors:
            if a.actor_type == ActorType.GLOBAL:
                a.alpha(0.4)
            else:
                a.alpha(1)

        self._is_transparent = False

    def set_dsa(self, d,s,a):
        for act in self.actors:
            act.lighting(diffuse=vc.VISUAL_DIFFUSE, ambient=vc.VISUAL_AMBIENT, specular=vc.VISUAL_SPECULAR, enabled=True)

    def on(self):
        for a in self.actors:
            a.on()

    def off(self):
        for a in self.actors:
            a.off()

    @property
    def visible(self):
        return self.actors[0].GetVisibility()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.visual.VisualActor.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def visible(self):
    return self.actors[0].GetVisibility()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.visual.VisualActor.deselect"><code class="name flex">
<span>def <span class="ident">deselect</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deselect(self):

    print(&#39;resetting original colors 1&#39;)

    if not self._is_selected:
        return

    print(&#39;resetting original colors 2&#39;)

    self._is_selected = False

    if self._original_colors:

        if self.node is not None:
            print(&#39;setting &#39; + str(self.node.name))
        else:
            print(&#39;setting properties&#39;)


        for actor, color in zip(self.actors, self._original_colors):
            actor.color(color)

    else:
        raise Exception(&#34;Original color not stored for visual belonging to {}&#34;.format(self.node.name))</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.make_transparent"><code class="name flex">
<span>def <span class="ident">make_transparent</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_transparent(self):

    if self._is_transparent:
        return

    for a in self.actors:
        a.alpha(0.4)

    self._is_transparent = True</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.off"><code class="name flex">
<span>def <span class="ident">off</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def off(self):
    for a in self.actors:
        a.off()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self):
    for a in self.actors:
        a.on()</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.reset_opacity"><code class="name flex">
<span>def <span class="ident">reset_opacity</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_opacity(self):

    if not self._is_transparent:
        return

    for a in self.actors:
        if a.actor_type == ActorType.GLOBAL:
            a.alpha(0.4)
        else:
            a.alpha(1)

    self._is_transparent = False</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self):

    if self._is_selected:
        return

    self._original_colors = list()

    if self.node is not None:
        print(&#39;storing &#39; + str(self.node.name))
    else:
        print(&#39;storing properties&#39;)

    for actor in self.actors:
        self._original_colors.append(actor.color())
        actor.color(vc.COLOR_SELECT)

    self._is_selected = True</code></pre>
</details>
</dd>
<dt id="DAVE.visual.VisualActor.set_dsa"><code class="name flex">
<span>def <span class="ident">set_dsa</span></span>(<span>self, d, s, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dsa(self, d,s,a):
    for act in self.actors:
        act.lighting(diffuse=vc.VISUAL_DIFFUSE, ambient=vc.VISUAL_AMBIENT, specular=vc.VISUAL_SPECULAR, enabled=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.visual.VisualOutline"><code class="flex name class">
<span>class <span class="ident">VisualOutline</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisualOutline:
    parent_vp_actor = None
    outline_actor = None
    outline_transform = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="DAVE.visual.VisualOutline.outline_actor"><code class="name">var <span class="ident">outline_actor</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="DAVE.visual.VisualOutline.outline_transform"><code class="name">var <span class="ident">outline_transform</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="DAVE.visual.VisualOutline.parent_vp_actor"><code class="name">var <span class="ident">parent_vp_actor</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="DAVE.visual.WaveField"><code class="flex name class">
<span>class <span class="ident">WaveField</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaveField():

    def __init__(self):
        self.actor = None
        self.pts = None
        self.nt = 0
        self.elevation = None

        self.texture = vtk.vtkTexture()
        input = vtk.vtkJPEGReader()
        input.SetFileName(vc.TEXTURE_SEA)
        self.texture.SetInputConnection(input.GetOutputPort())
        self.ttp = vtk.vtkTextureMapToPlane()


    def update(self, t):
        t = np.mod(t, self.period)
        i = int(self.nt * t/self.period)

        count = 0
        for ix,xx in enumerate(self.x):
            for iy, yy in enumerate(self.y):
                self.pts.SetPoint(count, xx,yy,self.elevation[iy,ix,i])
                count += 1
        self.pts.Modified()

    def create_waveplane(self, wave_direction, wave_amplitude, wave_length, wave_period, nt, nx, ny, dx,dy):

        x = np.linspace(-dx, dx, nx)
        y = np.linspace(-dy, dy, ny)
        xv, yv = np.meshgrid(x, y)

        u = np.array((np.cos(np.deg2rad(wave_direction)), np.sin(np.deg2rad(wave_direction))))

        dist_phasor = np.exp(1j * (xv*u[0] + yv*u[1]) * (2*np.pi/ wave_length))

        t = np.linspace(0,wave_period, nt)
        time_phasor = np.exp(-1j * (2 * np.pi * t / wave_period))

        elevation = np.zeros((*xv.shape, nt))

        for i in range(nt):
            elevation[:,:,i] = wave_amplitude * np.real(time_phasor[i] * dist_phasor)


        # the vtk stuff

        # make grid
        pts = vtk.vtkPoints()
        for ix,xx in enumerate(x):
            for iy, yy in enumerate(y):
                pts.InsertNextPoint(yy,xx,elevation[iy,ix,1])

        grid = vtk.vtkStructuredGrid()
        grid.SetDimensions(ny,nx,1)
        grid.SetPoints(pts)

        # make mapper
        filter = vtk.vtkStructuredGridGeometryFilter()
        filter.SetInputData(grid)

        # texture stuff
        self.ttp.SetInputConnection(filter.GetOutputPort())

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(self.ttp.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)
        actor.SetTexture(self.texture)

        actor.GetProperty().SetAmbient(1.0)
        actor.GetProperty().SetDiffuse(0.0)
        actor.GetProperty().SetSpecular(0.0)

        self.pts = pts
        self.actor = actor
        self.elevation = elevation
        self.nt = nt
        self.period = wave_period
        self.x = x
        self.y = y</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="DAVE.visual.WaveField.create_waveplane"><code class="name flex">
<span>def <span class="ident">create_waveplane</span></span>(<span>self, wave_direction, wave_amplitude, wave_length, wave_period, nt, nx, ny, dx, dy)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_waveplane(self, wave_direction, wave_amplitude, wave_length, wave_period, nt, nx, ny, dx,dy):

    x = np.linspace(-dx, dx, nx)
    y = np.linspace(-dy, dy, ny)
    xv, yv = np.meshgrid(x, y)

    u = np.array((np.cos(np.deg2rad(wave_direction)), np.sin(np.deg2rad(wave_direction))))

    dist_phasor = np.exp(1j * (xv*u[0] + yv*u[1]) * (2*np.pi/ wave_length))

    t = np.linspace(0,wave_period, nt)
    time_phasor = np.exp(-1j * (2 * np.pi * t / wave_period))

    elevation = np.zeros((*xv.shape, nt))

    for i in range(nt):
        elevation[:,:,i] = wave_amplitude * np.real(time_phasor[i] * dist_phasor)


    # the vtk stuff

    # make grid
    pts = vtk.vtkPoints()
    for ix,xx in enumerate(x):
        for iy, yy in enumerate(y):
            pts.InsertNextPoint(yy,xx,elevation[iy,ix,1])

    grid = vtk.vtkStructuredGrid()
    grid.SetDimensions(ny,nx,1)
    grid.SetPoints(pts)

    # make mapper
    filter = vtk.vtkStructuredGridGeometryFilter()
    filter.SetInputData(grid)

    # texture stuff
    self.ttp.SetInputConnection(filter.GetOutputPort())

    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputConnection(self.ttp.GetOutputPort())

    actor = vtk.vtkActor()
    actor.SetMapper(mapper)
    actor.SetTexture(self.texture)

    actor.GetProperty().SetAmbient(1.0)
    actor.GetProperty().SetDiffuse(0.0)
    actor.GetProperty().SetSpecular(0.0)

    self.pts = pts
    self.actor = actor
    self.elevation = elevation
    self.nt = nt
    self.period = wave_period
    self.x = x
    self.y = y</code></pre>
</details>
</dd>
<dt id="DAVE.visual.WaveField.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, t):
    t = np.mod(t, self.period)
    i = int(self.nt * t/self.period)

    count = 0
    for ix,xx in enumerate(self.x):
        for iy, yy in enumerate(self.y):
            self.pts.SetPoint(count, xx,yy,self.elevation[iy,ix,i])
            count += 1
    self.pts.Modified()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="DAVE" href="index.html">DAVE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DAVE.visual.actor_from_trimesh" href="#DAVE.visual.actor_from_trimesh">actor_from_trimesh</a></code></li>
<li><code><a title="DAVE.visual.apply_parent_tranlation_on_transform" href="#DAVE.visual.apply_parent_tranlation_on_transform">apply_parent_tranlation_on_transform</a></code></li>
<li><code><a title="DAVE.visual.transform_from_direction" href="#DAVE.visual.transform_from_direction">transform_from_direction</a></code></li>
<li><code><a title="DAVE.visual.transform_from_point" href="#DAVE.visual.transform_from_point">transform_from_point</a></code></li>
<li><code><a title="DAVE.visual.transform_to_mat4x4" href="#DAVE.visual.transform_to_mat4x4">transform_to_mat4x4</a></code></li>
<li><code><a title="DAVE.visual.vp_actor_from_obj" href="#DAVE.visual.vp_actor_from_obj">vp_actor_from_obj</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="DAVE.visual.ActorType" href="#DAVE.visual.ActorType">ActorType</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.visual.ActorType.BALLASTTANK" href="#DAVE.visual.ActorType.BALLASTTANK">BALLASTTANK</a></code></li>
<li><code><a title="DAVE.visual.ActorType.CABLE" href="#DAVE.visual.ActorType.CABLE">CABLE</a></code></li>
<li><code><a title="DAVE.visual.ActorType.FORCE" href="#DAVE.visual.ActorType.FORCE">FORCE</a></code></li>
<li><code><a title="DAVE.visual.ActorType.GEOMETRY" href="#DAVE.visual.ActorType.GEOMETRY">GEOMETRY</a></code></li>
<li><code><a title="DAVE.visual.ActorType.GLOBAL" href="#DAVE.visual.ActorType.GLOBAL">GLOBAL</a></code></li>
<li><code><a title="DAVE.visual.ActorType.NOT_GLOBAL" href="#DAVE.visual.ActorType.NOT_GLOBAL">NOT_GLOBAL</a></code></li>
<li><code><a title="DAVE.visual.ActorType.VISUAL" href="#DAVE.visual.ActorType.VISUAL">VISUAL</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.visual.Viewport" href="#DAVE.visual.Viewport">Viewport</a></code></h4>
<ul class="">
<li><code><a title="DAVE.visual.Viewport._wavefield" href="#DAVE.visual.Viewport._wavefield">_wavefield</a></code></li>
<li><code><a title="DAVE.visual.Viewport.actor_from_node" href="#DAVE.visual.Viewport.actor_from_node">actor_from_node</a></code></li>
<li><code><a title="DAVE.visual.Viewport.add_dynamic_wave_plane" href="#DAVE.visual.Viewport.add_dynamic_wave_plane">add_dynamic_wave_plane</a></code></li>
<li><code><a title="DAVE.visual.Viewport.add_new_actors_to_screen" href="#DAVE.visual.Viewport.add_new_actors_to_screen">add_new_actors_to_screen</a></code></li>
<li><code><a title="DAVE.visual.Viewport.create_visuals" href="#DAVE.visual.Viewport.create_visuals">create_visuals</a></code></li>
<li><code><a title="DAVE.visual.Viewport.create_world_actors" href="#DAVE.visual.Viewport.create_world_actors">create_world_actors</a></code></li>
<li><code><a title="DAVE.visual.Viewport.deselect_all" href="#DAVE.visual.Viewport.deselect_all">deselect_all</a></code></li>
<li><code><a title="DAVE.visual.Viewport.global_visual" href="#DAVE.visual.Viewport.global_visual">global_visual</a></code></li>
<li><code><a title="DAVE.visual.Viewport.hide_actors_of_type" href="#DAVE.visual.Viewport.hide_actors_of_type">hide_actors_of_type</a></code></li>
<li><code><a title="DAVE.visual.Viewport.level_camera" href="#DAVE.visual.Viewport.level_camera">level_camera</a></code></li>
<li><code><a title="DAVE.visual.Viewport.make_darker" href="#DAVE.visual.Viewport.make_darker">make_darker</a></code></li>
<li><code><a title="DAVE.visual.Viewport.make_lighter" href="#DAVE.visual.Viewport.make_lighter">make_lighter</a></code></li>
<li><code><a title="DAVE.visual.Viewport.node_from_vtk_actor" href="#DAVE.visual.Viewport.node_from_vtk_actor">node_from_vtk_actor</a></code></li>
<li><code><a title="DAVE.visual.Viewport.onMouseLeft" href="#DAVE.visual.Viewport.onMouseLeft">onMouseLeft</a></code></li>
<li><code><a title="DAVE.visual.Viewport.onMouseRight" href="#DAVE.visual.Viewport.onMouseRight">onMouseRight</a></code></li>
<li><code><a title="DAVE.visual.Viewport.position_visuals" href="#DAVE.visual.Viewport.position_visuals">position_visuals</a></code></li>
<li><code><a title="DAVE.visual.Viewport.refresh_embeded_view" href="#DAVE.visual.Viewport.refresh_embeded_view">refresh_embeded_view</a></code></li>
<li><code><a title="DAVE.visual.Viewport.remove_dynamic_wave_plane" href="#DAVE.visual.Viewport.remove_dynamic_wave_plane">remove_dynamic_wave_plane</a></code></li>
<li><code><a title="DAVE.visual.Viewport.screen" href="#DAVE.visual.Viewport.screen">screen</a></code></li>
<li><code><a title="DAVE.visual.Viewport.screenshot" href="#DAVE.visual.Viewport.screenshot">screenshot</a></code></li>
<li><code><a title="DAVE.visual.Viewport.set_alpha" href="#DAVE.visual.Viewport.set_alpha">set_alpha</a></code></li>
<li><code><a title="DAVE.visual.Viewport.set_default_dsa" href="#DAVE.visual.Viewport.set_default_dsa">set_default_dsa</a></code></li>
<li><code><a title="DAVE.visual.Viewport.set_dsa" href="#DAVE.visual.Viewport.set_dsa">set_dsa</a></code></li>
<li><code><a title="DAVE.visual.Viewport.show" href="#DAVE.visual.Viewport.show">show</a></code></li>
<li><code><a title="DAVE.visual.Viewport.show_actors_of_type" href="#DAVE.visual.Viewport.show_actors_of_type">show_actors_of_type</a></code></li>
<li><code><a title="DAVE.visual.Viewport.show_embedded" href="#DAVE.visual.Viewport.show_embedded">show_embedded</a></code></li>
<li><code><a title="DAVE.visual.Viewport.shutdown_qt" href="#DAVE.visual.Viewport.shutdown_qt">shutdown_qt</a></code></li>
<li><code><a title="DAVE.visual.Viewport.toggle_2D" href="#DAVE.visual.Viewport.toggle_2D">toggle_2D</a></code></li>
<li><code><a title="DAVE.visual.Viewport.update_dynamic_waveplane" href="#DAVE.visual.Viewport.update_dynamic_waveplane">update_dynamic_waveplane</a></code></li>
<li><code><a title="DAVE.visual.Viewport.update_outlines" href="#DAVE.visual.Viewport.update_outlines">update_outlines</a></code></li>
<li><code><a title="DAVE.visual.Viewport.update_visibility" href="#DAVE.visual.Viewport.update_visibility">update_visibility</a></code></li>
<li><code><a title="DAVE.visual.Viewport.zoom_all" href="#DAVE.visual.Viewport.zoom_all">zoom_all</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.visual.VisualActor" href="#DAVE.visual.VisualActor">VisualActor</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.visual.VisualActor.deselect" href="#DAVE.visual.VisualActor.deselect">deselect</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.make_transparent" href="#DAVE.visual.VisualActor.make_transparent">make_transparent</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.off" href="#DAVE.visual.VisualActor.off">off</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.on" href="#DAVE.visual.VisualActor.on">on</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.reset_opacity" href="#DAVE.visual.VisualActor.reset_opacity">reset_opacity</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.select" href="#DAVE.visual.VisualActor.select">select</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.set_dsa" href="#DAVE.visual.VisualActor.set_dsa">set_dsa</a></code></li>
<li><code><a title="DAVE.visual.VisualActor.visible" href="#DAVE.visual.VisualActor.visible">visible</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.visual.VisualOutline" href="#DAVE.visual.VisualOutline">VisualOutline</a></code></h4>
<ul class="">
<li><code><a title="DAVE.visual.VisualOutline.outline_actor" href="#DAVE.visual.VisualOutline.outline_actor">outline_actor</a></code></li>
<li><code><a title="DAVE.visual.VisualOutline.outline_transform" href="#DAVE.visual.VisualOutline.outline_transform">outline_transform</a></code></li>
<li><code><a title="DAVE.visual.VisualOutline.parent_vp_actor" href="#DAVE.visual.VisualOutline.parent_vp_actor">parent_vp_actor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.visual.WaveField" href="#DAVE.visual.WaveField">WaveField</a></code></h4>
<ul class="">
<li><code><a title="DAVE.visual.WaveField.create_waveplane" href="#DAVE.visual.WaveField.create_waveplane">create_waveplane</a></code></li>
<li><code><a title="DAVE.visual.WaveField.update" href="#DAVE.visual.WaveField.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>